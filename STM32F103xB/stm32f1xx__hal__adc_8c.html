<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>STM32F103xB HAL User Manual: stm32f1xx_hal_adc.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">STM32F103xB HAL User Manual
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_87d736d687b37c2c2535f3171b4da10d.html">Firmware</a>      </li>
      <li class="navelem"><a class="el" href="dir_77a4a036479ba611396f4796e3271770.html">Drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_e90ca8f7a3453277a713b77fb925b18f.html">STM32F1xx_HAL_Driver</a>      </li>
      <li class="navelem"><a class="el" href="dir_08b87254197b135abc61821bb66d28f7.html">Src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">stm32f1xx_hal_adc.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides firmware functions to manage the following functionalities of the Analog to Digital Convertor (ADC) peripheral: + Initialization and de-initialization functions ++ Initialization and Configuration of ADC + Operation functions ++ Start, stop, get result of conversions of regular group, using 3 possible modes: polling, interruption or DMA. + Control functions ++ Channels configuration on regular group ++ Channels configuration on injected group ++ Analog Watchdog configuration + State functions ++ ADC state machine management ++ Interrupts and flags management Other functions (extended functions) are available in file "stm32f1xx_hal_adc_ex.c".  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;stm32f1xx_hal.h&quot;</code><br/>
</div>
<p><a href="stm32f1xx__hal__adc_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Constants.html#gac60dabae20327f91cbd7c93bf1d5c40f">ADC_ENABLE_TIMEOUT</a>&#160;&#160;&#160;2U</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Constants.html#ga2b268ea01bfa472a0c004fb34cc48c38">ADC_DISABLE_TIMEOUT</a>&#160;&#160;&#160;2U</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Constants.html#gad0d1562099d9e378dd1d33b3519cd0c2">ADC_STAB_DELAY_US</a>&#160;&#160;&#160;1U</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Constants.html#gab57114ba262a4b64193617b22da005b0">ADC_TEMPSENSOR_DELAY_US</a>&#160;&#160;&#160;10U</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group1.html#ga33ddb73d4880bd425aaa43c5c52bb13a">HAL_ADC_Init</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the ADC peripheral and regular group according to parameters specified in structure "ADC_InitTypeDef".  <a href="group__ADC__Exported__Functions__Group1.html#ga33ddb73d4880bd425aaa43c5c52bb13a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group1.html#ga165940b437c6a8843c6032199adbf0a8">HAL_ADC_DeInit</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the ADC peripheral registers to their default reset values, with deinitialization of the ADC MSP.  <a href="group__ADC__Exported__Functions__Group1.html#ga165940b437c6a8843c6032199adbf0a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group1.html#gaa30863492d5c3103e3e8ce8a63dadd07">HAL_ADC_MspInit</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the ADC MSP.  <a href="group__ADC__Exported__Functions__Group1.html#gaa30863492d5c3103e3e8ce8a63dadd07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group1.html#ga39b0f8e80268ab3e660ead921ad4b22f">HAL_ADC_MspDeInit</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DeInitializes the ADC MSP.  <a href="group__ADC__Exported__Functions__Group1.html#ga39b0f8e80268ab3e660ead921ad4b22f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga193666e3bde978627c9ee1e2073c69c0">HAL_ADC_Start</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables ADC, starts conversion of regular group.  <a href="group__ADC__Exported__Functions__Group2.html#ga193666e3bde978627c9ee1e2073c69c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga1b00cb85fc6c0f40fabd02701528711d">HAL_ADC_Stop</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop ADC conversion of regular group (and injected channels in case of auto_injection mode), disable ADC peripheral.  <a href="group__ADC__Exported__Functions__Group2.html#ga1b00cb85fc6c0f40fabd02701528711d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gad9c0b5763ab75357407e22d310befc30">HAL_ADC_PollForConversion</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc, uint32_t Timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for regular group conversion to be completed.  <a href="group__ADC__Exported__Functions__Group2.html#gad9c0b5763ab75357407e22d310befc30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga139d1a4ab69bea84cb39918840e1a64e">HAL_ADC_PollForEvent</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc, uint32_t EventType, uint32_t Timeout)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll for conversion event.  <a href="group__ADC__Exported__Functions__Group2.html#ga139d1a4ab69bea84cb39918840e1a64e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gaeb53035f47a937d54de2164d6c939a04">HAL_ADC_Start_IT</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables ADC, starts conversion of regular group with interruption.  <a href="group__ADC__Exported__Functions__Group2.html#gaeb53035f47a937d54de2164d6c939a04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gae44e6d3d0d9c60897daa7ccfd368952c">HAL_ADC_Stop_IT</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop ADC conversion of regular group (and injected group in case of auto_injection mode), disable interrution of end-of-conversion, disable ADC peripheral.  <a href="group__ADC__Exported__Functions__Group2.html#gae44e6d3d0d9c60897daa7ccfd368952c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga7c3ef5532dddebe7fd76bb8f589d11fd">HAL_ADC_Start_DMA</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc, uint32_t *pData, uint32_t Length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables ADC, starts conversion of regular group and transfers result through DMA.  <a href="group__ADC__Exported__Functions__Group2.html#ga7c3ef5532dddebe7fd76bb8f589d11fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gae113bcf7fc3d8ce07d68403bb5a11560">HAL_ADC_Stop_DMA</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop ADC conversion of regular group (and injected group in case of auto_injection mode), disable ADC DMA transfer, disable ADC peripheral.  <a href="group__ADC__Exported__Functions__Group2.html#gae113bcf7fc3d8ce07d68403bb5a11560"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga421008ca3885339acb12f400958ffbe4">HAL_ADC_GetValue</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC regular group conversion result.  <a href="group__ADC__Exported__Functions__Group2.html#ga421008ca3885339acb12f400958ffbe4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga28aaa5662eced92c5a4d23d8bd6b29ca">HAL_ADC_IRQHandler</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles ADC interrupt request.  <a href="group__ADC__Exported__Functions__Group2.html#ga28aaa5662eced92c5a4d23d8bd6b29ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gaf20a88180db1113be1e89266917d148b">HAL_ADC_ConvCpltCallback</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion complete callback in non blocking mode.  <a href="group__ADC__Exported__Functions__Group2.html#gaf20a88180db1113be1e89266917d148b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gad7e3dafc08886b97b9c9e23267645b9e">HAL_ADC_ConvHalfCpltCallback</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion DMA half-transfer callback in non blocking mode.  <a href="group__ADC__Exported__Functions__Group2.html#gad7e3dafc08886b97b9c9e23267645b9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#ga8cf5c59c6355fe7cf3c10816c761b9c2">HAL_ADC_LevelOutOfWindowCallback</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog watchdog callback in non blocking mode.  <a href="group__ADC__Exported__Functions__Group2.html#ga8cf5c59c6355fe7cf3c10816c761b9c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">__weak void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group2.html#gadea1a55c5199d5cb4cfc1fdcd32be1b2">HAL_ADC_ErrorCallback</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ADC error callback in non blocking mode (ADC conversion with interruption or transfer by DMA)  <a href="group__ADC__Exported__Functions__Group2.html#gadea1a55c5199d5cb4cfc1fdcd32be1b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group3.html#gac6f70c4927204d6f50ab44c8e4800106">HAL_ADC_ConfigChannel</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc, <a class="el" href="structADC__ChannelConfTypeDef.html">ADC_ChannelConfTypeDef</a> *sConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the the selected channel to be linked to the regular group.  <a href="group__ADC__Exported__Functions__Group3.html#gac6f70c4927204d6f50ab44c8e4800106"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group3.html#gaebd9d3c15de8c92e92e18ee38d1bd998">HAL_ADC_AnalogWDGConfig</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc, <a class="el" href="structADC__AnalogWDGConfTypeDef.html">ADC_AnalogWDGConfTypeDef</a> *AnalogWDGConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the analog watchdog.  <a href="group__ADC__Exported__Functions__Group3.html#gaebd9d3c15de8c92e92e18ee38d1bd998"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group4.html#ga894143f0fa1502ac0afa6eae8fdaadcc">HAL_ADC_GetState</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">return the ADC state  <a href="group__ADC__Exported__Functions__Group4.html#ga894143f0fa1502ac0afa6eae8fdaadcc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Exported__Functions__Group4.html#ga3a546afb96f473f266573783f37ee8af">HAL_ADC_GetError</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ADC error code.  <a href="group__ADC__Exported__Functions__Group4.html#ga3a546afb96f473f266573783f37ee8af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Functions.html#ga034b9253bac7f083ec43b5b09873ebf1">ADC_Enable</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the selected ADC.  <a href="group__ADC__Private__Functions.html#ga034b9253bac7f083ec43b5b09873ebf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HAL_StatusTypeDef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Functions.html#ga646e302bd6f80b1a063f31b556806630">ADC_ConversionStop_Disable</a> (<a class="el" href="group__ADC__Exported__Types.html#ga46483fcdb7a528252920c304ec59d006">ADC_HandleTypeDef</a> *hadc)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop ADC conversion and disable the selected ADC.  <a href="group__ADC__Private__Functions.html#ga646e302bd6f80b1a063f31b556806630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Functions.html#ga055840e53820295bac4f4f0998ffcfb0">ADC_DMAConvCplt</a> (<a class="el" href="group/group__DMA__Exported__Types.html#ga92b907d56a9c29b93d46782a7a04f91e">DMA_HandleTypeDef</a> *hdma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA transfer complete callback.  <a href="group__ADC__Private__Functions.html#ga055840e53820295bac4f4f0998ffcfb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Functions.html#ga27abcd16a928caf2b6c719ea67c12b25">ADC_DMAHalfConvCplt</a> (<a class="el" href="group/group__DMA__Exported__Types.html#ga92b907d56a9c29b93d46782a7a04f91e">DMA_HandleTypeDef</a> *hdma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA half transfer complete callback.  <a href="group__ADC__Private__Functions.html#ga27abcd16a928caf2b6c719ea67c12b25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__Private__Functions.html#gaede41b9e917d64ad31fbbb8ae9fab79c">ADC_DMAError</a> (<a class="el" href="group/group__DMA__Exported__Types.html#ga92b907d56a9c29b93d46782a7a04f91e">DMA_HandleTypeDef</a> *hdma)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">DMA error callback.  <a href="group__ADC__Private__Functions.html#gaede41b9e917d64ad31fbbb8ae9fab79c"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file provides firmware functions to manage the following functionalities of the Analog to Digital Convertor (ADC) peripheral: + Initialization and de-initialization functions ++ Initialization and Configuration of ADC + Operation functions ++ Start, stop, get result of conversions of regular group, using 3 possible modes: polling, interruption or DMA. + Control functions ++ Channels configuration on regular group ++ Channels configuration on injected group ++ Analog Watchdog configuration + State functions ++ ADC state machine management ++ Interrupts and flags management Other functions (extended functions) are available in file "stm32f1xx_hal_adc_ex.c". </p>
<dl class="author"><dt><b>Author:</b></dt><dd>MCD Application Team <div class="fragment"><pre class="fragment">
  ==============================================================================
                     ##### ADC peripheral features #####
  ==============================================================================
  [..]
  (+) 12-bit resolution

  (+) Interrupt generation at the end of regular conversion, end of injected
      conversion, and in case of analog watchdog or overrun events.
  
  (+) Single and continuous conversion modes.
  
  (+) Scan mode for conversion of several channels sequentially.
  
  (+) Data alignment with in-built data coherency.
  
  (+) Programmable sampling time (channel wise)
  
  (+) ADC conversion of regular group and injected group.

  (+) External trigger (timer or EXTI) 
      for both regular and injected groups.

  (+) DMA request generation for transfer of conversions data of regular group.

  (+) Multimode Dual mode (available on devices with 2 ADCs or more).
  
  (+) Configurable DMA data storage in Multimode Dual mode (available on devices
      with 2 DCs or more).
  
  (+) Configurable delay between conversions in Dual interleaved mode (available 
      on devices with 2 DCs or more).
  
  (+) ADC calibration

  (+) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
      slower speed.
  
  (+) ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to 
      Vdda or to an external voltage reference).


                     ##### How to use this driver #####
  ==============================================================================
    [..]

     *** Configuration of top level parameters related to ADC ***
     ============================================================
     [..]

    (#) Enable the ADC interface
      (++) As prerequisite, ADC clock must be configured at RCC top level.
           Caution: On STM32F1, ADC clock frequency max is 14MHz (refer
                    to device datasheet).
                    Therefore, ADC clock prescaler must be configured in 
                    function of ADC clock source frequency to remain below
                    this maximum frequency.
        (++) One clock setting is mandatory:
             ADC clock (core clock, also possibly conversion clock).
             (+++) Example:
                   Into HAL_ADC_MspInit() (recommended code location) or with
                   other device clock parameters configuration:
               (+++) RCC_PeriphCLKInitTypeDef  PeriphClkInit;
               (+++) __ADC1_CLK_ENABLE();
               (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
               (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
               (+++) HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit);

    (#) ADC pins configuration
         (++) Enable the clock for the ADC GPIOs
              using macro __HAL_RCC_GPIOx_CLK_ENABLE()
         (++) Configure these ADC pins in analog mode
              using function HAL_GPIO_Init()

    (#) Optionally, in case of usage of ADC with interruptions:
         (++) Configure the NVIC for ADC
              using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
         (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
              into the function of corresponding ADC interruption vector 
              ADCx_IRQHandler().

    (#) Optionally, in case of usage of DMA:
         (++) Configure the DMA (DMA channel, mode normal or circular, ...)
              using function HAL_DMA_Init().
         (++) Configure the NVIC for DMA
              using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
         (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
              into the function of corresponding DMA interruption vector 
              DMAx_Channelx_IRQHandler().

     *** Configuration of ADC, groups regular/injected, channels parameters ***
     ==========================================================================
     [..]

    (#) Configure the ADC parameters (resolution, data alignment, ...)
        and regular group parameters (conversion trigger, sequencer, ...)
        using function HAL_ADC_Init().

    (#) Configure the channels for regular group parameters (channel number, 
        channel rank into sequencer, ..., into regular group)
        using function HAL_ADC_ConfigChannel().

    (#) Optionally, configure the injected group parameters (conversion trigger, 
        sequencer, ..., of injected group)
        and the channels for injected group parameters (channel number, 
        channel rank into sequencer, ..., into injected group)
        using function HAL_ADCEx_InjectedConfigChannel().

    (#) Optionally, configure the analog watchdog parameters (channels
        monitored, thresholds, ...)
        using function HAL_ADC_AnalogWDGConfig().

    (#) Optionally, for devices with several ADC instances: configure the 
        multimode parameters
        using function HAL_ADCEx_MultiModeConfigChannel().

     *** Execution of ADC conversions ***
     ====================================
     [..]

    (#) Optionally, perform an automatic ADC calibration to improve the
        conversion accuracy
        using function HAL_ADCEx_Calibration_Start().

    (#) ADC driver can be used among three modes: polling, interruption,
        transfer by DMA.

        (++) ADC conversion by polling:
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start()
          (+++) Wait for ADC conversion completion 
                using function HAL_ADC_PollForConversion()
                (or for injected group: HAL_ADCEx_InjectedPollForConversion() )
          (+++) Retrieve conversion results 
                using function HAL_ADC_GetValue()
                (or for injected group: HAL_ADCEx_InjectedGetValue() )
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop()

        (++) ADC conversion by interruption: 
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start_IT()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback()
                (this function must be implemented in user program)
                (or for injected group: HAL_ADCEx_InjectedConvCpltCallback() )
          (+++) Retrieve conversion results 
                using function HAL_ADC_GetValue()
                (or for injected group: HAL_ADCEx_InjectedGetValue() )
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop_IT()

        (++) ADC conversion with transfer by DMA:
          (+++) Activate the ADC peripheral and start conversions
                using function HAL_ADC_Start_DMA()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
                (these functions must be implemented in user program)
          (+++) Conversion results are automatically transferred by DMA into
                destination variable address.
          (+++) Stop conversion and disable the ADC peripheral 
                using function HAL_ADC_Stop_DMA()

        (++) For devices with several ADCs: ADC multimode conversion 
             with transfer by DMA:
          (+++) Activate the ADC peripheral (slave) and start conversions
                using function HAL_ADC_Start()
          (+++) Activate the ADC peripheral (master) and start conversions
                using function HAL_ADCEx_MultiModeStart_DMA()
          (+++) Wait for ADC conversion completion by call of function
                HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
                (these functions must be implemented in user program)
          (+++) Conversion results are automatically transferred by DMA into
                destination variable address.
          (+++) Stop conversion and disable the ADC peripheral (master)
                using function HAL_ADCEx_MultiModeStop_DMA()
          (+++) Stop conversion and disable the ADC peripheral (slave)
                using function HAL_ADC_Stop_IT()

     [..]

    (@) Callback functions must be implemented in user program:
      (+@) HAL_ADC_ErrorCallback()
      (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
      (+@) HAL_ADC_ConvCpltCallback()
      (+@) HAL_ADC_ConvHalfCpltCallback
      (+@) HAL_ADCEx_InjectedConvCpltCallback()

     *** Deinitialization of ADC ***
     ============================================================
     [..]

    (#) Disable the ADC interface
      (++) ADC clock can be hard reset and disabled at RCC top level.
        (++) Hard reset of ADC peripherals
             using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
        (++) ADC clock disable
             using the equivalent macro/functions as configuration step.
             (+++) Example:
                   Into HAL_ADC_MspDeInit() (recommended code location) or with
                   other device clock parameters configuration:
               (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC
               (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF
               (+++) HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInit)

    (#) ADC pins configuration
         (++) Disable the clock for the ADC GPIOs
              using macro __HAL_RCC_GPIOx_CLK_DISABLE()

    (#) Optionally, in case of usage of ADC with interruptions:
         (++) Disable the NVIC for ADC
              using function HAL_NVIC_EnableIRQ(ADCx_IRQn)

    (#) Optionally, in case of usage of DMA:
         (++) Deinitialize the DMA
              using function HAL_DMA_Init().
         (++) Disable the NVIC for DMA
              using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)

    [..]
    
    *** Callback registration ***
    =============================================
    [..]

     The compilation flag USE_HAL_ADC_REGISTER_CALLBACKS, when set to 1,
     allows the user to configure dynamically the driver callbacks.
     Use Functions @ref HAL_ADC_RegisterCallback()
     to register an interrupt callback.
    [..]

     Function @ref HAL_ADC_RegisterCallback() allows to register following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     This function takes as parameters the HAL peripheral handle, the Callback ID
     and a pointer to the user callback function.
    [..]

     Use function @ref HAL_ADC_UnRegisterCallback to reset a callback to the default
     weak function.
    [..]

     @ref HAL_ADC_UnRegisterCallback takes as parameters the HAL peripheral handle,
     and the Callback ID.
     This function allows to reset following callbacks:
       (+) ConvCpltCallback               : ADC conversion complete callback
       (+) ConvHalfCpltCallback           : ADC conversion DMA half-transfer callback
       (+) LevelOutOfWindowCallback       : ADC analog watchdog 1 callback
       (+) ErrorCallback                  : ADC error callback
       (+) InjectedConvCpltCallback       : ADC group injected conversion complete callback
       (+) MspInitCallback                : ADC Msp Init callback
       (+) MspDeInitCallback              : ADC Msp DeInit callback
     [..]

     By default, after the @ref HAL_ADC_Init() and when the state is @ref HAL_ADC_STATE_RESET
     all callbacks are set to the corresponding weak functions:
     examples @ref HAL_ADC_ConvCpltCallback(), @ref HAL_ADC_ErrorCallback().
     Exception done for MspInit and MspDeInit functions that are
     reset to the legacy weak functions in the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit() only when
     these callbacks are null (not registered beforehand).
    [..]

     If MspInit or MspDeInit are not null, the @ref HAL_ADC_Init()/ @ref HAL_ADC_DeInit()
     keep and use the user MspInit/MspDeInit callbacks (registered beforehand) whatever the state.
     [..]

     Callbacks can be registered/unregistered in @ref HAL_ADC_STATE_READY state only.
     Exception done MspInit/MspDeInit functions that can be registered/unregistered
     in @ref HAL_ADC_STATE_READY or @ref HAL_ADC_STATE_RESET state,
     thus registered (user) MspInit/DeInit callbacks can be used during the Init/DeInit.
    [..]

     Then, the user first registers the MspInit/MspDeInit user callbacks
     using @ref HAL_ADC_RegisterCallback() before calling @ref HAL_ADC_DeInit()
     or @ref HAL_ADC_Init() function.
     [..]

     When the compilation flag USE_HAL_ADC_REGISTER_CALLBACKS is set to 0 or
     not defined, the callback registration feature is not available and all callbacks
     are set to the corresponding weak functions.
  
  </pre></div></dd></dl>
<dl class="attention"><dt><b>Attention:</b></dt><dd></dd></dl>
<h2><center>&copy; Copyright (c) 2016 STMicroelectronics. All rights reserved.</center></h2>
<p>This software component is licensed by ST under BSD 3-Clause license, the "License"; You may not use this file except in compliance with the License. You may obtain a copy of the License at: opensource.org/licenses/BSD-3-Clause </p>

<p>Definition in file <a class="el" href="stm32f1xx__hal__adc_8c_source.html">stm32f1xx_hal_adc.c</a>.</p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue May 14 2019 08:55:21 for STM32F103xB HAL User Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
