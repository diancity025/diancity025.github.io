<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>STM32F103xG HAL User Manual: stm32f1xx_hal_nand.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">STM32F103xG HAL User Manual
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_87d736d687b37c2c2535f3171b4da10d.html">Firmware</a>      </li>
      <li class="navelem"><a class="el" href="dir_77a4a036479ba611396f4796e3271770.html">Drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_e90ca8f7a3453277a713b77fb925b18f.html">STM32F1xx_HAL_Driver</a>      </li>
      <li class="navelem"><a class="el" href="dir_08b87254197b135abc61821bb66d28f7.html">Src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">stm32f1xx_hal_nand.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="stm32f1xx__hal__nand_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment">  ******************************************************************************</span>
<a name="l00003"></a>00003 <span class="comment">  * @file    stm32f1xx_hal_nand.c</span>
<a name="l00004"></a>00004 <span class="comment">  * @author  MCD Application Team</span>
<a name="l00005"></a>00005 <span class="comment">  * @brief   NAND HAL module driver.</span>
<a name="l00006"></a>00006 <span class="comment">  *          This file provides a generic firmware to drive NAND memories mounted</span>
<a name="l00007"></a>00007 <span class="comment">  *          as external device.</span>
<a name="l00008"></a>00008 <span class="comment">  *</span>
<a name="l00009"></a>00009 <span class="comment">  @verbatim</span>
<a name="l00010"></a>00010 <span class="comment">  ==============================================================================</span>
<a name="l00011"></a>00011 <span class="comment">                         ##### How to use this driver #####</span>
<a name="l00012"></a>00012 <span class="comment">  ==============================================================================</span>
<a name="l00013"></a>00013 <span class="comment">    [..]</span>
<a name="l00014"></a>00014 <span class="comment">      This driver is a generic layered driver which contains a set of APIs used to</span>
<a name="l00015"></a>00015 <span class="comment">      control NAND flash memories. It uses the FSMC layer functions to interface</span>
<a name="l00016"></a>00016 <span class="comment">      with NAND devices. This driver is used as follows:</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">      (+) NAND flash memory configuration sequence using the function HAL_NAND_Init()</span>
<a name="l00019"></a>00019 <span class="comment">          with control and timing parameters for both common and attribute spaces.</span>
<a name="l00020"></a>00020 <span class="comment"></span>
<a name="l00021"></a>00021 <span class="comment">      (+) Read NAND flash memory maker and device IDs using the function</span>
<a name="l00022"></a>00022 <span class="comment">          HAL_NAND_Read_ID(). The read information is stored in the NAND_ID_TypeDef</span>
<a name="l00023"></a>00023 <span class="comment">          structure declared by the function caller.</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">      (+) Access NAND flash memory by read/write operations using the functions</span>
<a name="l00026"></a>00026 <span class="comment">          HAL_NAND_Read_Page_8b()/HAL_NAND_Read_SpareArea_8b(),</span>
<a name="l00027"></a>00027 <span class="comment">          HAL_NAND_Write_Page_8b()/HAL_NAND_Write_SpareArea_8b(),</span>
<a name="l00028"></a>00028 <span class="comment">          HAL_NAND_Read_Page_16b()/HAL_NAND_Read_SpareArea_16b(),</span>
<a name="l00029"></a>00029 <span class="comment">          HAL_NAND_Write_Page_16b()/HAL_NAND_Write_SpareArea_16b()</span>
<a name="l00030"></a>00030 <span class="comment">          to read/write page(s)/spare area(s). These functions use specific device</span>
<a name="l00031"></a>00031 <span class="comment">          information (Block, page size..) predefined by the user in the NAND_DeviceConfigTypeDef</span>
<a name="l00032"></a>00032 <span class="comment">          structure. The read/write address information is contained by the Nand_Address_Typedef</span>
<a name="l00033"></a>00033 <span class="comment">          structure passed as parameter.</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">      (+) Perform NAND flash Reset chip operation using the function HAL_NAND_Reset().</span>
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">      (+) Perform NAND flash erase block operation using the function HAL_NAND_Erase_Block().</span>
<a name="l00038"></a>00038 <span class="comment">          The erase block address information is contained in the Nand_Address_Typedef</span>
<a name="l00039"></a>00039 <span class="comment">          structure passed as parameter.</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">      (+) Read the NAND flash status operation using the function HAL_NAND_Read_Status().</span>
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">      (+) You can also control the NAND device by calling the control APIs HAL_NAND_ECC_Enable()/</span>
<a name="l00044"></a>00044 <span class="comment">          HAL_NAND_ECC_Disable() to respectively enable/disable the ECC code correction</span>
<a name="l00045"></a>00045 <span class="comment">          feature or the function HAL_NAND_GetECC() to get the ECC correction code.</span>
<a name="l00046"></a>00046 <span class="comment"></span>
<a name="l00047"></a>00047 <span class="comment">      (+) You can monitor the NAND device HAL state by calling the function</span>
<a name="l00048"></a>00048 <span class="comment">          HAL_NAND_GetState()</span>
<a name="l00049"></a>00049 <span class="comment"></span>
<a name="l00050"></a>00050 <span class="comment">    [..]</span>
<a name="l00051"></a>00051 <span class="comment">      (@) This driver is a set of generic APIs which handle standard NAND flash operations.</span>
<a name="l00052"></a>00052 <span class="comment">          If a NAND flash device contains different operations and/or implementations,</span>
<a name="l00053"></a>00053 <span class="comment">          it should be implemented separately.</span>
<a name="l00054"></a>00054 <span class="comment"></span>
<a name="l00055"></a>00055 <span class="comment">    *** Callback registration ***</span>
<a name="l00056"></a>00056 <span class="comment">    =============================================</span>
<a name="l00057"></a>00057 <span class="comment">    [..]</span>
<a name="l00058"></a>00058 <span class="comment">      The compilation define  USE_HAL_NAND_REGISTER_CALLBACKS when set to 1</span>
<a name="l00059"></a>00059 <span class="comment">      allows the user to configure dynamically the driver callbacks.</span>
<a name="l00060"></a>00060 <span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">      Use Functions @ref HAL_NAND_RegisterCallback() to register a user callback,</span>
<a name="l00062"></a>00062 <span class="comment">      it allows to register following callbacks:</span>
<a name="l00063"></a>00063 <span class="comment">        (+) MspInitCallback    : NAND MspInit.</span>
<a name="l00064"></a>00064 <span class="comment">        (+) MspDeInitCallback  : NAND MspDeInit.</span>
<a name="l00065"></a>00065 <span class="comment">      This function takes as parameters the HAL peripheral handle, the Callback ID</span>
<a name="l00066"></a>00066 <span class="comment">      and a pointer to the user callback function.</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">      Use function @ref HAL_NAND_UnRegisterCallback() to reset a callback to the default</span>
<a name="l00069"></a>00069 <span class="comment">      weak (surcharged) function. It allows to reset following callbacks:</span>
<a name="l00070"></a>00070 <span class="comment">        (+) MspInitCallback    : NAND MspInit.</span>
<a name="l00071"></a>00071 <span class="comment">        (+) MspDeInitCallback  : NAND MspDeInit.</span>
<a name="l00072"></a>00072 <span class="comment">      This function) takes as parameters the HAL peripheral handle and the Callback ID.</span>
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">      By default, after the @ref HAL_NAND_Init and if the state is HAL_NAND_STATE_RESET</span>
<a name="l00075"></a>00075 <span class="comment">      all callbacks are reset to the corresponding legacy weak (surcharged) functions.</span>
<a name="l00076"></a>00076 <span class="comment">      Exception done for MspInit and MspDeInit callbacks that are respectively</span>
<a name="l00077"></a>00077 <span class="comment">      reset to the legacy weak (surcharged) functions in the @ref HAL_NAND_Init</span>
<a name="l00078"></a>00078 <span class="comment">      and @ref  HAL_NAND_DeInit only when these callbacks are null (not registered beforehand).</span>
<a name="l00079"></a>00079 <span class="comment">      If not, MspInit or MspDeInit are not null, the @ref HAL_NAND_Init and @ref HAL_NAND_DeInit</span>
<a name="l00080"></a>00080 <span class="comment">      keep and use the user MspInit/MspDeInit callbacks (registered beforehand)</span>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">      Callbacks can be registered/unregistered in READY state only.</span>
<a name="l00083"></a>00083 <span class="comment">      Exception done for MspInit/MspDeInit callbacks that can be registered/unregistered</span>
<a name="l00084"></a>00084 <span class="comment">      in READY or RESET state, thus registered (user) MspInit/DeInit callbacks can be used</span>
<a name="l00085"></a>00085 <span class="comment">      during the Init/DeInit.</span>
<a name="l00086"></a>00086 <span class="comment">      In that case first register the MspInit/MspDeInit user callbacks</span>
<a name="l00087"></a>00087 <span class="comment">      using @ref HAL_NAND_RegisterCallback before calling @ref HAL_NAND_DeInit</span>
<a name="l00088"></a>00088 <span class="comment">      or @ref HAL_NAND_Init function.</span>
<a name="l00089"></a>00089 <span class="comment"></span>
<a name="l00090"></a>00090 <span class="comment">      When The compilation define USE_HAL_NAND_REGISTER_CALLBACKS is set to 0 or</span>
<a name="l00091"></a>00091 <span class="comment">      not defined, the callback registering feature is not available</span>
<a name="l00092"></a>00092 <span class="comment">      and weak (surcharged) callbacks are used.</span>
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">  @endverbatim</span>
<a name="l00095"></a>00095 <span class="comment">  ******************************************************************************</span>
<a name="l00096"></a>00096 <span class="comment">  * @attention</span>
<a name="l00097"></a>00097 <span class="comment">  *</span>
<a name="l00098"></a>00098 <span class="comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.</span>
<a name="l00099"></a>00099 <span class="comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span>
<a name="l00100"></a>00100 <span class="comment">  *</span>
<a name="l00101"></a>00101 <span class="comment">  * This software component is licensed by ST under BSD 3-Clause license,</span>
<a name="l00102"></a>00102 <span class="comment">  * the &quot;License&quot;; You may not use this file except in compliance with the</span>
<a name="l00103"></a>00103 <span class="comment">  * License. You may obtain a copy of the License at:</span>
<a name="l00104"></a>00104 <span class="comment">  *                       opensource.org/licenses/BSD-3-Clause</span>
<a name="l00105"></a>00105 <span class="comment">  *</span>
<a name="l00106"></a>00106 <span class="comment">  ******************************************************************************</span>
<a name="l00107"></a>00107 <span class="comment">  */</span>
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="comment">/* Includes ------------------------------------------------------------------*/</span>
<a name="l00110"></a>00110 <span class="preprocessor">#include &quot;<a class="code" href="stm32f1xx__hal_8h.html" title="This file contains all the functions prototypes for the HAL module driver.">stm32f1xx_hal.h</a>&quot;</span>
<a name="l00111"></a>00111 
<a name="l00112"></a>00112 <span class="preprocessor">#if defined(FSMC_BANK3)</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment">/** @addtogroup STM32F1xx_HAL_Driver</span>
<a name="l00115"></a>00115 <span class="comment">  * @{</span>
<a name="l00116"></a>00116 <span class="comment">  */</span>
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="preprocessor">#ifdef HAL_NAND_MODULE_ENABLED</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">/** @defgroup NAND NAND</span>
<a name="l00121"></a>00121 <span class="comment">  * @brief NAND HAL module driver</span>
<a name="l00122"></a>00122 <span class="comment">  * @{</span>
<a name="l00123"></a>00123 <span class="comment">  */</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* Private typedef -----------------------------------------------------------*/</span>
<a name="l00126"></a>00126 <span class="comment">/* Private Constants ------------------------------------------------------------*/</span>
<a name="l00127"></a>00127 <span class="comment">/* Private macro -------------------------------------------------------------*/</span>
<a name="l00128"></a>00128 <span class="comment">/* Private variables ---------------------------------------------------------*/</span>
<a name="l00129"></a>00129 <span class="comment">/* Private function prototypes -----------------------------------------------*/</span>
<a name="l00130"></a>00130 <span class="comment">/* Exported functions ---------------------------------------------------------*/</span>
<a name="l00131"></a>00131 <span class="comment"></span>
<a name="l00132"></a>00132 <span class="comment">/** @defgroup NAND_Exported_Functions NAND Exported Functions</span>
<a name="l00133"></a>00133 <span class="comment">  * @{</span>
<a name="l00134"></a>00134 <span class="comment">  */</span>
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">/** @defgroup NAND_Exported_Functions_Group1 Initialization and de-initialization functions</span>
<a name="l00137"></a>00137 <span class="comment">  * @brief    Initialization and Configuration functions</span>
<a name="l00138"></a>00138 <span class="comment">  *</span>
<a name="l00139"></a>00139 <span class="comment">  @verbatim</span>
<a name="l00140"></a>00140 <span class="comment">  ==============================================================================</span>
<a name="l00141"></a>00141 <span class="comment">            ##### NAND Initialization and de-initialization functions #####</span>
<a name="l00142"></a>00142 <span class="comment">  ==============================================================================</span>
<a name="l00143"></a>00143 <span class="comment">  [..]</span>
<a name="l00144"></a>00144 <span class="comment">    This section provides functions allowing to initialize/de-initialize</span>
<a name="l00145"></a>00145 <span class="comment">    the NAND memory</span>
<a name="l00146"></a>00146 <span class="comment"></span>
<a name="l00147"></a>00147 <span class="comment">@endverbatim</span>
<a name="l00148"></a>00148 <span class="comment">  * @{</span>
<a name="l00149"></a>00149 <span class="comment">  */</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a>00151 <span class="comment">/**</span>
<a name="l00152"></a>00152 <span class="comment">  * @brief  Perform NAND memory Initialization sequence</span>
<a name="l00153"></a>00153 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00154"></a>00154 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00155"></a>00155 <span class="comment">  * @param  ComSpace_Timing pointer to Common space timing structure</span>
<a name="l00156"></a>00156 <span class="comment">  * @param  AttSpace_Timing pointer to Attribute space timing structure</span>
<a name="l00157"></a>00157 <span class="comment">  * @retval HAL status</span>
<a name="l00158"></a>00158 <span class="comment">  */</span>
<a name="l00159"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#gaa815fe8e1d472d361682f50755f9e671">00159</a> HAL_StatusTypeDef  <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#gaa815fe8e1d472d361682f50755f9e671" title="Perform NAND memory Initialization sequence.">HAL_NAND_Init</a>(NAND_HandleTypeDef *hnand, FSMC_NAND_PCC_TimingTypeDef *ComSpace_Timing, FSMC_NAND_PCC_TimingTypeDef *AttSpace_Timing)
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161   <span class="comment">/* Check the NAND handle state */</span>
<a name="l00162"></a>00162   <span class="keywordflow">if</span> (hnand == NULL)
<a name="l00163"></a>00163   {
<a name="l00164"></a>00164     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00165"></a>00165   }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_RESET)
<a name="l00168"></a>00168   {
<a name="l00169"></a>00169     <span class="comment">/* Allocate lock resource and initialize it */</span>
<a name="l00170"></a>00170     hnand-&gt;Lock = HAL_UNLOCKED;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(hnand-&gt;MspInitCallback == NULL)
<a name="l00174"></a>00174     {
<a name="l00175"></a>00175       hnand-&gt;MspInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404" title="NAND MSP Init.">HAL_NAND_MspInit</a>;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177     hnand-&gt;ItCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179     <span class="comment">/* Init the low level hardware */</span>
<a name="l00180"></a>00180     hnand-&gt;MspInitCallback(hnand);
<a name="l00181"></a>00181 <span class="preprocessor">#else</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>    <span class="comment">/* Initialize the low level hardware (MSP) */</span>
<a name="l00183"></a>00183     <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404" title="NAND MSP Init.">HAL_NAND_MspInit</a>(hnand);
<a name="l00184"></a>00184 <span class="preprocessor">#endif</span>
<a name="l00185"></a>00185 <span class="preprocessor"></span>  }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">/* Initialize NAND control Interface */</span>
<a name="l00188"></a>00188   (void)FSMC_NAND_Init(hnand-&gt;Instance, &amp;(hnand-&gt;Init));
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">/* Initialize NAND common space timing Interface */</span>
<a name="l00191"></a>00191   (void)FSMC_NAND_CommonSpace_Timing_Init(hnand-&gt;Instance, ComSpace_Timing, hnand-&gt;Init.NandBank);
<a name="l00192"></a>00192 
<a name="l00193"></a>00193   <span class="comment">/* Initialize NAND attribute space timing Interface */</span>
<a name="l00194"></a>00194   (void)FSMC_NAND_AttributeSpace_Timing_Init(hnand-&gt;Instance, AttSpace_Timing, hnand-&gt;Init.NandBank);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="comment">/* Enable the NAND device */</span>
<a name="l00197"></a>00197   __FSMC_NAND_ENABLE(hnand-&gt;Instance, hnand-&gt;Init.NandBank);
<a name="l00198"></a>00198   
<a name="l00199"></a>00199   <span class="comment">/* Update the NAND controller state */</span>
<a name="l00200"></a>00200   hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202   <span class="keywordflow">return</span> HAL_OK;
<a name="l00203"></a>00203 }
<a name="l00204"></a>00204 <span class="comment"></span>
<a name="l00205"></a>00205 <span class="comment">/**</span>
<a name="l00206"></a>00206 <span class="comment">  * @brief  Perform NAND memory De-Initialization sequence</span>
<a name="l00207"></a>00207 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00208"></a>00208 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00209"></a>00209 <span class="comment">  * @retval HAL status</span>
<a name="l00210"></a>00210 <span class="comment">  */</span>
<a name="l00211"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#gaa112425b9194b40f519e9fb6118c70fa">00211</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#gaa112425b9194b40f519e9fb6118c70fa" title="Perform NAND memory De-Initialization sequence.">HAL_NAND_DeInit</a>(NAND_HandleTypeDef *hnand)
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00214"></a>00214 <span class="preprocessor"></span>  <span class="keywordflow">if</span>(hnand-&gt;MspDeInitCallback == NULL)
<a name="l00215"></a>00215   {
<a name="l00216"></a>00216     hnand-&gt;MspDeInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763" title="NAND MSP DeInit.">HAL_NAND_MspDeInit</a>;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="comment">/* DeInit the low level hardware */</span>
<a name="l00220"></a>00220   hnand-&gt;MspDeInitCallback(hnand);
<a name="l00221"></a>00221 <span class="preprocessor">#else</span>
<a name="l00222"></a>00222 <span class="preprocessor"></span>  <span class="comment">/* Initialize the low level hardware (MSP) */</span>
<a name="l00223"></a>00223   <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763" title="NAND MSP DeInit.">HAL_NAND_MspDeInit</a>(hnand);
<a name="l00224"></a>00224 <span class="preprocessor">#endif</span>
<a name="l00225"></a>00225 <span class="preprocessor"></span>
<a name="l00226"></a>00226   <span class="comment">/* Configure the NAND registers with their reset values */</span>
<a name="l00227"></a>00227   (void)FSMC_NAND_DeInit(hnand-&gt;Instance, hnand-&gt;Init.NandBank);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="comment">/* Reset the NAND controller state */</span>
<a name="l00230"></a>00230   hnand-&gt;State = HAL_NAND_STATE_RESET;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   <span class="comment">/* Release Lock */</span>
<a name="l00233"></a>00233   __HAL_UNLOCK(hnand);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="keywordflow">return</span> HAL_OK;
<a name="l00236"></a>00236 }
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment">/**</span>
<a name="l00239"></a>00239 <span class="comment">  * @brief  NAND MSP Init</span>
<a name="l00240"></a>00240 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00241"></a>00241 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00242"></a>00242 <span class="comment">  * @retval None</span>
<a name="l00243"></a>00243 <span class="comment">  */</span>
<a name="l00244"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404">00244</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404" title="NAND MSP Init.">HAL_NAND_MspInit</a>(NAND_HandleTypeDef *hnand)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l00247"></a>00247   UNUSED(hnand);
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="comment">/* NOTE : This function Should not be modified, when the callback is needed,</span>
<a name="l00250"></a>00250 <span class="comment">            the HAL_NAND_MspInit could be implemented in the user file</span>
<a name="l00251"></a>00251 <span class="comment">   */</span>
<a name="l00252"></a>00252 }
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">/**</span>
<a name="l00255"></a>00255 <span class="comment">  * @brief  NAND MSP DeInit</span>
<a name="l00256"></a>00256 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00257"></a>00257 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00258"></a>00258 <span class="comment">  * @retval None</span>
<a name="l00259"></a>00259 <span class="comment">  */</span>
<a name="l00260"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763">00260</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763" title="NAND MSP DeInit.">HAL_NAND_MspDeInit</a>(NAND_HandleTypeDef *hnand)
<a name="l00261"></a>00261 {
<a name="l00262"></a>00262   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l00263"></a>00263   UNUSED(hnand);
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">/* NOTE : This function Should not be modified, when the callback is needed,</span>
<a name="l00266"></a>00266 <span class="comment">            the HAL_NAND_MspDeInit could be implemented in the user file</span>
<a name="l00267"></a>00267 <span class="comment">   */</span>
<a name="l00268"></a>00268 }
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="comment"></span>
<a name="l00271"></a>00271 <span class="comment">/**</span>
<a name="l00272"></a>00272 <span class="comment">  * @brief  This function handles NAND device interrupt request.</span>
<a name="l00273"></a>00273 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00274"></a>00274 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00275"></a>00275 <span class="comment">  * @retval HAL status</span>
<a name="l00276"></a>00276 <span class="comment">*/</span>
<a name="l00277"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga93151bf1a6e4f193327afb2881a4efdd">00277</a> <span class="keywordtype">void</span> <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga93151bf1a6e4f193327afb2881a4efdd" title="This function handles NAND device interrupt request.">HAL_NAND_IRQHandler</a>(NAND_HandleTypeDef *hnand)
<a name="l00278"></a>00278 {
<a name="l00279"></a>00279   <span class="comment">/* Check NAND interrupt Rising edge flag */</span>
<a name="l00280"></a>00280   <span class="keywordflow">if</span> (__FSMC_NAND_GET_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_RISING_EDGE))
<a name="l00281"></a>00281   {
<a name="l00282"></a>00282     <span class="comment">/* NAND interrupt callback*/</span>
<a name="l00283"></a>00283 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span>    hnand-&gt;ItCallback(hnand);
<a name="l00285"></a>00285 <span class="preprocessor">#else</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span>    <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>(hnand);
<a name="l00287"></a>00287 <span class="preprocessor">#endif</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span>
<a name="l00289"></a>00289     <span class="comment">/* Clear NAND interrupt Rising edge pending bit */</span>
<a name="l00290"></a>00290     __FSMC_NAND_CLEAR_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_RISING_EDGE);
<a name="l00291"></a>00291   }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">/* Check NAND interrupt Level flag */</span>
<a name="l00294"></a>00294   <span class="keywordflow">if</span> (__FSMC_NAND_GET_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_LEVEL))
<a name="l00295"></a>00295   {
<a name="l00296"></a>00296     <span class="comment">/* NAND interrupt callback*/</span>
<a name="l00297"></a>00297 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>    hnand-&gt;ItCallback(hnand);
<a name="l00299"></a>00299 <span class="preprocessor">#else</span>
<a name="l00300"></a>00300 <span class="preprocessor"></span>    <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>(hnand);
<a name="l00301"></a>00301 <span class="preprocessor">#endif</span>
<a name="l00302"></a>00302 <span class="preprocessor"></span>
<a name="l00303"></a>00303     <span class="comment">/* Clear NAND interrupt Level pending bit */</span>
<a name="l00304"></a>00304     __FSMC_NAND_CLEAR_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_LEVEL);
<a name="l00305"></a>00305   }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   <span class="comment">/* Check NAND interrupt Falling edge flag */</span>
<a name="l00308"></a>00308   <span class="keywordflow">if</span> (__FSMC_NAND_GET_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_FALLING_EDGE))
<a name="l00309"></a>00309   {
<a name="l00310"></a>00310     <span class="comment">/* NAND interrupt callback*/</span>
<a name="l00311"></a>00311 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00312"></a>00312 <span class="preprocessor"></span>    hnand-&gt;ItCallback(hnand);
<a name="l00313"></a>00313 <span class="preprocessor">#else</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>    <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>(hnand);
<a name="l00315"></a>00315 <span class="preprocessor">#endif</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>
<a name="l00317"></a>00317     <span class="comment">/* Clear NAND interrupt Falling edge pending bit */</span>
<a name="l00318"></a>00318     __FSMC_NAND_CLEAR_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_FALLING_EDGE);
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   <span class="comment">/* Check NAND interrupt FIFO empty flag */</span>
<a name="l00322"></a>00322   <span class="keywordflow">if</span> (__FSMC_NAND_GET_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_FEMPT))
<a name="l00323"></a>00323   {
<a name="l00324"></a>00324     <span class="comment">/* NAND interrupt callback*/</span>
<a name="l00325"></a>00325 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span>    hnand-&gt;ItCallback(hnand);
<a name="l00327"></a>00327 <span class="preprocessor">#else</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>    <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>(hnand);
<a name="l00329"></a>00329 <span class="preprocessor">#endif</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>
<a name="l00331"></a>00331     <span class="comment">/* Clear NAND interrupt FIFO empty pending bit */</span>
<a name="l00332"></a>00332     __FSMC_NAND_CLEAR_FLAG(hnand-&gt;Instance, hnand-&gt;Init.NandBank, FSMC_FLAG_FEMPT);
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334 
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment">/**</span>
<a name="l00338"></a>00338 <span class="comment">  * @brief  NAND interrupt feature callback</span>
<a name="l00339"></a>00339 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00340"></a>00340 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00341"></a>00341 <span class="comment">  * @retval None</span>
<a name="l00342"></a>00342 <span class="comment">  */</span>
<a name="l00343"></a><a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4">00343</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>(NAND_HandleTypeDef *hnand)
<a name="l00344"></a>00344 {
<a name="l00345"></a>00345   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l00346"></a>00346   UNUSED(hnand);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348   <span class="comment">/* NOTE : This function Should not be modified, when the callback is needed,</span>
<a name="l00349"></a>00349 <span class="comment">            the HAL_NAND_ITCallback could be implemented in the user file</span>
<a name="l00350"></a>00350 <span class="comment">   */</span>
<a name="l00351"></a>00351 }
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment">/**</span>
<a name="l00354"></a>00354 <span class="comment">  * @}</span>
<a name="l00355"></a>00355 <span class="comment">  */</span>
<a name="l00356"></a>00356 <span class="comment"></span>
<a name="l00357"></a>00357 <span class="comment">/** @defgroup NAND_Exported_Functions_Group2 Input and Output functions</span>
<a name="l00358"></a>00358 <span class="comment">  * @brief    Input Output and memory control functions</span>
<a name="l00359"></a>00359 <span class="comment">  *</span>
<a name="l00360"></a>00360 <span class="comment">  @verbatim</span>
<a name="l00361"></a>00361 <span class="comment">  ==============================================================================</span>
<a name="l00362"></a>00362 <span class="comment">                    ##### NAND Input and Output functions #####</span>
<a name="l00363"></a>00363 <span class="comment">  ==============================================================================</span>
<a name="l00364"></a>00364 <span class="comment">  [..]</span>
<a name="l00365"></a>00365 <span class="comment">    This section provides functions allowing to use and control the NAND</span>
<a name="l00366"></a>00366 <span class="comment">    memory</span>
<a name="l00367"></a>00367 <span class="comment"></span>
<a name="l00368"></a>00368 <span class="comment">@endverbatim</span>
<a name="l00369"></a>00369 <span class="comment">  * @{</span>
<a name="l00370"></a>00370 <span class="comment">  */</span>
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">/**</span>
<a name="l00373"></a>00373 <span class="comment">  * @brief  Read the NAND memory electronic signature</span>
<a name="l00374"></a>00374 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00375"></a>00375 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00376"></a>00376 <span class="comment">  * @param  pNAND_ID NAND ID structure</span>
<a name="l00377"></a>00377 <span class="comment">  * @retval HAL status</span>
<a name="l00378"></a>00378 <span class="comment">  */</span>
<a name="l00379"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga9899354ee96eac1da4197075f6c2f774">00379</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga9899354ee96eac1da4197075f6c2f774" title="Read the NAND memory electronic signature.">HAL_NAND_Read_ID</a>(NAND_HandleTypeDef *hnand, NAND_IDTypeDef *pNAND_ID)
<a name="l00380"></a>00380 {
<a name="l00381"></a>00381   __IO uint32_t data = 0;
<a name="l00382"></a>00382   __IO uint32_t data1 = 0;
<a name="l00383"></a>00383   uint32_t deviceAddress;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <span class="comment">/* Check the NAND controller state */</span>
<a name="l00386"></a>00386   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l00387"></a>00387   {
<a name="l00388"></a>00388     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l00391"></a>00391   {
<a name="l00392"></a>00392     <span class="comment">/* Process Locked */</span>
<a name="l00393"></a>00393     __HAL_LOCK(hnand);
<a name="l00394"></a>00394 
<a name="l00395"></a>00395     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00396"></a>00396     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l00397"></a>00397 
<a name="l00398"></a>00398     <span class="comment">/* Identify the device address */</span>
<a name="l00399"></a>00399     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401       deviceAddress = NAND_DEVICE1;
<a name="l00402"></a>00402     }
<a name="l00403"></a>00403     <span class="keywordflow">else</span>
<a name="l00404"></a>00404     {
<a name="l00405"></a>00405       deviceAddress = NAND_DEVICE2;
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408     <span class="comment">/* Send Read ID command sequence */</span>
<a name="l00409"></a>00409     *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA))  = NAND_CMD_READID;
<a name="l00410"></a>00410     __DSB();
<a name="l00411"></a>00411     *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00;
<a name="l00412"></a>00412     __DSB();
<a name="l00413"></a>00413 
<a name="l00414"></a>00414     <span class="comment">/* Read the electronic signature from NAND flash */</span>
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (hnand-&gt;Init.MemoryDataWidth == FSMC_NAND_PCC_MEM_BUS_WIDTH_8)
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417       data = *(__IO uint32_t *)deviceAddress;
<a name="l00418"></a>00418 
<a name="l00419"></a>00419       <span class="comment">/* Return the data read */</span>
<a name="l00420"></a>00420       pNAND_ID-&gt;Maker_Id   = ADDR_1ST_CYCLE(data);
<a name="l00421"></a>00421       pNAND_ID-&gt;Device_Id  = ADDR_2ND_CYCLE(data);
<a name="l00422"></a>00422       pNAND_ID-&gt;Third_Id   = ADDR_3RD_CYCLE(data);
<a name="l00423"></a>00423       pNAND_ID-&gt;Fourth_Id  = ADDR_4TH_CYCLE(data);
<a name="l00424"></a>00424     }
<a name="l00425"></a>00425     <span class="keywordflow">else</span>
<a name="l00426"></a>00426     {
<a name="l00427"></a>00427       data = *(__IO uint32_t *)deviceAddress;
<a name="l00428"></a>00428       data1 = *((__IO uint32_t *)deviceAddress + 4);
<a name="l00429"></a>00429 
<a name="l00430"></a>00430       <span class="comment">/* Return the data read */</span>
<a name="l00431"></a>00431       pNAND_ID-&gt;Maker_Id   = ADDR_1ST_CYCLE(data);
<a name="l00432"></a>00432       pNAND_ID-&gt;Device_Id  = ADDR_3RD_CYCLE(data);
<a name="l00433"></a>00433       pNAND_ID-&gt;Third_Id   = ADDR_1ST_CYCLE(data1);
<a name="l00434"></a>00434       pNAND_ID-&gt;Fourth_Id  = ADDR_3RD_CYCLE(data1);
<a name="l00435"></a>00435     }
<a name="l00436"></a>00436 
<a name="l00437"></a>00437     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00438"></a>00438     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00439"></a>00439 
<a name="l00440"></a>00440     <span class="comment">/* Process unlocked */</span>
<a name="l00441"></a>00441     __HAL_UNLOCK(hnand);
<a name="l00442"></a>00442   }
<a name="l00443"></a>00443   <span class="keywordflow">else</span>
<a name="l00444"></a>00444   {
<a name="l00445"></a>00445     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00446"></a>00446   }
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="keywordflow">return</span> HAL_OK;
<a name="l00449"></a>00449 }
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">/**</span>
<a name="l00452"></a>00452 <span class="comment">  * @brief  NAND memory reset</span>
<a name="l00453"></a>00453 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00454"></a>00454 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00455"></a>00455 <span class="comment">  * @retval HAL status</span>
<a name="l00456"></a>00456 <span class="comment">  */</span>
<a name="l00457"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gab137d707e4b3ee23d32cc49fbe45ed5b">00457</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gab137d707e4b3ee23d32cc49fbe45ed5b" title="NAND memory reset.">HAL_NAND_Reset</a>(NAND_HandleTypeDef *hnand)
<a name="l00458"></a>00458 {
<a name="l00459"></a>00459   uint32_t deviceAddress;
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">/* Check the NAND controller state */</span>
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l00463"></a>00463   {
<a name="l00464"></a>00464     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l00465"></a>00465   }
<a name="l00466"></a>00466   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l00467"></a>00467   {
<a name="l00468"></a>00468     <span class="comment">/* Process Locked */</span>
<a name="l00469"></a>00469     __HAL_LOCK(hnand);
<a name="l00470"></a>00470 
<a name="l00471"></a>00471     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00472"></a>00472     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     <span class="comment">/* Identify the device address */</span>
<a name="l00475"></a>00475     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l00476"></a>00476     {
<a name="l00477"></a>00477       deviceAddress = NAND_DEVICE1;
<a name="l00478"></a>00478     }
<a name="l00479"></a>00479     <span class="keywordflow">else</span>
<a name="l00480"></a>00480     {
<a name="l00481"></a>00481       deviceAddress = NAND_DEVICE2;
<a name="l00482"></a>00482     }
<a name="l00483"></a>00483 
<a name="l00484"></a>00484     <span class="comment">/* Send NAND reset command */</span>
<a name="l00485"></a>00485     *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = 0xFF;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00488"></a>00488     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490     <span class="comment">/* Process unlocked */</span>
<a name="l00491"></a>00491     __HAL_UNLOCK(hnand);
<a name="l00492"></a>00492   }
<a name="l00493"></a>00493   <span class="keywordflow">else</span>
<a name="l00494"></a>00494   {
<a name="l00495"></a>00495     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00496"></a>00496   }
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   <span class="keywordflow">return</span> HAL_OK;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500 }
<a name="l00501"></a>00501 <span class="comment"></span>
<a name="l00502"></a>00502 <span class="comment">/**</span>
<a name="l00503"></a>00503 <span class="comment">  * @brief  Configure the device: Enter the physical parameters of the device</span>
<a name="l00504"></a>00504 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00505"></a>00505 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00506"></a>00506 <span class="comment">  * @param  pDeviceConfig  pointer to NAND_DeviceConfigTypeDef structure</span>
<a name="l00507"></a>00507 <span class="comment">  * @retval HAL status</span>
<a name="l00508"></a>00508 <span class="comment">  */</span>
<a name="l00509"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga6bd8a6bb2d4cd752611d4fbcdceb1aa4">00509</a> HAL_StatusTypeDef  <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga6bd8a6bb2d4cd752611d4fbcdceb1aa4" title="Configure the device: Enter the physical parameters of the device.">HAL_NAND_ConfigDevice</a>(NAND_HandleTypeDef *hnand, NAND_DeviceConfigTypeDef *pDeviceConfig)
<a name="l00510"></a>00510 {
<a name="l00511"></a>00511   hnand-&gt;Config.PageSize           = pDeviceConfig-&gt;PageSize;
<a name="l00512"></a>00512   hnand-&gt;Config.SpareAreaSize      = pDeviceConfig-&gt;SpareAreaSize;
<a name="l00513"></a>00513   hnand-&gt;Config.BlockSize          = pDeviceConfig-&gt;BlockSize;
<a name="l00514"></a>00514   hnand-&gt;Config.BlockNbr           = pDeviceConfig-&gt;BlockNbr;
<a name="l00515"></a>00515   hnand-&gt;Config.PlaneSize          = pDeviceConfig-&gt;PlaneSize;
<a name="l00516"></a>00516   hnand-&gt;Config.PlaneNbr           = pDeviceConfig-&gt;PlaneNbr;
<a name="l00517"></a>00517   hnand-&gt;Config.ExtraCommandEnable = pDeviceConfig-&gt;ExtraCommandEnable;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519   <span class="keywordflow">return</span> HAL_OK;
<a name="l00520"></a>00520 }
<a name="l00521"></a>00521 <span class="comment"></span>
<a name="l00522"></a>00522 <span class="comment">/**</span>
<a name="l00523"></a>00523 <span class="comment">  * @brief  Read Page(s) from NAND memory block (8-bits addressing)</span>
<a name="l00524"></a>00524 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00525"></a>00525 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00526"></a>00526 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l00527"></a>00527 <span class="comment">  * @param  pBuffer  pointer to destination read buffer</span>
<a name="l00528"></a>00528 <span class="comment">  * @param  NumPageToRead  number of pages to read from block</span>
<a name="l00529"></a>00529 <span class="comment">  * @retval HAL status</span>
<a name="l00530"></a>00530 <span class="comment">  */</span>
<a name="l00531"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga88f64880b8435ffde88f8e43e9b6eb43">00531</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga88f64880b8435ffde88f8e43e9b6eb43" title="Read Page(s) from NAND memory block (8-bits addressing)">HAL_NAND_Read_Page_8b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToRead)
<a name="l00532"></a>00532 {
<a name="l00533"></a>00533   uint32_t index;
<a name="l00534"></a>00534   uint32_t tickstart;
<a name="l00535"></a>00535   uint32_t deviceAddress, numPagesRead = 0U, nandAddress, nbpages = NumPageToRead;
<a name="l00536"></a>00536   uint8_t * buff = pBuffer;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">/* Check the NAND controller state */</span>
<a name="l00539"></a>00539   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l00540"></a>00540   {
<a name="l00541"></a>00541     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l00542"></a>00542   }
<a name="l00543"></a>00543   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l00544"></a>00544   {
<a name="l00545"></a>00545     <span class="comment">/* Process Locked */</span>
<a name="l00546"></a>00546     __HAL_LOCK(hnand);
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00549"></a>00549     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l00550"></a>00550 
<a name="l00551"></a>00551     <span class="comment">/* Identify the device address */</span>
<a name="l00552"></a>00552     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l00553"></a>00553     {
<a name="l00554"></a>00554       deviceAddress = NAND_DEVICE1;
<a name="l00555"></a>00555     }
<a name="l00556"></a>00556     <span class="keywordflow">else</span>
<a name="l00557"></a>00557     {
<a name="l00558"></a>00558       deviceAddress = NAND_DEVICE2;
<a name="l00559"></a>00559     }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="comment">/* NAND raw address calculation */</span>
<a name="l00562"></a>00562     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l00563"></a>00563 
<a name="l00564"></a>00564     <span class="comment">/* Page(s) read loop */</span>
<a name="l00565"></a>00565     <span class="keywordflow">while</span> ((nbpages != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l00566"></a>00566     {
<a name="l00567"></a>00567       <span class="comment">/* Send read page command sequence */</span>
<a name="l00568"></a>00568       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l00569"></a>00569       __DSB();
<a name="l00570"></a>00570 
<a name="l00571"></a>00571       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l00572"></a>00572       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l00573"></a>00573       {
<a name="l00574"></a>00574         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00575"></a>00575         {
<a name="l00576"></a>00576           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00577"></a>00577           __DSB();
<a name="l00578"></a>00578           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00579"></a>00579           __DSB();
<a name="l00580"></a>00580           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00581"></a>00581           __DSB();
<a name="l00582"></a>00582         }
<a name="l00583"></a>00583         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00584"></a>00584         {
<a name="l00585"></a>00585           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00586"></a>00586           __DSB();
<a name="l00587"></a>00587           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00588"></a>00588           __DSB();
<a name="l00589"></a>00589           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00590"></a>00590           __DSB();
<a name="l00591"></a>00591           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00592"></a>00592           __DSB();
<a name="l00593"></a>00593         }
<a name="l00594"></a>00594       }
<a name="l00595"></a>00595       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l00596"></a>00596       {
<a name="l00597"></a>00597         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00598"></a>00598         {
<a name="l00599"></a>00599           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00600"></a>00600           __DSB();
<a name="l00601"></a>00601           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00602"></a>00602           __DSB();
<a name="l00603"></a>00603           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00604"></a>00604           __DSB();
<a name="l00605"></a>00605           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00606"></a>00606           __DSB();
<a name="l00607"></a>00607         }
<a name="l00608"></a>00608         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00609"></a>00609         {
<a name="l00610"></a>00610           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00611"></a>00611           __DSB();
<a name="l00612"></a>00612           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00613"></a>00613           __DSB();
<a name="l00614"></a>00614           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00615"></a>00615           __DSB();
<a name="l00616"></a>00616           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00617"></a>00617           __DSB();
<a name="l00618"></a>00618           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00619"></a>00619           __DSB();
<a name="l00620"></a>00620         }
<a name="l00621"></a>00621       }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA))  = NAND_CMD_AREA_TRUE1;
<a name="l00624"></a>00624       __DSB();
<a name="l00625"></a>00625 
<a name="l00626"></a>00626 
<a name="l00627"></a>00627       <span class="keywordflow">if</span> (hnand-&gt;Config.ExtraCommandEnable == ENABLE)
<a name="l00628"></a>00628       {
<a name="l00629"></a>00629         <span class="comment">/* Get tick */</span>
<a name="l00630"></a>00630         tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l00631"></a>00631 
<a name="l00632"></a>00632         <span class="comment">/* Read status until NAND is ready */</span>
<a name="l00633"></a>00633         <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l00634"></a>00634         {
<a name="l00635"></a>00635           <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l00636"></a>00636           {
<a name="l00637"></a>00637             <span class="comment">/* Update the NAND controller state */</span>
<a name="l00638"></a>00638             hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l00639"></a>00639 
<a name="l00640"></a>00640             <span class="comment">/* Process unlocked */</span>
<a name="l00641"></a>00641             __HAL_UNLOCK(hnand);
<a name="l00642"></a>00642 
<a name="l00643"></a>00643             <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l00644"></a>00644           }
<a name="l00645"></a>00645         }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647         <span class="comment">/* Go back to read mode */</span>
<a name="l00648"></a>00648         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = ((uint8_t)0x00U);
<a name="l00649"></a>00649         __DSB();
<a name="l00650"></a>00650       }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652       <span class="comment">/* Get Data into Buffer */</span>
<a name="l00653"></a>00653       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.PageSize; index++)
<a name="l00654"></a>00654       {
<a name="l00655"></a>00655         *buff = *(uint8_t *)deviceAddress;
<a name="l00656"></a>00656         buff++;
<a name="l00657"></a>00657       }
<a name="l00658"></a>00658 
<a name="l00659"></a>00659       <span class="comment">/* Increment read pages number */</span>
<a name="l00660"></a>00660       numPagesRead++;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662       <span class="comment">/* Decrement pages to read */</span>
<a name="l00663"></a>00663       nbpages--;
<a name="l00664"></a>00664 
<a name="l00665"></a>00665       <span class="comment">/* Increment the NAND address */</span>
<a name="l00666"></a>00666       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00670"></a>00670     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00671"></a>00671 
<a name="l00672"></a>00672     <span class="comment">/* Process unlocked */</span>
<a name="l00673"></a>00673     __HAL_UNLOCK(hnand);
<a name="l00674"></a>00674   }
<a name="l00675"></a>00675   <span class="keywordflow">else</span>
<a name="l00676"></a>00676   {
<a name="l00677"></a>00677     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00678"></a>00678   }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="keywordflow">return</span> HAL_OK;
<a name="l00681"></a>00681 }
<a name="l00682"></a>00682 <span class="comment"></span>
<a name="l00683"></a>00683 <span class="comment">/**</span>
<a name="l00684"></a>00684 <span class="comment">  * @brief  Read Page(s) from NAND memory block (16-bits addressing)</span>
<a name="l00685"></a>00685 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00686"></a>00686 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00687"></a>00687 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l00688"></a>00688 <span class="comment">  * @param  pBuffer  pointer to destination read buffer. pBuffer should be 16bits aligned</span>
<a name="l00689"></a>00689 <span class="comment">  * @param  NumPageToRead  number of pages to read from block</span>
<a name="l00690"></a>00690 <span class="comment">  * @retval HAL status</span>
<a name="l00691"></a>00691 <span class="comment">  */</span>
<a name="l00692"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga12fd96e1602e7ec56237d90f5bd16c84">00692</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga12fd96e1602e7ec56237d90f5bd16c84" title="Read Page(s) from NAND memory block (16-bits addressing)">HAL_NAND_Read_Page_16b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumPageToRead)
<a name="l00693"></a>00693 {
<a name="l00694"></a>00694   uint32_t index;
<a name="l00695"></a>00695   uint32_t tickstart;
<a name="l00696"></a>00696   uint32_t deviceAddress, numPagesRead = 0, nandAddress, nbpages = NumPageToRead;
<a name="l00697"></a>00697   uint16_t * buff = pBuffer;
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   <span class="comment">/* Check the NAND controller state */</span>
<a name="l00700"></a>00700   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l00701"></a>00701   {
<a name="l00702"></a>00702     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l00703"></a>00703   }
<a name="l00704"></a>00704   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l00705"></a>00705   {
<a name="l00706"></a>00706     <span class="comment">/* Process Locked */</span>
<a name="l00707"></a>00707     __HAL_LOCK(hnand);
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00710"></a>00710     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712     <span class="comment">/* Identify the device address */</span>
<a name="l00713"></a>00713     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l00714"></a>00714     {
<a name="l00715"></a>00715       deviceAddress = NAND_DEVICE1;
<a name="l00716"></a>00716     }
<a name="l00717"></a>00717     <span class="keywordflow">else</span>
<a name="l00718"></a>00718     {
<a name="l00719"></a>00719       deviceAddress = NAND_DEVICE2;
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722     <span class="comment">/* NAND raw address calculation */</span>
<a name="l00723"></a>00723     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l00724"></a>00724 
<a name="l00725"></a>00725     <span class="comment">/* Page(s) read loop */</span>
<a name="l00726"></a>00726     <span class="keywordflow">while</span> ((nbpages != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l00727"></a>00727     {
<a name="l00728"></a>00728       <span class="comment">/* Send read page command sequence */</span>
<a name="l00729"></a>00729       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l00730"></a>00730       __DSB();
<a name="l00731"></a>00731 
<a name="l00732"></a>00732       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l00733"></a>00733       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l00734"></a>00734       {
<a name="l00735"></a>00735         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00736"></a>00736         {
<a name="l00737"></a>00737           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00738"></a>00738           __DSB();
<a name="l00739"></a>00739           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00740"></a>00740           __DSB();
<a name="l00741"></a>00741           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00742"></a>00742           __DSB();
<a name="l00743"></a>00743         }
<a name="l00744"></a>00744         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00745"></a>00745         {
<a name="l00746"></a>00746           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00747"></a>00747           __DSB();
<a name="l00748"></a>00748           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00749"></a>00749           __DSB();
<a name="l00750"></a>00750           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00751"></a>00751           __DSB();
<a name="l00752"></a>00752           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00753"></a>00753           __DSB();
<a name="l00754"></a>00754         }
<a name="l00755"></a>00755       }
<a name="l00756"></a>00756       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l00757"></a>00757       {
<a name="l00758"></a>00758         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00759"></a>00759         {
<a name="l00760"></a>00760           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00761"></a>00761           __DSB();
<a name="l00762"></a>00762           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00763"></a>00763           __DSB();
<a name="l00764"></a>00764           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00765"></a>00765           __DSB();
<a name="l00766"></a>00766           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00767"></a>00767           __DSB();
<a name="l00768"></a>00768         }
<a name="l00769"></a>00769         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00770"></a>00770         {
<a name="l00771"></a>00771           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00772"></a>00772           __DSB();
<a name="l00773"></a>00773           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00774"></a>00774           __DSB();
<a name="l00775"></a>00775           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00776"></a>00776           __DSB();
<a name="l00777"></a>00777           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00778"></a>00778           __DSB();
<a name="l00779"></a>00779           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00780"></a>00780           __DSB();
<a name="l00781"></a>00781         }
<a name="l00782"></a>00782       }
<a name="l00783"></a>00783 
<a name="l00784"></a>00784       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA))  = NAND_CMD_AREA_TRUE1;
<a name="l00785"></a>00785       __DSB();
<a name="l00786"></a>00786 
<a name="l00787"></a>00787       <span class="keywordflow">if</span> (hnand-&gt;Config.ExtraCommandEnable == ENABLE)
<a name="l00788"></a>00788       {
<a name="l00789"></a>00789         <span class="comment">/* Get tick */</span>
<a name="l00790"></a>00790         tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l00791"></a>00791 
<a name="l00792"></a>00792         <span class="comment">/* Read status until NAND is ready */</span>
<a name="l00793"></a>00793         <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l00794"></a>00794         {
<a name="l00795"></a>00795           <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l00796"></a>00796           {
<a name="l00797"></a>00797             <span class="comment">/* Update the NAND controller state */</span>
<a name="l00798"></a>00798             hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l00799"></a>00799 
<a name="l00800"></a>00800             <span class="comment">/* Process unlocked */</span>
<a name="l00801"></a>00801             __HAL_UNLOCK(hnand);
<a name="l00802"></a>00802 
<a name="l00803"></a>00803             <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l00804"></a>00804           }
<a name="l00805"></a>00805         }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807         <span class="comment">/* Go back to read mode */</span>
<a name="l00808"></a>00808         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = ((uint8_t)0x00U);
<a name="l00809"></a>00809         __DSB();
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812       <span class="comment">/* Get Data into Buffer */</span>
<a name="l00813"></a>00813       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.PageSize; index++)
<a name="l00814"></a>00814       {
<a name="l00815"></a>00815         *buff = *(uint16_t *)deviceAddress;
<a name="l00816"></a>00816         buff++;
<a name="l00817"></a>00817       }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819       <span class="comment">/* Increment read pages number */</span>
<a name="l00820"></a>00820       numPagesRead++;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822       <span class="comment">/* Decrement pages to read */</span>
<a name="l00823"></a>00823       nbpages--;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825       <span class="comment">/* Increment the NAND address */</span>
<a name="l00826"></a>00826       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l00827"></a>00827     }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00830"></a>00830     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00831"></a>00831 
<a name="l00832"></a>00832     <span class="comment">/* Process unlocked */</span>
<a name="l00833"></a>00833     __HAL_UNLOCK(hnand);
<a name="l00834"></a>00834   }
<a name="l00835"></a>00835   <span class="keywordflow">else</span>
<a name="l00836"></a>00836   {
<a name="l00837"></a>00837     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00838"></a>00838   }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="keywordflow">return</span> HAL_OK;
<a name="l00841"></a>00841 }
<a name="l00842"></a>00842 <span class="comment"></span>
<a name="l00843"></a>00843 <span class="comment">/**</span>
<a name="l00844"></a>00844 <span class="comment">  * @brief  Write Page(s) to NAND memory block (8-bits addressing)</span>
<a name="l00845"></a>00845 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l00846"></a>00846 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l00847"></a>00847 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l00848"></a>00848 <span class="comment">  * @param  pBuffer  pointer to source buffer to write</span>
<a name="l00849"></a>00849 <span class="comment">  * @param  NumPageToWrite   number of pages to write to block</span>
<a name="l00850"></a>00850 <span class="comment">  * @retval HAL status</span>
<a name="l00851"></a>00851 <span class="comment">  */</span>
<a name="l00852"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gaba01cc60ac7b85e5dcd64dc74bf5115e">00852</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gaba01cc60ac7b85e5dcd64dc74bf5115e" title="Write Page(s) to NAND memory block (8-bits addressing)">HAL_NAND_Write_Page_8b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumPageToWrite)
<a name="l00853"></a>00853 {
<a name="l00854"></a>00854   uint32_t index;
<a name="l00855"></a>00855   uint32_t tickstart;
<a name="l00856"></a>00856   uint32_t deviceAddress, numPagesWritten = 0, nandAddress, nbpages = NumPageToWrite;
<a name="l00857"></a>00857   uint8_t * buff = pBuffer;
<a name="l00858"></a>00858 
<a name="l00859"></a>00859   <span class="comment">/* Check the NAND controller state */</span>
<a name="l00860"></a>00860   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l00861"></a>00861   {
<a name="l00862"></a>00862     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l00863"></a>00863   }
<a name="l00864"></a>00864   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l00865"></a>00865   {
<a name="l00866"></a>00866     <span class="comment">/* Process Locked */</span>
<a name="l00867"></a>00867     __HAL_LOCK(hnand);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00870"></a>00870     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l00871"></a>00871 
<a name="l00872"></a>00872     <span class="comment">/* Identify the device address */</span>
<a name="l00873"></a>00873     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l00874"></a>00874     {
<a name="l00875"></a>00875       deviceAddress = NAND_DEVICE1;
<a name="l00876"></a>00876     }
<a name="l00877"></a>00877     <span class="keywordflow">else</span>
<a name="l00878"></a>00878     {
<a name="l00879"></a>00879       deviceAddress = NAND_DEVICE2;
<a name="l00880"></a>00880     }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882     <span class="comment">/* NAND raw address calculation */</span>
<a name="l00883"></a>00883     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l00884"></a>00884 
<a name="l00885"></a>00885     <span class="comment">/* Page(s) write loop */</span>
<a name="l00886"></a>00886     <span class="keywordflow">while</span> ((nbpages != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888       <span class="comment">/* Send write page command sequence */</span>
<a name="l00889"></a>00889       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l00890"></a>00890       __DSB();
<a name="l00891"></a>00891       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l00892"></a>00892       __DSB();
<a name="l00893"></a>00893 
<a name="l00894"></a>00894       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l00895"></a>00895       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l00896"></a>00896       {
<a name="l00897"></a>00897         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00898"></a>00898         {
<a name="l00899"></a>00899           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00900"></a>00900           __DSB();
<a name="l00901"></a>00901           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00902"></a>00902           __DSB();
<a name="l00903"></a>00903           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00904"></a>00904           __DSB();
<a name="l00905"></a>00905         }
<a name="l00906"></a>00906         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00907"></a>00907         {
<a name="l00908"></a>00908           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00909"></a>00909           __DSB();
<a name="l00910"></a>00910           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00911"></a>00911           __DSB();
<a name="l00912"></a>00912           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00913"></a>00913           __DSB();
<a name="l00914"></a>00914           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00915"></a>00915           __DSB();
<a name="l00916"></a>00916         }
<a name="l00917"></a>00917       }
<a name="l00918"></a>00918       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l00919"></a>00919       {
<a name="l00920"></a>00920         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l00921"></a>00921         {
<a name="l00922"></a>00922           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00923"></a>00923           __DSB();
<a name="l00924"></a>00924           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00925"></a>00925           __DSB();
<a name="l00926"></a>00926           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00927"></a>00927           __DSB();
<a name="l00928"></a>00928           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00929"></a>00929           __DSB();
<a name="l00930"></a>00930         }
<a name="l00931"></a>00931         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l00932"></a>00932         {
<a name="l00933"></a>00933           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00934"></a>00934           __DSB();
<a name="l00935"></a>00935           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l00936"></a>00936           __DSB();
<a name="l00937"></a>00937           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l00938"></a>00938           __DSB();
<a name="l00939"></a>00939           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l00940"></a>00940           __DSB();
<a name="l00941"></a>00941           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l00942"></a>00942           __DSB();
<a name="l00943"></a>00943         }
<a name="l00944"></a>00944       }
<a name="l00945"></a>00945 
<a name="l00946"></a>00946       <span class="comment">/* Write data to memory */</span>
<a name="l00947"></a>00947       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.PageSize; index++)
<a name="l00948"></a>00948       {
<a name="l00949"></a>00949         *(__IO uint8_t *)deviceAddress = *buff;
<a name="l00950"></a>00950         buff++;
<a name="l00951"></a>00951         __DSB();
<a name="l00952"></a>00952       }
<a name="l00953"></a>00953 
<a name="l00954"></a>00954       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE_TRUE1;
<a name="l00955"></a>00955       __DSB();
<a name="l00956"></a>00956 
<a name="l00957"></a>00957       <span class="comment">/* Get tick */</span>
<a name="l00958"></a>00958       tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l00959"></a>00959 
<a name="l00960"></a>00960       <span class="comment">/* Read status until NAND is ready */</span>
<a name="l00961"></a>00961       <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l00962"></a>00962       {
<a name="l00963"></a>00963         <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l00964"></a>00964         {
<a name="l00965"></a>00965           <span class="comment">/* Update the NAND controller state */</span>
<a name="l00966"></a>00966           hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l00967"></a>00967 
<a name="l00968"></a>00968           <span class="comment">/* Process unlocked */</span>
<a name="l00969"></a>00969           __HAL_UNLOCK(hnand);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971           <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l00972"></a>00972         }
<a name="l00973"></a>00973       }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975       <span class="comment">/* Increment written pages number */</span>
<a name="l00976"></a>00976       numPagesWritten++;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978       <span class="comment">/* Decrement pages to write */</span>
<a name="l00979"></a>00979       nbpages--;
<a name="l00980"></a>00980 
<a name="l00981"></a>00981       <span class="comment">/* Increment the NAND address */</span>
<a name="l00982"></a>00982       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984 
<a name="l00985"></a>00985     <span class="comment">/* Update the NAND controller state */</span>
<a name="l00986"></a>00986     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l00987"></a>00987 
<a name="l00988"></a>00988     <span class="comment">/* Process unlocked */</span>
<a name="l00989"></a>00989     __HAL_UNLOCK(hnand);
<a name="l00990"></a>00990   }
<a name="l00991"></a>00991   <span class="keywordflow">else</span>
<a name="l00992"></a>00992   {
<a name="l00993"></a>00993     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00994"></a>00994   }
<a name="l00995"></a>00995 
<a name="l00996"></a>00996   <span class="keywordflow">return</span> HAL_OK;
<a name="l00997"></a>00997 }
<a name="l00998"></a>00998 <span class="comment"></span>
<a name="l00999"></a>00999 <span class="comment">/**</span>
<a name="l01000"></a>01000 <span class="comment">  * @brief  Write Page(s) to NAND memory block (16-bits addressing)</span>
<a name="l01001"></a>01001 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01002"></a>01002 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01003"></a>01003 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01004"></a>01004 <span class="comment">  * @param  pBuffer  pointer to source buffer to write. pBuffer should be 16bits aligned</span>
<a name="l01005"></a>01005 <span class="comment">  * @param  NumPageToWrite   number of pages to write to block</span>
<a name="l01006"></a>01006 <span class="comment">  * @retval HAL status</span>
<a name="l01007"></a>01007 <span class="comment">  */</span>
<a name="l01008"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga39a997ea7f5390d992ac6b2621afc32d">01008</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga39a997ea7f5390d992ac6b2621afc32d" title="Write Page(s) to NAND memory block (16-bits addressing)">HAL_NAND_Write_Page_16b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumPageToWrite)
<a name="l01009"></a>01009 {
<a name="l01010"></a>01010   uint32_t index;
<a name="l01011"></a>01011   uint32_t tickstart;
<a name="l01012"></a>01012   uint32_t deviceAddress, numPagesWritten = 0, nandAddress, nbpages = NumPageToWrite;
<a name="l01013"></a>01013   uint16_t * buff = pBuffer;
<a name="l01014"></a>01014 
<a name="l01015"></a>01015   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01016"></a>01016   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01017"></a>01017   {
<a name="l01018"></a>01018     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01019"></a>01019   }
<a name="l01020"></a>01020   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01021"></a>01021   {
<a name="l01022"></a>01022     <span class="comment">/* Process Locked */</span>
<a name="l01023"></a>01023     __HAL_LOCK(hnand);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01026"></a>01026     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01027"></a>01027 
<a name="l01028"></a>01028     <span class="comment">/* Identify the device address */</span>
<a name="l01029"></a>01029     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01030"></a>01030     {
<a name="l01031"></a>01031       deviceAddress = NAND_DEVICE1;
<a name="l01032"></a>01032     }
<a name="l01033"></a>01033     <span class="keywordflow">else</span>
<a name="l01034"></a>01034     {
<a name="l01035"></a>01035       deviceAddress = NAND_DEVICE2;
<a name="l01036"></a>01036     }
<a name="l01037"></a>01037 
<a name="l01038"></a>01038     <span class="comment">/* NAND raw address calculation */</span>
<a name="l01039"></a>01039     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     <span class="comment">/* Page(s) write loop */</span>
<a name="l01042"></a>01042     <span class="keywordflow">while</span> ((nbpages != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l01043"></a>01043     {
<a name="l01044"></a>01044       <span class="comment">/* Send write page command sequence */</span>
<a name="l01045"></a>01045       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l01046"></a>01046       __DSB();
<a name="l01047"></a>01047       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l01048"></a>01048       __DSB();
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l01051"></a>01051       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l01052"></a>01052       {
<a name="l01053"></a>01053         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01054"></a>01054         {
<a name="l01055"></a>01055           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01056"></a>01056           __DSB();
<a name="l01057"></a>01057           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01058"></a>01058           __DSB();
<a name="l01059"></a>01059           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01060"></a>01060           __DSB();
<a name="l01061"></a>01061         }
<a name="l01062"></a>01062         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01063"></a>01063         {
<a name="l01064"></a>01064           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01065"></a>01065           __DSB();
<a name="l01066"></a>01066           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01067"></a>01067           __DSB();
<a name="l01068"></a>01068           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01069"></a>01069           __DSB();
<a name="l01070"></a>01070           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01071"></a>01071           __DSB();
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073       }
<a name="l01074"></a>01074       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l01075"></a>01075       {
<a name="l01076"></a>01076         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01077"></a>01077         {
<a name="l01078"></a>01078           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01079"></a>01079           __DSB();
<a name="l01080"></a>01080           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01081"></a>01081           __DSB();
<a name="l01082"></a>01082           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01083"></a>01083           __DSB();
<a name="l01084"></a>01084           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01085"></a>01085           __DSB();
<a name="l01086"></a>01086         }
<a name="l01087"></a>01087         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01088"></a>01088         {
<a name="l01089"></a>01089           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01090"></a>01090           __DSB();
<a name="l01091"></a>01091           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01092"></a>01092           __DSB();
<a name="l01093"></a>01093           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01094"></a>01094           __DSB();
<a name="l01095"></a>01095           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01096"></a>01096           __DSB();
<a name="l01097"></a>01097           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01098"></a>01098           __DSB();
<a name="l01099"></a>01099         }
<a name="l01100"></a>01100       }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102       <span class="comment">/* Write data to memory */</span>
<a name="l01103"></a>01103       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.PageSize; index++)
<a name="l01104"></a>01104       {
<a name="l01105"></a>01105         *(__IO uint16_t *)deviceAddress = *buff;
<a name="l01106"></a>01106         buff++;
<a name="l01107"></a>01107         __DSB();
<a name="l01108"></a>01108       }
<a name="l01109"></a>01109 
<a name="l01110"></a>01110       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE_TRUE1;
<a name="l01111"></a>01111       __DSB();
<a name="l01112"></a>01112 
<a name="l01113"></a>01113       <span class="comment">/* Get tick */</span>
<a name="l01114"></a>01114       tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l01115"></a>01115 
<a name="l01116"></a>01116       <span class="comment">/* Read status until NAND is ready */</span>
<a name="l01117"></a>01117       <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l01118"></a>01118       {
<a name="l01119"></a>01119         <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l01120"></a>01120         {
<a name="l01121"></a>01121           <span class="comment">/* Update the NAND controller state */</span>
<a name="l01122"></a>01122           hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l01123"></a>01123 
<a name="l01124"></a>01124           <span class="comment">/* Process unlocked */</span>
<a name="l01125"></a>01125           __HAL_UNLOCK(hnand);
<a name="l01126"></a>01126 
<a name="l01127"></a>01127           <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l01128"></a>01128         }
<a name="l01129"></a>01129       }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131       <span class="comment">/* Increment written pages number */</span>
<a name="l01132"></a>01132       numPagesWritten++;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134       <span class="comment">/* Decrement pages to write */</span>
<a name="l01135"></a>01135       nbpages--;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137       <span class="comment">/* Increment the NAND address */</span>
<a name="l01138"></a>01138       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l01139"></a>01139     }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01142"></a>01142     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01143"></a>01143 
<a name="l01144"></a>01144     <span class="comment">/* Process unlocked */</span>
<a name="l01145"></a>01145     __HAL_UNLOCK(hnand);
<a name="l01146"></a>01146   }
<a name="l01147"></a>01147   <span class="keywordflow">else</span>
<a name="l01148"></a>01148   {
<a name="l01149"></a>01149     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01150"></a>01150   }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   <span class="keywordflow">return</span> HAL_OK;
<a name="l01153"></a>01153 }
<a name="l01154"></a>01154 <span class="comment"></span>
<a name="l01155"></a>01155 <span class="comment">/**</span>
<a name="l01156"></a>01156 <span class="comment">  * @brief  Read Spare area(s) from NAND memory (8-bits addressing)</span>
<a name="l01157"></a>01157 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01158"></a>01158 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01159"></a>01159 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01160"></a>01160 <span class="comment">  * @param  pBuffer pointer to source buffer to write</span>
<a name="l01161"></a>01161 <span class="comment">  * @param  NumSpareAreaToRead Number of spare area to read</span>
<a name="l01162"></a>01162 <span class="comment">  * @retval HAL status</span>
<a name="l01163"></a>01163 <span class="comment">*/</span>
<a name="l01164"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga7ccdb17336cafb6188a33a9ab1b03719">01164</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga7ccdb17336cafb6188a33a9ab1b03719" title="Read Spare area(s) from NAND memory (8-bits addressing)">HAL_NAND_Read_SpareArea_8b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaToRead)
<a name="l01165"></a>01165 {
<a name="l01166"></a>01166   uint32_t index;
<a name="l01167"></a>01167   uint32_t tickstart;
<a name="l01168"></a>01168   uint32_t deviceAddress, numSpareAreaRead = 0, nandAddress, columnAddress, nbspare = NumSpareAreaToRead;
<a name="l01169"></a>01169   uint8_t * buff = pBuffer;
<a name="l01170"></a>01170 
<a name="l01171"></a>01171   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01172"></a>01172   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01173"></a>01173   {
<a name="l01174"></a>01174     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01175"></a>01175   }
<a name="l01176"></a>01176   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01177"></a>01177   {
<a name="l01178"></a>01178     <span class="comment">/* Process Locked */</span>
<a name="l01179"></a>01179     __HAL_LOCK(hnand);
<a name="l01180"></a>01180 
<a name="l01181"></a>01181     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01182"></a>01182     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184     <span class="comment">/* Identify the device address */</span>
<a name="l01185"></a>01185     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01186"></a>01186     {
<a name="l01187"></a>01187       deviceAddress = NAND_DEVICE1;
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189     <span class="keywordflow">else</span>
<a name="l01190"></a>01190     {
<a name="l01191"></a>01191       deviceAddress = NAND_DEVICE2;
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194     <span class="comment">/* NAND raw address calculation */</span>
<a name="l01195"></a>01195     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l01196"></a>01196 
<a name="l01197"></a>01197     <span class="comment">/* Column in page address */</span>
<a name="l01198"></a>01198     columnAddress = COLUMN_ADDRESS(hnand);
<a name="l01199"></a>01199 
<a name="l01200"></a>01200     <span class="comment">/* Spare area(s) read loop */</span>
<a name="l01201"></a>01201     <span class="keywordflow">while</span> ((nbspare != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l01202"></a>01202     {
<a name="l01203"></a>01203       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l01204"></a>01204       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l01205"></a>01205       {
<a name="l01206"></a>01206         <span class="comment">/* Send read spare area command sequence */</span>
<a name="l01207"></a>01207         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
<a name="l01208"></a>01208         __DSB();
<a name="l01209"></a>01209 
<a name="l01210"></a>01210         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01211"></a>01211         {
<a name="l01212"></a>01212           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01213"></a>01213           __DSB();
<a name="l01214"></a>01214           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01215"></a>01215           __DSB();
<a name="l01216"></a>01216           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01217"></a>01217           __DSB();
<a name="l01218"></a>01218         }
<a name="l01219"></a>01219         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01220"></a>01220         {
<a name="l01221"></a>01221           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01222"></a>01222           __DSB();
<a name="l01223"></a>01223           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01224"></a>01224           __DSB();
<a name="l01225"></a>01225           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01226"></a>01226           __DSB();
<a name="l01227"></a>01227           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01228"></a>01228           __DSB();
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230       }
<a name="l01231"></a>01231       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l01232"></a>01232       {
<a name="l01233"></a>01233         <span class="comment">/* Send read spare area command sequence */</span>
<a name="l01234"></a>01234         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l01235"></a>01235         __DSB();
<a name="l01236"></a>01236 
<a name="l01237"></a>01237         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01238"></a>01238         {
<a name="l01239"></a>01239           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01240"></a>01240           __DSB();
<a name="l01241"></a>01241           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01242"></a>01242           __DSB();
<a name="l01243"></a>01243           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01244"></a>01244           __DSB();
<a name="l01245"></a>01245           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01246"></a>01246           __DSB();
<a name="l01247"></a>01247         }
<a name="l01248"></a>01248         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01249"></a>01249         {
<a name="l01250"></a>01250           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01251"></a>01251           __DSB();
<a name="l01252"></a>01252           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01253"></a>01253           __DSB();
<a name="l01254"></a>01254           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01255"></a>01255           __DSB();
<a name="l01256"></a>01256           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01257"></a>01257           __DSB();
<a name="l01258"></a>01258           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01259"></a>01259           __DSB();
<a name="l01260"></a>01260         }
<a name="l01261"></a>01261       }
<a name="l01262"></a>01262 
<a name="l01263"></a>01263       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_TRUE1;
<a name="l01264"></a>01264       __DSB();
<a name="l01265"></a>01265 
<a name="l01266"></a>01266       <span class="keywordflow">if</span> (hnand-&gt;Config.ExtraCommandEnable == ENABLE)
<a name="l01267"></a>01267       {
<a name="l01268"></a>01268         <span class="comment">/* Get tick */</span>
<a name="l01269"></a>01269         tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l01270"></a>01270 
<a name="l01271"></a>01271         <span class="comment">/* Read status until NAND is ready */</span>
<a name="l01272"></a>01272         <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l01273"></a>01273         {
<a name="l01274"></a>01274           <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l01275"></a>01275           {
<a name="l01276"></a>01276             <span class="comment">/* Update the NAND controller state */</span>
<a name="l01277"></a>01277             hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l01278"></a>01278 
<a name="l01279"></a>01279             <span class="comment">/* Process unlocked */</span>
<a name="l01280"></a>01280             __HAL_UNLOCK(hnand);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282             <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l01283"></a>01283           }
<a name="l01284"></a>01284         }
<a name="l01285"></a>01285 
<a name="l01286"></a>01286         <span class="comment">/* Go back to read mode */</span>
<a name="l01287"></a>01287         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = ((uint8_t)0x00U);
<a name="l01288"></a>01288         __DSB();
<a name="l01289"></a>01289       }
<a name="l01290"></a>01290 
<a name="l01291"></a>01291       <span class="comment">/* Get Data into Buffer */</span>
<a name="l01292"></a>01292       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.SpareAreaSize; index++)
<a name="l01293"></a>01293       {
<a name="l01294"></a>01294         *buff = *(uint8_t *)deviceAddress;
<a name="l01295"></a>01295         buff++;
<a name="l01296"></a>01296       }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298       <span class="comment">/* Increment read spare areas number */</span>
<a name="l01299"></a>01299       numSpareAreaRead++;
<a name="l01300"></a>01300 
<a name="l01301"></a>01301       <span class="comment">/* Decrement spare areas to read */</span>
<a name="l01302"></a>01302       nbspare--;
<a name="l01303"></a>01303 
<a name="l01304"></a>01304       <span class="comment">/* Increment the NAND address */</span>
<a name="l01305"></a>01305       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01309"></a>01309     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01310"></a>01310 
<a name="l01311"></a>01311     <span class="comment">/* Process unlocked */</span>
<a name="l01312"></a>01312     __HAL_UNLOCK(hnand);
<a name="l01313"></a>01313   }
<a name="l01314"></a>01314   <span class="keywordflow">else</span>
<a name="l01315"></a>01315   {
<a name="l01316"></a>01316     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01317"></a>01317   }
<a name="l01318"></a>01318 
<a name="l01319"></a>01319   <span class="keywordflow">return</span> HAL_OK;
<a name="l01320"></a>01320 }
<a name="l01321"></a>01321 <span class="comment"></span>
<a name="l01322"></a>01322 <span class="comment">/**</span>
<a name="l01323"></a>01323 <span class="comment">  * @brief  Read Spare area(s) from NAND memory (16-bits addressing)</span>
<a name="l01324"></a>01324 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01325"></a>01325 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01326"></a>01326 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01327"></a>01327 <span class="comment">  * @param  pBuffer pointer to source buffer to write. pBuffer should be 16bits aligned.</span>
<a name="l01328"></a>01328 <span class="comment">  * @param  NumSpareAreaToRead Number of spare area to read</span>
<a name="l01329"></a>01329 <span class="comment">  * @retval HAL status</span>
<a name="l01330"></a>01330 <span class="comment">*/</span>
<a name="l01331"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga270713c9a3630fb532981ef1014fa392">01331</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#ga270713c9a3630fb532981ef1014fa392" title="Read Spare area(s) from NAND memory (16-bits addressing)">HAL_NAND_Read_SpareArea_16b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumSpareAreaToRead)
<a name="l01332"></a>01332 {
<a name="l01333"></a>01333   uint32_t index;
<a name="l01334"></a>01334   uint32_t tickstart;
<a name="l01335"></a>01335   uint32_t deviceAddress, numSpareAreaRead = 0, nandAddress, columnAddress, nbspare = NumSpareAreaToRead;
<a name="l01336"></a>01336   uint16_t * buff = pBuffer;
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01339"></a>01339   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01340"></a>01340   {
<a name="l01341"></a>01341     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01342"></a>01342   }
<a name="l01343"></a>01343   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01344"></a>01344   {
<a name="l01345"></a>01345     <span class="comment">/* Process Locked */</span>
<a name="l01346"></a>01346     __HAL_LOCK(hnand);
<a name="l01347"></a>01347 
<a name="l01348"></a>01348     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01349"></a>01349     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01350"></a>01350 
<a name="l01351"></a>01351     <span class="comment">/* Identify the device address */</span>
<a name="l01352"></a>01352     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01353"></a>01353     {
<a name="l01354"></a>01354       deviceAddress = NAND_DEVICE1;
<a name="l01355"></a>01355     }
<a name="l01356"></a>01356     <span class="keywordflow">else</span>
<a name="l01357"></a>01357     {
<a name="l01358"></a>01358       deviceAddress = NAND_DEVICE2;
<a name="l01359"></a>01359     }
<a name="l01360"></a>01360 
<a name="l01361"></a>01361     <span class="comment">/* NAND raw address calculation */</span>
<a name="l01362"></a>01362     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l01363"></a>01363 
<a name="l01364"></a>01364     <span class="comment">/* Column in page address */</span>
<a name="l01365"></a>01365     columnAddress = (uint32_t)(COLUMN_ADDRESS(hnand) * 2U);
<a name="l01366"></a>01366 
<a name="l01367"></a>01367     <span class="comment">/* Spare area(s) read loop */</span>
<a name="l01368"></a>01368     <span class="keywordflow">while</span> ((nbspare != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l01369"></a>01369     {
<a name="l01370"></a>01370       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l01371"></a>01371       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l01372"></a>01372       {
<a name="l01373"></a>01373         <span class="comment">/* Send read spare area command sequence */</span>
<a name="l01374"></a>01374         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
<a name="l01375"></a>01375         __DSB();
<a name="l01376"></a>01376 
<a name="l01377"></a>01377         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01378"></a>01378         {
<a name="l01379"></a>01379           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01380"></a>01380           __DSB();
<a name="l01381"></a>01381           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01382"></a>01382           __DSB();
<a name="l01383"></a>01383           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01384"></a>01384           __DSB();
<a name="l01385"></a>01385         }
<a name="l01386"></a>01386         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01387"></a>01387         {
<a name="l01388"></a>01388           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01389"></a>01389           __DSB();
<a name="l01390"></a>01390           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01391"></a>01391           __DSB();
<a name="l01392"></a>01392           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01393"></a>01393           __DSB();
<a name="l01394"></a>01394           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01395"></a>01395           __DSB();
<a name="l01396"></a>01396         }
<a name="l01397"></a>01397       }
<a name="l01398"></a>01398       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l01399"></a>01399       {
<a name="l01400"></a>01400         <span class="comment">/* Send read spare area command sequence */</span>
<a name="l01401"></a>01401         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l01402"></a>01402         __DSB();
<a name="l01403"></a>01403 
<a name="l01404"></a>01404         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01405"></a>01405         {
<a name="l01406"></a>01406           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01407"></a>01407           __DSB();
<a name="l01408"></a>01408           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01409"></a>01409           __DSB();
<a name="l01410"></a>01410           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01411"></a>01411           __DSB();
<a name="l01412"></a>01412           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01413"></a>01413           __DSB();
<a name="l01414"></a>01414         }
<a name="l01415"></a>01415         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01416"></a>01416         {
<a name="l01417"></a>01417           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01418"></a>01418           __DSB();
<a name="l01419"></a>01419           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01420"></a>01420           __DSB();
<a name="l01421"></a>01421           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01422"></a>01422           __DSB();
<a name="l01423"></a>01423           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01424"></a>01424           __DSB();
<a name="l01425"></a>01425           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01426"></a>01426           __DSB();
<a name="l01427"></a>01427         }
<a name="l01428"></a>01428       }
<a name="l01429"></a>01429 
<a name="l01430"></a>01430       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_TRUE1;
<a name="l01431"></a>01431       __DSB();
<a name="l01432"></a>01432 
<a name="l01433"></a>01433       <span class="keywordflow">if</span> (hnand-&gt;Config.ExtraCommandEnable == ENABLE)
<a name="l01434"></a>01434       {
<a name="l01435"></a>01435         <span class="comment">/* Get tick */</span>
<a name="l01436"></a>01436         tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l01437"></a>01437 
<a name="l01438"></a>01438         <span class="comment">/* Read status until NAND is ready */</span>
<a name="l01439"></a>01439         <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l01440"></a>01440         {
<a name="l01441"></a>01441           <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l01442"></a>01442           {
<a name="l01443"></a>01443             <span class="comment">/* Update the NAND controller state */</span>
<a name="l01444"></a>01444             hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l01445"></a>01445 
<a name="l01446"></a>01446             <span class="comment">/* Process unlocked */</span>
<a name="l01447"></a>01447             __HAL_UNLOCK(hnand);
<a name="l01448"></a>01448 
<a name="l01449"></a>01449             <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l01450"></a>01450           }
<a name="l01451"></a>01451         }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453         <span class="comment">/* Go back to read mode */</span>
<a name="l01454"></a>01454         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = ((uint8_t)0x00U);
<a name="l01455"></a>01455         __DSB();
<a name="l01456"></a>01456       }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458       <span class="comment">/* Get Data into Buffer */</span>
<a name="l01459"></a>01459       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.SpareAreaSize; index++)
<a name="l01460"></a>01460       {
<a name="l01461"></a>01461         *buff = *(uint16_t *)deviceAddress;
<a name="l01462"></a>01462         buff++;
<a name="l01463"></a>01463       }
<a name="l01464"></a>01464 
<a name="l01465"></a>01465       <span class="comment">/* Increment read spare areas number */</span>
<a name="l01466"></a>01466       numSpareAreaRead++;
<a name="l01467"></a>01467 
<a name="l01468"></a>01468       <span class="comment">/* Decrement spare areas to read */</span>
<a name="l01469"></a>01469       nbspare--;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471       <span class="comment">/* Increment the NAND address */</span>
<a name="l01472"></a>01472       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l01473"></a>01473     }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01476"></a>01476     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01477"></a>01477 
<a name="l01478"></a>01478     <span class="comment">/* Process unlocked */</span>
<a name="l01479"></a>01479     __HAL_UNLOCK(hnand);
<a name="l01480"></a>01480   }
<a name="l01481"></a>01481   <span class="keywordflow">else</span>
<a name="l01482"></a>01482   {
<a name="l01483"></a>01483     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01484"></a>01484   }
<a name="l01485"></a>01485 
<a name="l01486"></a>01486   <span class="keywordflow">return</span> HAL_OK;
<a name="l01487"></a>01487 }
<a name="l01488"></a>01488 <span class="comment"></span>
<a name="l01489"></a>01489 <span class="comment">/**</span>
<a name="l01490"></a>01490 <span class="comment">  * @brief  Write Spare area(s) to NAND memory (8-bits addressing)</span>
<a name="l01491"></a>01491 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01492"></a>01492 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01493"></a>01493 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01494"></a>01494 <span class="comment">  * @param  pBuffer  pointer to source buffer to write</span>
<a name="l01495"></a>01495 <span class="comment">  * @param  NumSpareAreaTowrite   number of spare areas to write to block</span>
<a name="l01496"></a>01496 <span class="comment">  * @retval HAL status</span>
<a name="l01497"></a>01497 <span class="comment">  */</span>
<a name="l01498"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gafa3b1c56821926e5ec0f6cbf703eb07d">01498</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gafa3b1c56821926e5ec0f6cbf703eb07d" title="Write Spare area(s) to NAND memory (8-bits addressing)">HAL_NAND_Write_SpareArea_8b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint8_t *pBuffer, uint32_t NumSpareAreaTowrite)
<a name="l01499"></a>01499 {
<a name="l01500"></a>01500   uint32_t index;
<a name="l01501"></a>01501   uint32_t tickstart;
<a name="l01502"></a>01502   uint32_t deviceAddress, numSpareAreaWritten = 0, nandAddress, columnAddress, nbspare = NumSpareAreaTowrite;
<a name="l01503"></a>01503   uint8_t * buff = pBuffer;
<a name="l01504"></a>01504 
<a name="l01505"></a>01505   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01506"></a>01506   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01507"></a>01507   {
<a name="l01508"></a>01508     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01509"></a>01509   }
<a name="l01510"></a>01510   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01511"></a>01511   {
<a name="l01512"></a>01512     <span class="comment">/* Process Locked */</span>
<a name="l01513"></a>01513     __HAL_LOCK(hnand);
<a name="l01514"></a>01514 
<a name="l01515"></a>01515     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01516"></a>01516     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01517"></a>01517 
<a name="l01518"></a>01518     <span class="comment">/* Identify the device address */</span>
<a name="l01519"></a>01519     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01520"></a>01520     {
<a name="l01521"></a>01521       deviceAddress = NAND_DEVICE1;
<a name="l01522"></a>01522     }
<a name="l01523"></a>01523     <span class="keywordflow">else</span>
<a name="l01524"></a>01524     {
<a name="l01525"></a>01525       deviceAddress = NAND_DEVICE2;
<a name="l01526"></a>01526     }
<a name="l01527"></a>01527 
<a name="l01528"></a>01528     <span class="comment">/* Page address calculation */</span>
<a name="l01529"></a>01529     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l01530"></a>01530 
<a name="l01531"></a>01531     <span class="comment">/* Column in page address */</span>
<a name="l01532"></a>01532     columnAddress = COLUMN_ADDRESS(hnand);
<a name="l01533"></a>01533 
<a name="l01534"></a>01534     <span class="comment">/* Spare area(s) write loop */</span>
<a name="l01535"></a>01535     <span class="keywordflow">while</span> ((nbspare != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l01536"></a>01536     {
<a name="l01537"></a>01537       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l01538"></a>01538       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l01539"></a>01539       {
<a name="l01540"></a>01540         <span class="comment">/* Send write Spare area command sequence */</span>
<a name="l01541"></a>01541         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
<a name="l01542"></a>01542         __DSB();
<a name="l01543"></a>01543         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l01544"></a>01544         __DSB();
<a name="l01545"></a>01545 
<a name="l01546"></a>01546         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01547"></a>01547         {
<a name="l01548"></a>01548           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01549"></a>01549           __DSB();
<a name="l01550"></a>01550           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01551"></a>01551           __DSB();
<a name="l01552"></a>01552           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01553"></a>01553           __DSB();
<a name="l01554"></a>01554         }
<a name="l01555"></a>01555         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01556"></a>01556         {
<a name="l01557"></a>01557           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01558"></a>01558           __DSB();
<a name="l01559"></a>01559           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01560"></a>01560           __DSB();
<a name="l01561"></a>01561           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01562"></a>01562           __DSB();
<a name="l01563"></a>01563           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01564"></a>01564           __DSB();
<a name="l01565"></a>01565         }
<a name="l01566"></a>01566       }
<a name="l01567"></a>01567       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l01568"></a>01568       {
<a name="l01569"></a>01569         <span class="comment">/* Send write Spare area command sequence */</span>
<a name="l01570"></a>01570         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l01571"></a>01571         __DSB();
<a name="l01572"></a>01572         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l01573"></a>01573         __DSB();
<a name="l01574"></a>01574 
<a name="l01575"></a>01575         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01576"></a>01576         {
<a name="l01577"></a>01577           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01578"></a>01578           __DSB();
<a name="l01579"></a>01579           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01580"></a>01580           __DSB();
<a name="l01581"></a>01581           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01582"></a>01582           __DSB();
<a name="l01583"></a>01583           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01584"></a>01584           __DSB();
<a name="l01585"></a>01585         }
<a name="l01586"></a>01586         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01587"></a>01587         {
<a name="l01588"></a>01588           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01589"></a>01589           __DSB();
<a name="l01590"></a>01590           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01591"></a>01591           __DSB();
<a name="l01592"></a>01592           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01593"></a>01593           __DSB();
<a name="l01594"></a>01594           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01595"></a>01595           __DSB();
<a name="l01596"></a>01596           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01597"></a>01597           __DSB();
<a name="l01598"></a>01598         }
<a name="l01599"></a>01599       }
<a name="l01600"></a>01600 
<a name="l01601"></a>01601       <span class="comment">/* Write data to memory */</span>
<a name="l01602"></a>01602       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.SpareAreaSize; index++)
<a name="l01603"></a>01603       {
<a name="l01604"></a>01604         *(__IO uint8_t *)deviceAddress = *buff;
<a name="l01605"></a>01605         buff++;
<a name="l01606"></a>01606         __DSB();
<a name="l01607"></a>01607       }
<a name="l01608"></a>01608 
<a name="l01609"></a>01609       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE_TRUE1;
<a name="l01610"></a>01610       __DSB();
<a name="l01611"></a>01611 
<a name="l01612"></a>01612       <span class="comment">/* Get tick */</span>
<a name="l01613"></a>01613       tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l01614"></a>01614 
<a name="l01615"></a>01615       <span class="comment">/* Read status until NAND is ready */</span>
<a name="l01616"></a>01616       <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l01617"></a>01617       {
<a name="l01618"></a>01618         <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l01619"></a>01619         {
<a name="l01620"></a>01620           <span class="comment">/* Update the NAND controller state */</span>
<a name="l01621"></a>01621           hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623           <span class="comment">/* Process unlocked */</span>
<a name="l01624"></a>01624           __HAL_UNLOCK(hnand);
<a name="l01625"></a>01625 
<a name="l01626"></a>01626           <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l01627"></a>01627         }
<a name="l01628"></a>01628       }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630       <span class="comment">/* Increment written spare areas number */</span>
<a name="l01631"></a>01631       numSpareAreaWritten++;
<a name="l01632"></a>01632 
<a name="l01633"></a>01633       <span class="comment">/* Decrement spare areas to write */</span>
<a name="l01634"></a>01634       nbspare--;
<a name="l01635"></a>01635 
<a name="l01636"></a>01636       <span class="comment">/* Increment the NAND address */</span>
<a name="l01637"></a>01637       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l01638"></a>01638     }
<a name="l01639"></a>01639 
<a name="l01640"></a>01640     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01641"></a>01641     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01642"></a>01642 
<a name="l01643"></a>01643     <span class="comment">/* Process unlocked */</span>
<a name="l01644"></a>01644     __HAL_UNLOCK(hnand);
<a name="l01645"></a>01645   }
<a name="l01646"></a>01646   <span class="keywordflow">else</span>
<a name="l01647"></a>01647   {
<a name="l01648"></a>01648     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01649"></a>01649   }
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   <span class="keywordflow">return</span> HAL_OK;
<a name="l01652"></a>01652 }
<a name="l01653"></a>01653 <span class="comment"></span>
<a name="l01654"></a>01654 <span class="comment">/**</span>
<a name="l01655"></a>01655 <span class="comment">  * @brief  Write Spare area(s) to NAND memory (16-bits addressing)</span>
<a name="l01656"></a>01656 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01657"></a>01657 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01658"></a>01658 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01659"></a>01659 <span class="comment">  * @param  pBuffer  pointer to source buffer to write. pBuffer should be 16bits aligned.</span>
<a name="l01660"></a>01660 <span class="comment">  * @param  NumSpareAreaTowrite   number of spare areas to write to block</span>
<a name="l01661"></a>01661 <span class="comment">  * @retval HAL status</span>
<a name="l01662"></a>01662 <span class="comment">  */</span>
<a name="l01663"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gad8542d4140f3ac2e6f30f31261844746">01663</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gad8542d4140f3ac2e6f30f31261844746" title="Write Spare area(s) to NAND memory (16-bits addressing)">HAL_NAND_Write_SpareArea_16b</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress, uint16_t *pBuffer, uint32_t NumSpareAreaTowrite)
<a name="l01664"></a>01664 {
<a name="l01665"></a>01665   uint32_t index;
<a name="l01666"></a>01666   uint32_t tickstart;
<a name="l01667"></a>01667   uint32_t deviceAddress, numSpareAreaWritten = 0, nandAddress, columnAddress, nbspare = NumSpareAreaTowrite;
<a name="l01668"></a>01668   uint16_t * buff = pBuffer;
<a name="l01669"></a>01669 
<a name="l01670"></a>01670   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01671"></a>01671   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01672"></a>01672   {
<a name="l01673"></a>01673     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01674"></a>01674   }
<a name="l01675"></a>01675   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01676"></a>01676   {
<a name="l01677"></a>01677     <span class="comment">/* Process Locked */</span>
<a name="l01678"></a>01678     __HAL_LOCK(hnand);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01681"></a>01681     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01682"></a>01682 
<a name="l01683"></a>01683     <span class="comment">/* Identify the device address */</span>
<a name="l01684"></a>01684     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01685"></a>01685     {
<a name="l01686"></a>01686       deviceAddress = NAND_DEVICE1;
<a name="l01687"></a>01687     }
<a name="l01688"></a>01688     <span class="keywordflow">else</span>
<a name="l01689"></a>01689     {
<a name="l01690"></a>01690       deviceAddress = NAND_DEVICE2;
<a name="l01691"></a>01691     }
<a name="l01692"></a>01692 
<a name="l01693"></a>01693     <span class="comment">/* NAND raw address calculation */</span>
<a name="l01694"></a>01694     nandAddress = ARRAY_ADDRESS(pAddress, hnand);
<a name="l01695"></a>01695 
<a name="l01696"></a>01696     <span class="comment">/* Column in page address */</span>
<a name="l01697"></a>01697     columnAddress = (uint32_t)(COLUMN_ADDRESS(hnand) * 2U);
<a name="l01698"></a>01698 
<a name="l01699"></a>01699     <span class="comment">/* Spare area(s) write loop */</span>
<a name="l01700"></a>01700     <span class="keywordflow">while</span> ((nbspare != 0U) &amp;&amp; (nandAddress &lt; ((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr))))
<a name="l01701"></a>01701     {
<a name="l01702"></a>01702       <span class="comment">/* Cards with page size &lt;= 512 bytes */</span>
<a name="l01703"></a>01703       <span class="keywordflow">if</span> ((hnand-&gt;Config.PageSize) &lt;= 512U)
<a name="l01704"></a>01704       {
<a name="l01705"></a>01705         <span class="comment">/* Send write Spare area command sequence */</span>
<a name="l01706"></a>01706         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_C;
<a name="l01707"></a>01707         __DSB();
<a name="l01708"></a>01708         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l01709"></a>01709         __DSB();
<a name="l01710"></a>01710 
<a name="l01711"></a>01711         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01712"></a>01712         {
<a name="l01713"></a>01713           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01714"></a>01714           __DSB();
<a name="l01715"></a>01715           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01716"></a>01716           __DSB();
<a name="l01717"></a>01717           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01718"></a>01718           __DSB();
<a name="l01719"></a>01719         }
<a name="l01720"></a>01720         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01721"></a>01721         {
<a name="l01722"></a>01722           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = 0x00U;
<a name="l01723"></a>01723           __DSB();
<a name="l01724"></a>01724           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01725"></a>01725           __DSB();
<a name="l01726"></a>01726           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01727"></a>01727           __DSB();
<a name="l01728"></a>01728           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01729"></a>01729           __DSB();
<a name="l01730"></a>01730         }
<a name="l01731"></a>01731       }
<a name="l01732"></a>01732       <span class="keywordflow">else</span> <span class="comment">/* (hnand-&gt;Config.PageSize) &gt; 512 */</span>
<a name="l01733"></a>01733       {
<a name="l01734"></a>01734         <span class="comment">/* Send write Spare area command sequence */</span>
<a name="l01735"></a>01735         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_AREA_A;
<a name="l01736"></a>01736         __DSB();
<a name="l01737"></a>01737         *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE0;
<a name="l01738"></a>01738         __DSB();
<a name="l01739"></a>01739 
<a name="l01740"></a>01740         <span class="keywordflow">if</span> (((hnand-&gt;Config.BlockSize) * (hnand-&gt;Config.BlockNbr)) &lt;= 65535U)
<a name="l01741"></a>01741         {
<a name="l01742"></a>01742           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01743"></a>01743           __DSB();
<a name="l01744"></a>01744           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01745"></a>01745           __DSB();
<a name="l01746"></a>01746           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01747"></a>01747           __DSB();
<a name="l01748"></a>01748           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01749"></a>01749           __DSB();
<a name="l01750"></a>01750         }
<a name="l01751"></a>01751         <span class="keywordflow">else</span> <span class="comment">/* ((hnand-&gt;Config.BlockSize)*(hnand-&gt;Config.BlockNbr)) &gt; 65535 */</span>
<a name="l01752"></a>01752         {
<a name="l01753"></a>01753           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_1ST_CYCLE(columnAddress);
<a name="l01754"></a>01754           __DSB();
<a name="l01755"></a>01755           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = COLUMN_2ND_CYCLE(columnAddress);
<a name="l01756"></a>01756           __DSB();
<a name="l01757"></a>01757           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(nandAddress);
<a name="l01758"></a>01758           __DSB();
<a name="l01759"></a>01759           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(nandAddress);
<a name="l01760"></a>01760           __DSB();
<a name="l01761"></a>01761           *(__IO uint8_t *)((uint32_t)(deviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(nandAddress);
<a name="l01762"></a>01762           __DSB();
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764       }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766       <span class="comment">/* Write data to memory */</span>
<a name="l01767"></a>01767       <span class="keywordflow">for</span> (index = 0U; index &lt; hnand-&gt;Config.SpareAreaSize; index++)
<a name="l01768"></a>01768       {
<a name="l01769"></a>01769         *(__IO uint16_t *)deviceAddress = *buff;
<a name="l01770"></a>01770         buff++;
<a name="l01771"></a>01771         __DSB();
<a name="l01772"></a>01772       }
<a name="l01773"></a>01773 
<a name="l01774"></a>01774       *(__IO uint8_t *)((uint32_t)(deviceAddress | CMD_AREA)) = NAND_CMD_WRITE_TRUE1;
<a name="l01775"></a>01775       __DSB();
<a name="l01776"></a>01776 
<a name="l01777"></a>01777       <span class="comment">/* Get tick */</span>
<a name="l01778"></a>01778       tickstart = <a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>();
<a name="l01779"></a>01779 
<a name="l01780"></a>01780       <span class="comment">/* Read status until NAND is ready */</span>
<a name="l01781"></a>01781       <span class="keywordflow">while</span> (<a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(hnand) != NAND_READY)
<a name="l01782"></a>01782       {
<a name="l01783"></a>01783         <span class="keywordflow">if</span> ((<a class="code" href="group/group__HAL__Exported__Functions__Group2.html#gaf2c4f03d53e997a54e1fd5e80daa55c4" title="Provides a tick value in millisecond.">HAL_GetTick</a>() - tickstart) &gt; NAND_WRITE_TIMEOUT)
<a name="l01784"></a>01784         {
<a name="l01785"></a>01785           <span class="comment">/* Update the NAND controller state */</span>
<a name="l01786"></a>01786           hnand-&gt;State = HAL_NAND_STATE_ERROR;
<a name="l01787"></a>01787 
<a name="l01788"></a>01788           <span class="comment">/* Process unlocked */</span>
<a name="l01789"></a>01789           __HAL_UNLOCK(hnand);
<a name="l01790"></a>01790 
<a name="l01791"></a>01791           <span class="keywordflow">return</span> HAL_TIMEOUT;
<a name="l01792"></a>01792         }
<a name="l01793"></a>01793       }
<a name="l01794"></a>01794 
<a name="l01795"></a>01795       <span class="comment">/* Increment written spare areas number */</span>
<a name="l01796"></a>01796       numSpareAreaWritten++;
<a name="l01797"></a>01797 
<a name="l01798"></a>01798       <span class="comment">/* Decrement spare areas to write */</span>
<a name="l01799"></a>01799       nbspare--;
<a name="l01800"></a>01800 
<a name="l01801"></a>01801       <span class="comment">/* Increment the NAND address */</span>
<a name="l01802"></a>01802       nandAddress = (uint32_t)(nandAddress + 1U);
<a name="l01803"></a>01803     }
<a name="l01804"></a>01804 
<a name="l01805"></a>01805     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01806"></a>01806     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01807"></a>01807 
<a name="l01808"></a>01808     <span class="comment">/* Process unlocked */</span>
<a name="l01809"></a>01809     __HAL_UNLOCK(hnand);
<a name="l01810"></a>01810   }
<a name="l01811"></a>01811   <span class="keywordflow">else</span>
<a name="l01812"></a>01812   {
<a name="l01813"></a>01813     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01814"></a>01814   }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816   <span class="keywordflow">return</span> HAL_OK;
<a name="l01817"></a>01817 }
<a name="l01818"></a>01818 <span class="comment"></span>
<a name="l01819"></a>01819 <span class="comment">/**</span>
<a name="l01820"></a>01820 <span class="comment">  * @brief  NAND memory Block erase</span>
<a name="l01821"></a>01821 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01822"></a>01822 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01823"></a>01823 <span class="comment">  * @param  pAddress  pointer to NAND address structure</span>
<a name="l01824"></a>01824 <span class="comment">  * @retval HAL status</span>
<a name="l01825"></a>01825 <span class="comment">  */</span>
<a name="l01826"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gab59a9ca3f34e9154b67595db1471b33c">01826</a> HAL_StatusTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gab59a9ca3f34e9154b67595db1471b33c" title="NAND memory Block erase.">HAL_NAND_Erase_Block</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress)
<a name="l01827"></a>01827 {
<a name="l01828"></a>01828   uint32_t DeviceAddress;
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <span class="comment">/* Check the NAND controller state */</span>
<a name="l01831"></a>01831   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l01832"></a>01832   {
<a name="l01833"></a>01833     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l01834"></a>01834   }
<a name="l01835"></a>01835   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01836"></a>01836   {
<a name="l01837"></a>01837     <span class="comment">/* Process Locked */</span>
<a name="l01838"></a>01838     __HAL_LOCK(hnand);
<a name="l01839"></a>01839 
<a name="l01840"></a>01840     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01841"></a>01841     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l01842"></a>01842 
<a name="l01843"></a>01843     <span class="comment">/* Identify the device address */</span>
<a name="l01844"></a>01844     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l01845"></a>01845     {
<a name="l01846"></a>01846       DeviceAddress = NAND_DEVICE1;
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848     <span class="keywordflow">else</span>
<a name="l01849"></a>01849     {
<a name="l01850"></a>01850       DeviceAddress = NAND_DEVICE2;
<a name="l01851"></a>01851     }
<a name="l01852"></a>01852 
<a name="l01853"></a>01853     <span class="comment">/* Send Erase block command sequence */</span>
<a name="l01854"></a>01854     *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = NAND_CMD_ERASE0;
<a name="l01855"></a>01855     __DSB();
<a name="l01856"></a>01856     *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_1ST_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
<a name="l01857"></a>01857     __DSB();
<a name="l01858"></a>01858     *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_2ND_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
<a name="l01859"></a>01859     __DSB();
<a name="l01860"></a>01860     *(__IO uint8_t *)((uint32_t)(DeviceAddress | ADDR_AREA)) = ADDR_3RD_CYCLE(ARRAY_ADDRESS(pAddress, hnand));
<a name="l01861"></a>01861     __DSB();
<a name="l01862"></a>01862 
<a name="l01863"></a>01863     *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = NAND_CMD_ERASE1;
<a name="l01864"></a>01864     __DSB();
<a name="l01865"></a>01865 
<a name="l01866"></a>01866     <span class="comment">/* Update the NAND controller state */</span>
<a name="l01867"></a>01867     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l01868"></a>01868 
<a name="l01869"></a>01869     <span class="comment">/* Process unlocked */</span>
<a name="l01870"></a>01870     __HAL_UNLOCK(hnand);
<a name="l01871"></a>01871   }
<a name="l01872"></a>01872   <span class="keywordflow">else</span>
<a name="l01873"></a>01873   {
<a name="l01874"></a>01874     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01875"></a>01875   }
<a name="l01876"></a>01876 
<a name="l01877"></a>01877   <span class="keywordflow">return</span> HAL_OK;
<a name="l01878"></a>01878 }
<a name="l01879"></a>01879 <span class="comment"></span>
<a name="l01880"></a>01880 <span class="comment">/**</span>
<a name="l01881"></a>01881 <span class="comment">  * @brief  Increment the NAND memory address</span>
<a name="l01882"></a>01882 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l01883"></a>01883 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l01884"></a>01884 <span class="comment">  * @param pAddress pointer to NAND address structure</span>
<a name="l01885"></a>01885 <span class="comment">  * @retval The new status of the increment address operation. It can be:</span>
<a name="l01886"></a>01886 <span class="comment">  *           - NAND_VALID_ADDRESS: When the new address is valid address</span>
<a name="l01887"></a>01887 <span class="comment">  *           - NAND_INVALID_ADDRESS: When the new address is invalid address</span>
<a name="l01888"></a>01888 <span class="comment">  */</span>
<a name="l01889"></a><a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gae2a8dd61d92a8f108e9708f39e3e1aac">01889</a> uint32_t <a class="code" href="group/group__NAND__Exported__Functions__Group2.html#gae2a8dd61d92a8f108e9708f39e3e1aac" title="Increment the NAND memory address.">HAL_NAND_Address_Inc</a>(NAND_HandleTypeDef *hnand, NAND_AddressTypeDef *pAddress)
<a name="l01890"></a>01890 {
<a name="l01891"></a>01891   uint32_t status = NAND_VALID_ADDRESS;
<a name="l01892"></a>01892 
<a name="l01893"></a>01893   <span class="comment">/* Increment page address */</span>
<a name="l01894"></a>01894   pAddress-&gt;Page++;
<a name="l01895"></a>01895 
<a name="l01896"></a>01896   <span class="comment">/* Check NAND address is valid */</span>
<a name="l01897"></a>01897   <span class="keywordflow">if</span> (pAddress-&gt;Page == hnand-&gt;Config.BlockSize)
<a name="l01898"></a>01898   {
<a name="l01899"></a>01899     pAddress-&gt;Page = 0;
<a name="l01900"></a>01900     pAddress-&gt;Block++;
<a name="l01901"></a>01901 
<a name="l01902"></a>01902     <span class="keywordflow">if</span> (pAddress-&gt;Block == hnand-&gt;Config.PlaneSize)
<a name="l01903"></a>01903     {
<a name="l01904"></a>01904       pAddress-&gt;Block = 0;
<a name="l01905"></a>01905       pAddress-&gt;Plane++;
<a name="l01906"></a>01906 
<a name="l01907"></a>01907       <span class="keywordflow">if</span> (pAddress-&gt;Plane == (hnand-&gt;Config.PlaneNbr))
<a name="l01908"></a>01908       {
<a name="l01909"></a>01909         status = NAND_INVALID_ADDRESS;
<a name="l01910"></a>01910       }
<a name="l01911"></a>01911     }
<a name="l01912"></a>01912   }
<a name="l01913"></a>01913 
<a name="l01914"></a>01914   <span class="keywordflow">return</span> (status);
<a name="l01915"></a>01915 }
<a name="l01916"></a>01916 
<a name="l01917"></a>01917 <span class="preprocessor">#if (USE_HAL_NAND_REGISTER_CALLBACKS == 1)</span>
<a name="l01918"></a>01918 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01919"></a>01919 <span class="comment">  * @brief  Register a User NAND Callback</span>
<a name="l01920"></a>01920 <span class="comment">  *         To be used instead of the weak (surcharged) predefined callback</span>
<a name="l01921"></a>01921 <span class="comment">  * @param hnand : NAND handle</span>
<a name="l01922"></a>01922 <span class="comment">  * @param CallbackId : ID of the callback to be registered</span>
<a name="l01923"></a>01923 <span class="comment">  *        This parameter can be one of the following values:</span>
<a name="l01924"></a>01924 <span class="comment">  *          @arg @ref HAL_NAND_MSP_INIT_CB_ID       NAND MspInit callback ID</span>
<a name="l01925"></a>01925 <span class="comment">  *          @arg @ref HAL_NAND_MSP_DEINIT_CB_ID     NAND MspDeInit callback ID</span>
<a name="l01926"></a>01926 <span class="comment">  *          @arg @ref HAL_NAND_IT_CB_ID             NAND IT callback ID</span>
<a name="l01927"></a>01927 <span class="comment">  * @param pCallback : pointer to the Callback function</span>
<a name="l01928"></a>01928 <span class="comment">  * @retval status</span>
<a name="l01929"></a>01929 <span class="comment">  */</span>
<a name="l01930"></a>01930 HAL_StatusTypeDef HAL_NAND_RegisterCallback (NAND_HandleTypeDef *hnand, HAL_NAND_CallbackIDTypeDef CallbackId, pNAND_CallbackTypeDef pCallback)
<a name="l01931"></a>01931 {
<a name="l01932"></a>01932   HAL_StatusTypeDef status = HAL_OK;
<a name="l01933"></a>01933 
<a name="l01934"></a>01934   <span class="keywordflow">if</span>(pCallback == NULL)
<a name="l01935"></a>01935   {
<a name="l01936"></a>01936     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01937"></a>01937   }
<a name="l01938"></a>01938 
<a name="l01939"></a>01939   <span class="comment">/* Process locked */</span>
<a name="l01940"></a>01940   __HAL_LOCK(hnand);
<a name="l01941"></a>01941 
<a name="l01942"></a>01942   <span class="keywordflow">if</span>(hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l01943"></a>01943   {
<a name="l01944"></a>01944     <span class="keywordflow">switch</span> (CallbackId)
<a name="l01945"></a>01945     {
<a name="l01946"></a>01946     <span class="keywordflow">case</span> HAL_NAND_MSP_INIT_CB_ID :
<a name="l01947"></a>01947       hnand-&gt;MspInitCallback = pCallback;
<a name="l01948"></a>01948       <span class="keywordflow">break</span>;
<a name="l01949"></a>01949     <span class="keywordflow">case</span> HAL_NAND_MSP_DEINIT_CB_ID :
<a name="l01950"></a>01950       hnand-&gt;MspDeInitCallback = pCallback;
<a name="l01951"></a>01951       <span class="keywordflow">break</span>;
<a name="l01952"></a>01952     <span class="keywordflow">case</span> HAL_NAND_IT_CB_ID :
<a name="l01953"></a>01953       hnand-&gt;ItCallback = pCallback;
<a name="l01954"></a>01954       <span class="keywordflow">break</span>;
<a name="l01955"></a>01955     <span class="keywordflow">default</span> :
<a name="l01956"></a>01956       <span class="comment">/* update return status */</span>
<a name="l01957"></a>01957       status =  HAL_ERROR;
<a name="l01958"></a>01958       <span class="keywordflow">break</span>;
<a name="l01959"></a>01959     }
<a name="l01960"></a>01960   }
<a name="l01961"></a>01961   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(hnand-&gt;State == HAL_NAND_STATE_RESET)
<a name="l01962"></a>01962   {
<a name="l01963"></a>01963     <span class="keywordflow">switch</span> (CallbackId)
<a name="l01964"></a>01964     {
<a name="l01965"></a>01965     <span class="keywordflow">case</span> HAL_NAND_MSP_INIT_CB_ID :
<a name="l01966"></a>01966       hnand-&gt;MspInitCallback = pCallback;
<a name="l01967"></a>01967       <span class="keywordflow">break</span>;
<a name="l01968"></a>01968     <span class="keywordflow">case</span> HAL_NAND_MSP_DEINIT_CB_ID :
<a name="l01969"></a>01969       hnand-&gt;MspDeInitCallback = pCallback;
<a name="l01970"></a>01970       <span class="keywordflow">break</span>;
<a name="l01971"></a>01971     <span class="keywordflow">default</span> :
<a name="l01972"></a>01972       <span class="comment">/* update return status */</span>
<a name="l01973"></a>01973       status =  HAL_ERROR;
<a name="l01974"></a>01974       <span class="keywordflow">break</span>;
<a name="l01975"></a>01975     }
<a name="l01976"></a>01976   }
<a name="l01977"></a>01977   <span class="keywordflow">else</span>
<a name="l01978"></a>01978   {
<a name="l01979"></a>01979     <span class="comment">/* update return status */</span>
<a name="l01980"></a>01980     status =  HAL_ERROR;
<a name="l01981"></a>01981   }
<a name="l01982"></a>01982 
<a name="l01983"></a>01983   <span class="comment">/* Release Lock */</span>
<a name="l01984"></a>01984   __HAL_UNLOCK(hnand);
<a name="l01985"></a>01985   <span class="keywordflow">return</span> status;
<a name="l01986"></a>01986 }
<a name="l01987"></a>01987 <span class="comment"></span>
<a name="l01988"></a>01988 <span class="comment">/**</span>
<a name="l01989"></a>01989 <span class="comment">  * @brief  Unregister a User NAND Callback</span>
<a name="l01990"></a>01990 <span class="comment">  *         NAND Callback is redirected to the weak (surcharged) predefined callback</span>
<a name="l01991"></a>01991 <span class="comment">  * @param hnand : NAND handle</span>
<a name="l01992"></a>01992 <span class="comment">  * @param CallbackId : ID of the callback to be unregistered</span>
<a name="l01993"></a>01993 <span class="comment">  *        This parameter can be one of the following values:</span>
<a name="l01994"></a>01994 <span class="comment">  *          @arg @ref HAL_NAND_MSP_INIT_CB_ID       NAND MspInit callback ID</span>
<a name="l01995"></a>01995 <span class="comment">  *          @arg @ref HAL_NAND_MSP_DEINIT_CB_ID     NAND MspDeInit callback ID</span>
<a name="l01996"></a>01996 <span class="comment">  *          @arg @ref HAL_NAND_IT_CB_ID             NAND IT callback ID</span>
<a name="l01997"></a>01997 <span class="comment">  * @retval status</span>
<a name="l01998"></a>01998 <span class="comment">  */</span>
<a name="l01999"></a>01999 HAL_StatusTypeDef HAL_NAND_UnRegisterCallback (NAND_HandleTypeDef *hnand, HAL_NAND_CallbackIDTypeDef CallbackId)
<a name="l02000"></a>02000 {
<a name="l02001"></a>02001   HAL_StatusTypeDef status = HAL_OK;
<a name="l02002"></a>02002 
<a name="l02003"></a>02003   <span class="comment">/* Process locked */</span>
<a name="l02004"></a>02004   __HAL_LOCK(hnand);
<a name="l02005"></a>02005 
<a name="l02006"></a>02006   <span class="keywordflow">if</span>(hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l02007"></a>02007   {
<a name="l02008"></a>02008     <span class="keywordflow">switch</span> (CallbackId)
<a name="l02009"></a>02009     {
<a name="l02010"></a>02010     <span class="keywordflow">case</span> HAL_NAND_MSP_INIT_CB_ID :
<a name="l02011"></a>02011       hnand-&gt;MspInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404" title="NAND MSP Init.">HAL_NAND_MspInit</a>;
<a name="l02012"></a>02012       <span class="keywordflow">break</span>;
<a name="l02013"></a>02013     <span class="keywordflow">case</span> HAL_NAND_MSP_DEINIT_CB_ID :
<a name="l02014"></a>02014       hnand-&gt;MspDeInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763" title="NAND MSP DeInit.">HAL_NAND_MspDeInit</a>;
<a name="l02015"></a>02015       <span class="keywordflow">break</span>;
<a name="l02016"></a>02016     <span class="keywordflow">case</span> HAL_NAND_IT_CB_ID :
<a name="l02017"></a>02017       hnand-&gt;ItCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga376a6982016a02dea68e76e2a2fb8cc4" title="NAND interrupt feature callback.">HAL_NAND_ITCallback</a>;
<a name="l02018"></a>02018       <span class="keywordflow">break</span>;
<a name="l02019"></a>02019     <span class="keywordflow">default</span> :
<a name="l02020"></a>02020       <span class="comment">/* update return status */</span>
<a name="l02021"></a>02021       status =  HAL_ERROR;
<a name="l02022"></a>02022       <span class="keywordflow">break</span>;
<a name="l02023"></a>02023     }
<a name="l02024"></a>02024   }
<a name="l02025"></a>02025   <span class="keywordflow">else</span> <span class="keywordflow">if</span>(hnand-&gt;State == HAL_NAND_STATE_RESET)
<a name="l02026"></a>02026   {
<a name="l02027"></a>02027     <span class="keywordflow">switch</span> (CallbackId)
<a name="l02028"></a>02028     {
<a name="l02029"></a>02029     <span class="keywordflow">case</span> HAL_NAND_MSP_INIT_CB_ID :
<a name="l02030"></a>02030       hnand-&gt;MspInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga57ef3814180cf717dabf240a2b396404" title="NAND MSP Init.">HAL_NAND_MspInit</a>;
<a name="l02031"></a>02031       <span class="keywordflow">break</span>;
<a name="l02032"></a>02032     <span class="keywordflow">case</span> HAL_NAND_MSP_DEINIT_CB_ID :
<a name="l02033"></a>02033       hnand-&gt;MspDeInitCallback = <a class="code" href="group/group__NAND__Exported__Functions__Group1.html#ga182939bc00bdda782830b706f5a7c763" title="NAND MSP DeInit.">HAL_NAND_MspDeInit</a>;
<a name="l02034"></a>02034       <span class="keywordflow">break</span>;
<a name="l02035"></a>02035     <span class="keywordflow">default</span> :
<a name="l02036"></a>02036       <span class="comment">/* update return status */</span>
<a name="l02037"></a>02037       status =  HAL_ERROR;
<a name="l02038"></a>02038       <span class="keywordflow">break</span>;
<a name="l02039"></a>02039     }
<a name="l02040"></a>02040   }
<a name="l02041"></a>02041   <span class="keywordflow">else</span>
<a name="l02042"></a>02042   {
<a name="l02043"></a>02043     <span class="comment">/* update return status */</span>
<a name="l02044"></a>02044     status =  HAL_ERROR;
<a name="l02045"></a>02045   }
<a name="l02046"></a>02046 
<a name="l02047"></a>02047   <span class="comment">/* Release Lock */</span>
<a name="l02048"></a>02048   __HAL_UNLOCK(hnand);
<a name="l02049"></a>02049   <span class="keywordflow">return</span> status;
<a name="l02050"></a>02050 }
<a name="l02051"></a>02051 <span class="preprocessor">#endif</span>
<a name="l02052"></a>02052 <span class="preprocessor"></span><span class="comment"></span>
<a name="l02053"></a>02053 <span class="comment">/**</span>
<a name="l02054"></a>02054 <span class="comment">  * @}</span>
<a name="l02055"></a>02055 <span class="comment">  */</span>
<a name="l02056"></a>02056 <span class="comment"></span>
<a name="l02057"></a>02057 <span class="comment">/** @defgroup NAND_Exported_Functions_Group3 Peripheral Control functions</span>
<a name="l02058"></a>02058 <span class="comment"> *  @brief   management functions</span>
<a name="l02059"></a>02059 <span class="comment"> *</span>
<a name="l02060"></a>02060 <span class="comment">@verbatim</span>
<a name="l02061"></a>02061 <span class="comment">  ==============================================================================</span>
<a name="l02062"></a>02062 <span class="comment">                         ##### NAND Control functions #####</span>
<a name="l02063"></a>02063 <span class="comment">  ==============================================================================</span>
<a name="l02064"></a>02064 <span class="comment">  [..]</span>
<a name="l02065"></a>02065 <span class="comment">    This subsection provides a set of functions allowing to control dynamically</span>
<a name="l02066"></a>02066 <span class="comment">    the NAND interface.</span>
<a name="l02067"></a>02067 <span class="comment"></span>
<a name="l02068"></a>02068 <span class="comment">@endverbatim</span>
<a name="l02069"></a>02069 <span class="comment">  * @{</span>
<a name="l02070"></a>02070 <span class="comment">  */</span>
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 <span class="comment"></span>
<a name="l02073"></a>02073 <span class="comment">/**</span>
<a name="l02074"></a>02074 <span class="comment">  * @brief  Enables dynamically NAND ECC feature.</span>
<a name="l02075"></a>02075 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l02076"></a>02076 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l02077"></a>02077 <span class="comment">  * @retval HAL status</span>
<a name="l02078"></a>02078 <span class="comment">  */</span>
<a name="l02079"></a><a class="code" href="group/group__NAND__Exported__Functions__Group3.html#ga91316bfd4f3ad4770bbb06e02071ce35">02079</a> HAL_StatusTypeDef  <a class="code" href="group/group__NAND__Exported__Functions__Group3.html#ga91316bfd4f3ad4770bbb06e02071ce35" title="Enables dynamically NAND ECC feature.">HAL_NAND_ECC_Enable</a>(NAND_HandleTypeDef *hnand)
<a name="l02080"></a>02080 {
<a name="l02081"></a>02081   <span class="comment">/* Check the NAND controller state */</span>
<a name="l02082"></a>02082   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l02083"></a>02083   {
<a name="l02084"></a>02084     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l02085"></a>02085   }
<a name="l02086"></a>02086   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l02087"></a>02087   {
<a name="l02088"></a>02088     <span class="comment">/* Update the NAND state */</span>
<a name="l02089"></a>02089     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l02090"></a>02090 
<a name="l02091"></a>02091     <span class="comment">/* Enable ECC feature */</span>
<a name="l02092"></a>02092     (void)FSMC_NAND_ECC_Enable(hnand-&gt;Instance, hnand-&gt;Init.NandBank);
<a name="l02093"></a>02093 
<a name="l02094"></a>02094     <span class="comment">/* Update the NAND state */</span>
<a name="l02095"></a>02095     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l02096"></a>02096   }
<a name="l02097"></a>02097   <span class="keywordflow">else</span>
<a name="l02098"></a>02098   {
<a name="l02099"></a>02099     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l02100"></a>02100   }
<a name="l02101"></a>02101 
<a name="l02102"></a>02102   <span class="keywordflow">return</span> HAL_OK;
<a name="l02103"></a>02103 }
<a name="l02104"></a>02104 <span class="comment"></span>
<a name="l02105"></a>02105 <span class="comment">/**</span>
<a name="l02106"></a>02106 <span class="comment">  * @brief  Disables dynamically FSMC_NAND ECC feature.</span>
<a name="l02107"></a>02107 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l02108"></a>02108 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l02109"></a>02109 <span class="comment">  * @retval HAL status</span>
<a name="l02110"></a>02110 <span class="comment">  */</span>
<a name="l02111"></a><a class="code" href="group/group__NAND__Exported__Functions__Group3.html#ga29344a7cb80d2713e5f0d0738abcff51">02111</a> HAL_StatusTypeDef  <a class="code" href="group/group__NAND__Exported__Functions__Group3.html#ga29344a7cb80d2713e5f0d0738abcff51" title="Disables dynamically FSMC_NAND ECC feature.">HAL_NAND_ECC_Disable</a>(NAND_HandleTypeDef *hnand)
<a name="l02112"></a>02112 {
<a name="l02113"></a>02113   <span class="comment">/* Check the NAND controller state */</span>
<a name="l02114"></a>02114   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l02115"></a>02115   {
<a name="l02116"></a>02116     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l02117"></a>02117   }
<a name="l02118"></a>02118   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l02119"></a>02119   {
<a name="l02120"></a>02120     <span class="comment">/* Update the NAND state */</span>
<a name="l02121"></a>02121     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l02122"></a>02122 
<a name="l02123"></a>02123     <span class="comment">/* Disable ECC feature */</span>
<a name="l02124"></a>02124     (void)FSMC_NAND_ECC_Disable(hnand-&gt;Instance, hnand-&gt;Init.NandBank);
<a name="l02125"></a>02125 
<a name="l02126"></a>02126     <span class="comment">/* Update the NAND state */</span>
<a name="l02127"></a>02127     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l02128"></a>02128   }
<a name="l02129"></a>02129   <span class="keywordflow">else</span>
<a name="l02130"></a>02130   {
<a name="l02131"></a>02131     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l02132"></a>02132   }
<a name="l02133"></a>02133 
<a name="l02134"></a>02134   <span class="keywordflow">return</span> HAL_OK;
<a name="l02135"></a>02135 }
<a name="l02136"></a>02136 <span class="comment"></span>
<a name="l02137"></a>02137 <span class="comment">/**</span>
<a name="l02138"></a>02138 <span class="comment">  * @brief  Disables dynamically NAND ECC feature.</span>
<a name="l02139"></a>02139 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l02140"></a>02140 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l02141"></a>02141 <span class="comment">  * @param  ECCval pointer to ECC value</span>
<a name="l02142"></a>02142 <span class="comment">  * @param  Timeout maximum timeout to wait</span>
<a name="l02143"></a>02143 <span class="comment">  * @retval HAL status</span>
<a name="l02144"></a>02144 <span class="comment">  */</span>
<a name="l02145"></a><a class="code" href="group/group__NAND__Exported__Functions__Group3.html#gaa7a44e9d310ac35802936c8427055daf">02145</a> HAL_StatusTypeDef  <a class="code" href="group/group__NAND__Exported__Functions__Group3.html#gaa7a44e9d310ac35802936c8427055daf" title="Disables dynamically NAND ECC feature.">HAL_NAND_GetECC</a>(NAND_HandleTypeDef *hnand, uint32_t *ECCval, uint32_t Timeout)
<a name="l02146"></a>02146 {
<a name="l02147"></a>02147   HAL_StatusTypeDef status;
<a name="l02148"></a>02148 
<a name="l02149"></a>02149   <span class="comment">/* Check the NAND controller state */</span>
<a name="l02150"></a>02150   <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_BUSY)
<a name="l02151"></a>02151   {
<a name="l02152"></a>02152     <span class="keywordflow">return</span> HAL_BUSY;
<a name="l02153"></a>02153   }
<a name="l02154"></a>02154   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hnand-&gt;State == HAL_NAND_STATE_READY)
<a name="l02155"></a>02155   {
<a name="l02156"></a>02156     <span class="comment">/* Update the NAND state */</span>
<a name="l02157"></a>02157     hnand-&gt;State = HAL_NAND_STATE_BUSY;
<a name="l02158"></a>02158 
<a name="l02159"></a>02159     <span class="comment">/* Get NAND ECC value */</span>
<a name="l02160"></a>02160     status = FSMC_NAND_GetECC(hnand-&gt;Instance, ECCval, hnand-&gt;Init.NandBank, Timeout);
<a name="l02161"></a>02161 
<a name="l02162"></a>02162     <span class="comment">/* Update the NAND state */</span>
<a name="l02163"></a>02163     hnand-&gt;State = HAL_NAND_STATE_READY;
<a name="l02164"></a>02164   }
<a name="l02165"></a>02165   <span class="keywordflow">else</span>
<a name="l02166"></a>02166   {
<a name="l02167"></a>02167     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l02168"></a>02168   }
<a name="l02169"></a>02169 
<a name="l02170"></a>02170   <span class="keywordflow">return</span> status;
<a name="l02171"></a>02171 }
<a name="l02172"></a>02172 <span class="comment"></span>
<a name="l02173"></a>02173 <span class="comment">/**</span>
<a name="l02174"></a>02174 <span class="comment">  * @}</span>
<a name="l02175"></a>02175 <span class="comment">  */</span>
<a name="l02176"></a>02176 
<a name="l02177"></a>02177 <span class="comment"></span>
<a name="l02178"></a>02178 <span class="comment">/** @defgroup NAND_Exported_Functions_Group4 Peripheral State functions</span>
<a name="l02179"></a>02179 <span class="comment"> *  @brief   Peripheral State functions</span>
<a name="l02180"></a>02180 <span class="comment"> *</span>
<a name="l02181"></a>02181 <span class="comment">@verbatim</span>
<a name="l02182"></a>02182 <span class="comment">  ==============================================================================</span>
<a name="l02183"></a>02183 <span class="comment">                         ##### NAND State functions #####</span>
<a name="l02184"></a>02184 <span class="comment">  ==============================================================================</span>
<a name="l02185"></a>02185 <span class="comment">  [..]</span>
<a name="l02186"></a>02186 <span class="comment">    This subsection permits to get in run-time the status of the NAND controller</span>
<a name="l02187"></a>02187 <span class="comment">    and the data flow.</span>
<a name="l02188"></a>02188 <span class="comment"></span>
<a name="l02189"></a>02189 <span class="comment">@endverbatim</span>
<a name="l02190"></a>02190 <span class="comment">  * @{</span>
<a name="l02191"></a>02191 <span class="comment">  */</span>
<a name="l02192"></a>02192 <span class="comment"></span>
<a name="l02193"></a>02193 <span class="comment">/**</span>
<a name="l02194"></a>02194 <span class="comment">  * @brief  return the NAND state</span>
<a name="l02195"></a>02195 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l02196"></a>02196 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l02197"></a>02197 <span class="comment">  * @retval HAL state</span>
<a name="l02198"></a>02198 <span class="comment">  */</span>
<a name="l02199"></a><a class="code" href="group/group__NAND__Exported__Functions__Group4.html#ga49a9b2dd282dcdf6e0670952e1bf57af">02199</a> HAL_NAND_StateTypeDef <a class="code" href="group/group__NAND__Exported__Functions__Group4.html#ga49a9b2dd282dcdf6e0670952e1bf57af" title="return the NAND state">HAL_NAND_GetState</a>(NAND_HandleTypeDef *hnand)
<a name="l02200"></a>02200 {
<a name="l02201"></a>02201   <span class="keywordflow">return</span> hnand-&gt;State;
<a name="l02202"></a>02202 }
<a name="l02203"></a>02203 <span class="comment"></span>
<a name="l02204"></a>02204 <span class="comment">/**</span>
<a name="l02205"></a>02205 <span class="comment">  * @brief  NAND memory read status</span>
<a name="l02206"></a>02206 <span class="comment">  * @param  hnand pointer to a NAND_HandleTypeDef structure that contains</span>
<a name="l02207"></a>02207 <span class="comment">  *                the configuration information for NAND module.</span>
<a name="l02208"></a>02208 <span class="comment">  * @retval NAND status</span>
<a name="l02209"></a>02209 <span class="comment">  */</span>
<a name="l02210"></a><a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9">02210</a> uint32_t <a class="code" href="group/group__NAND__Exported__Functions__Group4.html#gabf19dc1c0c665d8ba9589dbf5e751cd9" title="NAND memory read status.">HAL_NAND_Read_Status</a>(NAND_HandleTypeDef *hnand)
<a name="l02211"></a>02211 {
<a name="l02212"></a>02212   uint32_t data;
<a name="l02213"></a>02213   uint32_t DeviceAddress;
<a name="l02214"></a>02214   UNUSED(hnand);
<a name="l02215"></a>02215 
<a name="l02216"></a>02216   <span class="comment">/* Identify the device address */</span>
<a name="l02217"></a>02217     <span class="keywordflow">if</span>(hnand-&gt;Init.NandBank == FSMC_NAND_BANK2)
<a name="l02218"></a>02218     {
<a name="l02219"></a>02219       DeviceAddress = NAND_DEVICE1;
<a name="l02220"></a>02220     }
<a name="l02221"></a>02221     <span class="keywordflow">else</span>
<a name="l02222"></a>02222     {
<a name="l02223"></a>02223       DeviceAddress = NAND_DEVICE2;
<a name="l02224"></a>02224     }
<a name="l02225"></a>02225 
<a name="l02226"></a>02226   <span class="comment">/* Send Read status operation command */</span>
<a name="l02227"></a>02227   *(__IO uint8_t *)((uint32_t)(DeviceAddress | CMD_AREA)) = NAND_CMD_STATUS;
<a name="l02228"></a>02228 
<a name="l02229"></a>02229   <span class="comment">/* Read status register data */</span>
<a name="l02230"></a>02230   data = *(__IO uint8_t *)DeviceAddress;
<a name="l02231"></a>02231 
<a name="l02232"></a>02232   <span class="comment">/* Return the status */</span>
<a name="l02233"></a>02233   <span class="keywordflow">if</span> ((data &amp; NAND_ERROR) == NAND_ERROR)
<a name="l02234"></a>02234   {
<a name="l02235"></a>02235     <span class="keywordflow">return</span> NAND_ERROR;
<a name="l02236"></a>02236   }
<a name="l02237"></a>02237   <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((data &amp; NAND_READY) == NAND_READY)
<a name="l02238"></a>02238   {
<a name="l02239"></a>02239     <span class="keywordflow">return</span> NAND_READY;
<a name="l02240"></a>02240   }
<a name="l02241"></a>02241   <span class="keywordflow">else</span>
<a name="l02242"></a>02242   {
<a name="l02243"></a>02243     <span class="keywordflow">return</span> NAND_BUSY;
<a name="l02244"></a>02244   }
<a name="l02245"></a>02245 }
<a name="l02246"></a>02246 <span class="comment"></span>
<a name="l02247"></a>02247 <span class="comment">/**</span>
<a name="l02248"></a>02248 <span class="comment">  * @}</span>
<a name="l02249"></a>02249 <span class="comment">  */</span>
<a name="l02250"></a>02250 <span class="comment"></span>
<a name="l02251"></a>02251 <span class="comment">/**</span>
<a name="l02252"></a>02252 <span class="comment">  * @}</span>
<a name="l02253"></a>02253 <span class="comment">  */</span>
<a name="l02254"></a>02254 <span class="comment"></span>
<a name="l02255"></a>02255 <span class="comment">/**</span>
<a name="l02256"></a>02256 <span class="comment">  * @}</span>
<a name="l02257"></a>02257 <span class="comment">  */</span>
<a name="l02258"></a>02258 
<a name="l02259"></a>02259 <span class="preprocessor">#endif </span><span class="comment">/* HAL_NAND_MODULE_ENABLED  */</span>
<a name="l02260"></a>02260 <span class="comment"></span>
<a name="l02261"></a>02261 <span class="comment">/**</span>
<a name="l02262"></a>02262 <span class="comment">  * @}</span>
<a name="l02263"></a>02263 <span class="comment">  */</span>
<a name="l02264"></a>02264 
<a name="l02265"></a>02265 <span class="preprocessor">#endif </span><span class="comment">/* FSMC_BANK3 */</span>
<a name="l02266"></a>02266 
<a name="l02267"></a>02267 <span class="comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue May 14 2019 08:56:52 for STM32F103xG HAL User Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
