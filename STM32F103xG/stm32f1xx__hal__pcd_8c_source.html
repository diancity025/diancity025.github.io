<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>STM32F103xG HAL User Manual: stm32f1xx_hal_pcd.c Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">STM32F103xG HAL User Manual
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_87d736d687b37c2c2535f3171b4da10d.html">Firmware</a>      </li>
      <li class="navelem"><a class="el" href="dir_77a4a036479ba611396f4796e3271770.html">Drivers</a>      </li>
      <li class="navelem"><a class="el" href="dir_e90ca8f7a3453277a713b77fb925b18f.html">STM32F1xx_HAL_Driver</a>      </li>
      <li class="navelem"><a class="el" href="dir_08b87254197b135abc61821bb66d28f7.html">Src</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">stm32f1xx_hal_pcd.c</div>  </div>
</div><!--header-->
<div class="contents">
<a href="stm32f1xx__hal__pcd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/**</span>
<a name="l00002"></a>00002 <span class="comment">  ******************************************************************************</span>
<a name="l00003"></a>00003 <span class="comment">  * @file    stm32f1xx_hal_pcd.c</span>
<a name="l00004"></a>00004 <span class="comment">  * @author  MCD Application Team</span>
<a name="l00005"></a>00005 <span class="comment">  * @brief   PCD HAL module driver.</span>
<a name="l00006"></a>00006 <span class="comment">  *          This file provides firmware functions to manage the following</span>
<a name="l00007"></a>00007 <span class="comment">  *          functionalities of the USB Peripheral Controller:</span>
<a name="l00008"></a>00008 <span class="comment">  *           + Initialization and de-initialization functions</span>
<a name="l00009"></a>00009 <span class="comment">  *           + IO operation functions</span>
<a name="l00010"></a>00010 <span class="comment">  *           + Peripheral Control functions</span>
<a name="l00011"></a>00011 <span class="comment">  *           + Peripheral State functions</span>
<a name="l00012"></a>00012 <span class="comment">  *</span>
<a name="l00013"></a>00013 <span class="comment">  @verbatim</span>
<a name="l00014"></a>00014 <span class="comment">  ==============================================================================</span>
<a name="l00015"></a>00015 <span class="comment">                    ##### How to use this driver #####</span>
<a name="l00016"></a>00016 <span class="comment">  ==============================================================================</span>
<a name="l00017"></a>00017 <span class="comment">    [..]</span>
<a name="l00018"></a>00018 <span class="comment">      The PCD HAL driver can be used as follows:</span>
<a name="l00019"></a>00019 <span class="comment"></span>
<a name="l00020"></a>00020 <span class="comment">     (#) Declare a PCD_HandleTypeDef handle structure, for example:</span>
<a name="l00021"></a>00021 <span class="comment">         PCD_HandleTypeDef  hpcd;</span>
<a name="l00022"></a>00022 <span class="comment"></span>
<a name="l00023"></a>00023 <span class="comment">     (#) Fill parameters of Init structure in HCD handle</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">     (#) Call HAL_PCD_Init() API to initialize the PCD peripheral (Core, Device core, ...)</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">     (#) Initialize the PCD low level resources through the HAL_PCD_MspInit() API:</span>
<a name="l00028"></a>00028 <span class="comment">         (##) Enable the PCD/USB Low Level interface clock using</span>
<a name="l00029"></a>00029 <span class="comment">              (+++) __HAL_RCC_USB_CLK_ENABLE(); For USB Device only FS peripheral</span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">         (##) Initialize the related GPIO clocks</span>
<a name="l00032"></a>00032 <span class="comment">         (##) Configure PCD pin-out</span>
<a name="l00033"></a>00033 <span class="comment">         (##) Configure PCD NVIC interrupt</span>
<a name="l00034"></a>00034 <span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">     (#)Associate the Upper USB device stack to the HAL PCD Driver:</span>
<a name="l00036"></a>00036 <span class="comment">         (##) hpcd.pData = pdev;</span>
<a name="l00037"></a>00037 <span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">     (#)Enable PCD transmission and reception:</span>
<a name="l00039"></a>00039 <span class="comment">         (##) HAL_PCD_Start();</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="comment">  @endverbatim</span>
<a name="l00042"></a>00042 <span class="comment">  ******************************************************************************</span>
<a name="l00043"></a>00043 <span class="comment">  * @attention</span>
<a name="l00044"></a>00044 <span class="comment">  *</span>
<a name="l00045"></a>00045 <span class="comment">  * &lt;h2&gt;&lt;center&gt;&amp;copy; Copyright (c) 2016 STMicroelectronics.</span>
<a name="l00046"></a>00046 <span class="comment">  * All rights reserved.&lt;/center&gt;&lt;/h2&gt;</span>
<a name="l00047"></a>00047 <span class="comment">  *</span>
<a name="l00048"></a>00048 <span class="comment">  * This software component is licensed by ST under BSD 3-Clause license,</span>
<a name="l00049"></a>00049 <span class="comment">  * the &quot;License&quot;; You may not use this file except in compliance with the</span>
<a name="l00050"></a>00050 <span class="comment">  * License. You may obtain a copy of the License at:</span>
<a name="l00051"></a>00051 <span class="comment">  *                        opensource.org/licenses/BSD-3-Clause</span>
<a name="l00052"></a>00052 <span class="comment">  *</span>
<a name="l00053"></a>00053 <span class="comment">  ******************************************************************************</span>
<a name="l00054"></a>00054 <span class="comment">  */</span>
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="comment">/* Includes ------------------------------------------------------------------*/</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &quot;<a class="code" href="stm32f1xx__hal_8h.html" title="This file contains all the functions prototypes for the HAL module driver.">stm32f1xx_hal.h</a>&quot;</span>
<a name="l00058"></a>00058 <span class="comment"></span>
<a name="l00059"></a>00059 <span class="comment">/** @addtogroup STM32F1xx_HAL_Driver</span>
<a name="l00060"></a>00060 <span class="comment">  * @{</span>
<a name="l00061"></a>00061 <span class="comment">  */</span>
<a name="l00062"></a>00062 <span class="comment"></span>
<a name="l00063"></a>00063 <span class="comment">/** @defgroup PCD PCD</span>
<a name="l00064"></a>00064 <span class="comment">  * @brief PCD HAL module driver</span>
<a name="l00065"></a>00065 <span class="comment">  * @{</span>
<a name="l00066"></a>00066 <span class="comment">  */</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="preprocessor">#ifdef HAL_PCD_MODULE_ENABLED</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span>
<a name="l00070"></a>00070 <span class="preprocessor">#if defined (USB) || defined (USB_OTG_FS)</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="comment">/* Private types -------------------------------------------------------------*/</span>
<a name="l00073"></a>00073 <span class="comment">/* Private variables ---------------------------------------------------------*/</span>
<a name="l00074"></a>00074 <span class="comment">/* Private constants ---------------------------------------------------------*/</span>
<a name="l00075"></a>00075 <span class="comment">/* Private macros ------------------------------------------------------------*/</span><span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">/** @defgroup PCD_Private_Macros PCD Private Macros</span>
<a name="l00077"></a>00077 <span class="comment">  * @{</span>
<a name="l00078"></a>00078 <span class="comment">  */</span>
<a name="l00079"></a><a class="code" href="group/group__PCD__Private__Macros.html#gabef53a343b8d79c8b8edb311685b82ad">00079</a> <span class="preprocessor">#define PCD_MIN(a, b)  (((a) &lt; (b)) ? (a) : (b))</span>
<a name="l00080"></a><a class="code" href="group/group__PCD__Private__Macros.html#ga170b49fd9879d3746f7c8461daa3a831">00080</a> <span class="preprocessor"></span><span class="preprocessor">#define PCD_MAX(a, b)  (((a) &gt; (b)) ? (a) : (b))</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l00082"></a>00082 <span class="comment">  * @}</span>
<a name="l00083"></a>00083 <span class="comment">  */</span>
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/* Private functions prototypes ----------------------------------------------*/</span><span class="comment"></span>
<a name="l00086"></a>00086 <span class="comment">/** @defgroup PCD_Private_Functions PCD Private Functions</span>
<a name="l00087"></a>00087 <span class="comment">  * @{</span>
<a name="l00088"></a>00088 <span class="comment">  */</span>
<a name="l00089"></a>00089 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span><span class="keyword">static</span> HAL_StatusTypeDef PCD_WriteEmptyTxFifo(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum);
<a name="l00091"></a>00091 <span class="keyword">static</span> HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum);
<a name="l00092"></a>00092 <span class="keyword">static</span> HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum);
<a name="l00093"></a>00093 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="preprocessor">#if defined (USB)</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span><span class="keyword">static</span> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Private__Functions.html#ga3420898814fa6df814196c597d833007" title="This function handles PCD Endpoint interrupt request.">PCD_EP_ISR_Handler</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd);
<a name="l00097"></a>00097 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l00098"></a>00098 <span class="comment">/**</span>
<a name="l00099"></a>00099 <span class="comment">  * @}</span>
<a name="l00100"></a>00100 <span class="comment">  */</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">/* Exported functions --------------------------------------------------------*/</span><span class="comment"></span>
<a name="l00103"></a>00103 <span class="comment">/** @defgroup PCD_Exported_Functions PCD Exported Functions</span>
<a name="l00104"></a>00104 <span class="comment">  * @{</span>
<a name="l00105"></a>00105 <span class="comment">  */</span>
<a name="l00106"></a>00106 <span class="comment"></span>
<a name="l00107"></a>00107 <span class="comment">/** @defgroup PCD_Exported_Functions_Group1 Initialization and de-initialization functions</span>
<a name="l00108"></a>00108 <span class="comment"> *  @brief    Initialization and Configuration functions</span>
<a name="l00109"></a>00109 <span class="comment"> *</span>
<a name="l00110"></a>00110 <span class="comment">@verbatim</span>
<a name="l00111"></a>00111 <span class="comment"> ===============================================================================</span>
<a name="l00112"></a>00112 <span class="comment">            ##### Initialization and de-initialization functions #####</span>
<a name="l00113"></a>00113 <span class="comment"> ===============================================================================</span>
<a name="l00114"></a>00114 <span class="comment">    [..]  This section provides functions allowing to:</span>
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">@endverbatim</span>
<a name="l00117"></a>00117 <span class="comment">  * @{</span>
<a name="l00118"></a>00118 <span class="comment">  */</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment">/**</span>
<a name="l00121"></a>00121 <span class="comment">  * @brief  Initializes the PCD according to the specified</span>
<a name="l00122"></a>00122 <span class="comment">  *         parameters in the PCD_InitTypeDef and initialize the associated handle.</span>
<a name="l00123"></a>00123 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00124"></a>00124 <span class="comment">  * @retval HAL status</span>
<a name="l00125"></a>00125 <span class="comment">  */</span>
<a name="l00126"></a><a class="code" href="group/group__PCD__Exported__Functions__Group1.html#gae9ae02615c7a4badf2357e392ec66cd9">00126</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#gae9ae02615c7a4badf2357e392ec66cd9" title="Initializes the PCD according to the specified parameters in the PCD_InitTypeDef and initialize the a...">HAL_PCD_Init</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00127"></a>00127 {
<a name="l00128"></a>00128 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>  USB_OTG_GlobalTypeDef *USBx;
<a name="l00130"></a>00130 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l00131"></a>00131   uint8_t i;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133   <span class="comment">/* Check the PCD handle allocation */</span>
<a name="l00134"></a>00134   <span class="keywordflow">if</span> (hpcd == NULL)
<a name="l00135"></a>00135   {
<a name="l00136"></a>00136     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00137"></a>00137   }
<a name="l00138"></a>00138 
<a name="l00139"></a>00139   <span class="comment">/* Check the parameters */</span>
<a name="l00140"></a>00140   <a class="code" href="stm32f1xx__hal__conf_8h.html#a631dea7b230e600555f979c62af1de21" title="Include module&#39;s header file.">assert_param</a>(IS_PCD_ALL_INSTANCE(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>));
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span>  USBx = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>;
<a name="l00144"></a>00144 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l00145"></a>00145 
<a name="l00146"></a>00146   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96aae4b1fe80cbc5d95ef8df608ebebbe81">HAL_PCD_STATE_RESET</a>)
<a name="l00147"></a>00147   {
<a name="l00148"></a>00148     <span class="comment">/* Allocate lock resource and initialize it */</span>
<a name="l00149"></a>00149     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a836e3913271729600785e1d0cf5521bd">Lock</a> = HAL_UNLOCKED;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>    hpcd-&gt;SOFCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e" title="USB Start Of Frame callback.">HAL_PCD_SOFCallback</a>;
<a name="l00153"></a>00153     hpcd-&gt;SetupStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d" title="Setup stage callback.">HAL_PCD_SetupStageCallback</a>;
<a name="l00154"></a>00154     hpcd-&gt;ResetCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b" title="USB Reset callback.">HAL_PCD_ResetCallback</a>;
<a name="l00155"></a>00155     hpcd-&gt;SuspendCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428" title="Suspend event callback.">HAL_PCD_SuspendCallback</a>;
<a name="l00156"></a>00156     hpcd-&gt;ResumeCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1" title="Resume event callback.">HAL_PCD_ResumeCallback</a>;
<a name="l00157"></a>00157     hpcd-&gt;ConnectCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0c449541523759cf62be9c9d47540c5d" title="Connection event callback.">HAL_PCD_ConnectCallback</a>;
<a name="l00158"></a>00158     hpcd-&gt;DisconnectCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga25f930b5fe696224f8e71dacf5f324b4" title="Disconnection event callback.">HAL_PCD_DisconnectCallback</a>;
<a name="l00159"></a>00159     hpcd-&gt;DataOutStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>;
<a name="l00160"></a>00160     hpcd-&gt;DataInStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>;
<a name="l00161"></a>00161     hpcd-&gt;ISOOUTIncompleteCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga4274f129d782f0a3c9a10b5bbe022cd4" title="Incomplete ISO OUT callback.">HAL_PCD_ISOOUTIncompleteCallback</a>;
<a name="l00162"></a>00162     hpcd-&gt;ISOINIncompleteCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga8f4041d553ef2fb326c6e483797f99a8" title="Incomplete ISO IN callback.">HAL_PCD_ISOINIncompleteCallback</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keywordflow">if</span> (hpcd-&gt;MspInitCallback == NULL)
<a name="l00165"></a>00165     {
<a name="l00166"></a>00166       hpcd-&gt;MspInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad" title="Initializes the PCD MSP.">HAL_PCD_MspInit</a>;
<a name="l00167"></a>00167     }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="comment">/* Init the low level hardware */</span>
<a name="l00170"></a>00170     hpcd-&gt;MspInitCallback(hpcd);
<a name="l00171"></a>00171 <span class="preprocessor">#else</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>    <span class="comment">/* Init the low level hardware : GPIO, CLOCK, NVIC... */</span>
<a name="l00173"></a>00173     <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad" title="Initializes the PCD MSP.">HAL_PCD_MspInit</a>(hpcd);
<a name="l00174"></a>00174 <span class="preprocessor">#endif </span><span class="comment">/* (USE_HAL_PCD_REGISTER_CALLBACKS) */</span>
<a name="l00175"></a>00175   }
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a22ef1e90acb6dba395c8a48d6979997f">HAL_PCD_STATE_BUSY</a>;
<a name="l00178"></a>00178 
<a name="l00179"></a>00179 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l00180"></a>00180 <span class="preprocessor"></span>  <span class="comment">/* Disable DMA mode for FS instance */</span>
<a name="l00181"></a>00181   <span class="keywordflow">if</span> ((USBx-&gt;CID &amp; (0x1U &lt;&lt; 8)) == 0U)
<a name="l00182"></a>00182   {
<a name="l00183"></a>00183     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dma_enable = 0U;
<a name="l00184"></a>00184   }
<a name="l00185"></a>00185 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="comment">/* Disable the Interrupts */</span>
<a name="l00188"></a>00188   <a class="code" href="group/group__PCD__Exported__Macros.html#ga71786c2c6765e270f25c21a85ac3fa77">__HAL_PCD_DISABLE</a>(hpcd);
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">/*Init the Core (common init.) */</span>
<a name="l00191"></a>00191   <span class="keywordflow">if</span> (USB_CoreInit(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>) != HAL_OK)
<a name="l00192"></a>00192   {
<a name="l00193"></a>00193     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a1fffd6147f369822689c6adf3155f2e7">HAL_PCD_STATE_ERROR</a>;
<a name="l00194"></a>00194     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="comment">/* Force Device Mode*/</span>
<a name="l00198"></a>00198   (void)USB_SetCurrentMode(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, USB_DEVICE_MODE);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200   <span class="comment">/* Init endpoints structures */</span>
<a name="l00201"></a>00201   <span class="keywordflow">for</span> (i = 0U; i &lt; hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dev_endpoints; i++)
<a name="l00202"></a>00202   {
<a name="l00203"></a>00203     <span class="comment">/* Init ep structure */</span>
<a name="l00204"></a>00204     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].is_in = 1U;
<a name="l00205"></a>00205     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].num = i;
<a name="l00206"></a>00206     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].tx_fifo_num = i;
<a name="l00207"></a>00207     <span class="comment">/* Control until ep is activated */</span>
<a name="l00208"></a>00208     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].type = EP_TYPE_CTRL;
<a name="l00209"></a>00209     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].maxpacket = 0U;
<a name="l00210"></a>00210     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].xfer_buff = 0U;
<a name="l00211"></a>00211     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[i].xfer_len = 0U;
<a name="l00212"></a>00212   }
<a name="l00213"></a>00213 
<a name="l00214"></a>00214   <span class="keywordflow">for</span> (i = 0U; i &lt; hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dev_endpoints; i++)
<a name="l00215"></a>00215   {
<a name="l00216"></a>00216     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].is_in = 0U;
<a name="l00217"></a>00217     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].num = i;
<a name="l00218"></a>00218     <span class="comment">/* Control until ep is activated */</span>
<a name="l00219"></a>00219     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].type = EP_TYPE_CTRL;
<a name="l00220"></a>00220     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].maxpacket = 0U;
<a name="l00221"></a>00221     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].xfer_buff = 0U;
<a name="l00222"></a>00222     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[i].xfer_len = 0U;
<a name="l00223"></a>00223   }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225   <span class="comment">/* Init Device */</span>
<a name="l00226"></a>00226   <span class="keywordflow">if</span> (USB_DevInit(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>) != HAL_OK)
<a name="l00227"></a>00227   {
<a name="l00228"></a>00228     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a1fffd6147f369822689c6adf3155f2e7">HAL_PCD_STATE_ERROR</a>;
<a name="l00229"></a>00229     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00230"></a>00230   }
<a name="l00231"></a>00231 
<a name="l00232"></a>00232   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a795a07e094bc7bc5a4dc3e149d7a33c7">USB_Address</a> = 0U;
<a name="l00233"></a>00233   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>;
<a name="l00234"></a>00234   (void)USB_DevDisconnect(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l00235"></a>00235 
<a name="l00236"></a>00236   <span class="keywordflow">return</span> HAL_OK;
<a name="l00237"></a>00237 }
<a name="l00238"></a>00238 <span class="comment"></span>
<a name="l00239"></a>00239 <span class="comment">/**</span>
<a name="l00240"></a>00240 <span class="comment">  * @brief  DeInitializes the PCD peripheral.</span>
<a name="l00241"></a>00241 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00242"></a>00242 <span class="comment">  * @retval HAL status</span>
<a name="l00243"></a>00243 <span class="comment">  */</span>
<a name="l00244"></a><a class="code" href="group/group__PCD__Exported__Functions__Group1.html#gaf16d6b4eab71321e49998f13d00e38f0">00244</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#gaf16d6b4eab71321e49998f13d00e38f0" title="DeInitializes the PCD peripheral.">HAL_PCD_DeInit</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00245"></a>00245 {
<a name="l00246"></a>00246   <span class="comment">/* Check the PCD handle allocation */</span>
<a name="l00247"></a>00247   <span class="keywordflow">if</span> (hpcd == NULL)
<a name="l00248"></a>00248   {
<a name="l00249"></a>00249     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00250"></a>00250   }
<a name="l00251"></a>00251 
<a name="l00252"></a>00252   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a22ef1e90acb6dba395c8a48d6979997f">HAL_PCD_STATE_BUSY</a>;
<a name="l00253"></a>00253 
<a name="l00254"></a>00254   <span class="comment">/* Stop Device */</span>
<a name="l00255"></a>00255   (void)<a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gad2e6055aea6458c0aec7df9c8ab7abab" title="Stop the USB device.">HAL_PCD_Stop</a>(hpcd);
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (hpcd-&gt;MspDeInitCallback == NULL)
<a name="l00259"></a>00259   {
<a name="l00260"></a>00260     hpcd-&gt;MspDeInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47" title="DeInitializes PCD MSP.">HAL_PCD_MspDeInit</a>; <span class="comment">/* Legacy weak MspDeInit  */</span>
<a name="l00261"></a>00261   }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263   <span class="comment">/* DeInit the low level hardware */</span>
<a name="l00264"></a>00264   hpcd-&gt;MspDeInitCallback(hpcd);
<a name="l00265"></a>00265 <span class="preprocessor">#else</span>
<a name="l00266"></a>00266 <span class="preprocessor"></span>  <span class="comment">/* DeInit the low level hardware: CLOCK, NVIC.*/</span>
<a name="l00267"></a>00267   <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47" title="DeInitializes PCD MSP.">HAL_PCD_MspDeInit</a>(hpcd);
<a name="l00268"></a>00268 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> = <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96aae4b1fe80cbc5d95ef8df608ebebbe81">HAL_PCD_STATE_RESET</a>;
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keywordflow">return</span> HAL_OK;
<a name="l00273"></a>00273 }
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="comment">/**</span>
<a name="l00276"></a>00276 <span class="comment">  * @brief  Initializes the PCD MSP.</span>
<a name="l00277"></a>00277 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00278"></a>00278 <span class="comment">  * @retval None</span>
<a name="l00279"></a>00279 <span class="comment">  */</span>
<a name="l00280"></a><a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad">00280</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad" title="Initializes the PCD MSP.">HAL_PCD_MspInit</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00281"></a>00281 {
<a name="l00282"></a>00282   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l00283"></a>00283   UNUSED(hpcd);
<a name="l00284"></a>00284 
<a name="l00285"></a>00285   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l00286"></a>00286 <span class="comment">            the HAL_PCD_MspInit could be implemented in the user file</span>
<a name="l00287"></a>00287 <span class="comment">   */</span>
<a name="l00288"></a>00288 }
<a name="l00289"></a>00289 <span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">/**</span>
<a name="l00291"></a>00291 <span class="comment">  * @brief  DeInitializes PCD MSP.</span>
<a name="l00292"></a>00292 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00293"></a>00293 <span class="comment">  * @retval None</span>
<a name="l00294"></a>00294 <span class="comment">  */</span>
<a name="l00295"></a><a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47">00295</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47" title="DeInitializes PCD MSP.">HAL_PCD_MspDeInit</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00296"></a>00296 {
<a name="l00297"></a>00297   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l00298"></a>00298   UNUSED(hpcd);
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l00301"></a>00301 <span class="comment">            the HAL_PCD_MspDeInit could be implemented in the user file</span>
<a name="l00302"></a>00302 <span class="comment">   */</span>
<a name="l00303"></a>00303 }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l00306"></a>00306 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l00307"></a>00307 <span class="comment">  * @brief  Register a User USB PCD Callback</span>
<a name="l00308"></a>00308 <span class="comment">  *         To be used instead of the weak predefined callback</span>
<a name="l00309"></a>00309 <span class="comment">  * @param  hpcd USB PCD handle</span>
<a name="l00310"></a>00310 <span class="comment">  * @param  CallbackID ID of the callback to be registered</span>
<a name="l00311"></a>00311 <span class="comment">  *         This parameter can be one of the following values:</span>
<a name="l00312"></a>00312 <span class="comment">  *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID</span>
<a name="l00313"></a>00313 <span class="comment">  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID</span>
<a name="l00314"></a>00314 <span class="comment">  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID</span>
<a name="l00315"></a>00315 <span class="comment">  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID</span>
<a name="l00316"></a>00316 <span class="comment">  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID</span>
<a name="l00317"></a>00317 <span class="comment">  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID</span>
<a name="l00318"></a>00318 <span class="comment">  *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID</span>
<a name="l00319"></a>00319 <span class="comment">  *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID</span>
<a name="l00320"></a>00320 <span class="comment">  *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID</span>
<a name="l00321"></a>00321 <span class="comment">  * @param  pCallback pointer to the Callback function</span>
<a name="l00322"></a>00322 <span class="comment">  * @retval HAL status</span>
<a name="l00323"></a>00323 <span class="comment">  */</span>
<a name="l00324"></a>00324 HAL_StatusTypeDef HAL_PCD_RegisterCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, HAL_PCD_CallbackIDTypeDef CallbackID, pPCD_CallbackTypeDef pCallback)
<a name="l00325"></a>00325 {
<a name="l00326"></a>00326   HAL_StatusTypeDef status = HAL_OK;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="keywordflow">if</span> (pCallback == NULL)
<a name="l00329"></a>00329   {
<a name="l00330"></a>00330     <span class="comment">/* Update the error code */</span>
<a name="l00331"></a>00331     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00332"></a>00332     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00333"></a>00333   }
<a name="l00334"></a>00334   <span class="comment">/* Process locked */</span>
<a name="l00335"></a>00335   __HAL_LOCK(hpcd);
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00338"></a>00338   {
<a name="l00339"></a>00339     <span class="keywordflow">switch</span> (CallbackID)
<a name="l00340"></a>00340     {
<a name="l00341"></a>00341       <span class="keywordflow">case</span> HAL_PCD_SOF_CB_ID :
<a name="l00342"></a>00342         hpcd-&gt;SOFCallback = pCallback;
<a name="l00343"></a>00343         <span class="keywordflow">break</span>;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345       <span class="keywordflow">case</span> HAL_PCD_SETUPSTAGE_CB_ID :
<a name="l00346"></a>00346         hpcd-&gt;SetupStageCallback = pCallback;
<a name="l00347"></a>00347         <span class="keywordflow">break</span>;
<a name="l00348"></a>00348 
<a name="l00349"></a>00349       <span class="keywordflow">case</span> HAL_PCD_RESET_CB_ID :
<a name="l00350"></a>00350         hpcd-&gt;ResetCallback = pCallback;
<a name="l00351"></a>00351         <span class="keywordflow">break</span>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353       <span class="keywordflow">case</span> HAL_PCD_SUSPEND_CB_ID :
<a name="l00354"></a>00354         hpcd-&gt;SuspendCallback = pCallback;
<a name="l00355"></a>00355         <span class="keywordflow">break</span>;
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       <span class="keywordflow">case</span> HAL_PCD_RESUME_CB_ID :
<a name="l00358"></a>00358         hpcd-&gt;ResumeCallback = pCallback;
<a name="l00359"></a>00359         <span class="keywordflow">break</span>;
<a name="l00360"></a>00360 
<a name="l00361"></a>00361       <span class="keywordflow">case</span> HAL_PCD_CONNECT_CB_ID :
<a name="l00362"></a>00362         hpcd-&gt;ConnectCallback = pCallback;
<a name="l00363"></a>00363         <span class="keywordflow">break</span>;
<a name="l00364"></a>00364 
<a name="l00365"></a>00365       <span class="keywordflow">case</span> HAL_PCD_DISCONNECT_CB_ID :
<a name="l00366"></a>00366         hpcd-&gt;DisconnectCallback = pCallback;
<a name="l00367"></a>00367         <span class="keywordflow">break</span>;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369       <span class="keywordflow">case</span> HAL_PCD_MSPINIT_CB_ID :
<a name="l00370"></a>00370         hpcd-&gt;MspInitCallback = pCallback;
<a name="l00371"></a>00371         <span class="keywordflow">break</span>;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373       <span class="keywordflow">case</span> HAL_PCD_MSPDEINIT_CB_ID :
<a name="l00374"></a>00374         hpcd-&gt;MspDeInitCallback = pCallback;
<a name="l00375"></a>00375         <span class="keywordflow">break</span>;
<a name="l00376"></a>00376 
<a name="l00377"></a>00377       <span class="keywordflow">default</span> :
<a name="l00378"></a>00378         <span class="comment">/* Update the error code */</span>
<a name="l00379"></a>00379         hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00380"></a>00380         <span class="comment">/* Return error status */</span>
<a name="l00381"></a>00381         status =  HAL_ERROR;
<a name="l00382"></a>00382         <span class="keywordflow">break</span>;
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384   }
<a name="l00385"></a>00385   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96aae4b1fe80cbc5d95ef8df608ebebbe81">HAL_PCD_STATE_RESET</a>)
<a name="l00386"></a>00386   {
<a name="l00387"></a>00387     <span class="keywordflow">switch</span> (CallbackID)
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389       <span class="keywordflow">case</span> HAL_PCD_MSPINIT_CB_ID :
<a name="l00390"></a>00390         hpcd-&gt;MspInitCallback = pCallback;
<a name="l00391"></a>00391         <span class="keywordflow">break</span>;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       <span class="keywordflow">case</span> HAL_PCD_MSPDEINIT_CB_ID :
<a name="l00394"></a>00394         hpcd-&gt;MspDeInitCallback = pCallback;
<a name="l00395"></a>00395         <span class="keywordflow">break</span>;
<a name="l00396"></a>00396 
<a name="l00397"></a>00397       <span class="keywordflow">default</span> :
<a name="l00398"></a>00398         <span class="comment">/* Update the error code */</span>
<a name="l00399"></a>00399         hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00400"></a>00400         <span class="comment">/* Return error status */</span>
<a name="l00401"></a>00401         status =  HAL_ERROR;
<a name="l00402"></a>00402         <span class="keywordflow">break</span>;
<a name="l00403"></a>00403     }
<a name="l00404"></a>00404   }
<a name="l00405"></a>00405   <span class="keywordflow">else</span>
<a name="l00406"></a>00406   {
<a name="l00407"></a>00407     <span class="comment">/* Update the error code */</span>
<a name="l00408"></a>00408     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00409"></a>00409     <span class="comment">/* Return error status */</span>
<a name="l00410"></a>00410     status =  HAL_ERROR;
<a name="l00411"></a>00411   }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413   <span class="comment">/* Release Lock */</span>
<a name="l00414"></a>00414   __HAL_UNLOCK(hpcd);
<a name="l00415"></a>00415   <span class="keywordflow">return</span> status;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417 <span class="comment"></span>
<a name="l00418"></a>00418 <span class="comment">/**</span>
<a name="l00419"></a>00419 <span class="comment">  * @brief  Unregister an USB PCD Callback</span>
<a name="l00420"></a>00420 <span class="comment">  *         USB PCD callabck is redirected to the weak predefined callback</span>
<a name="l00421"></a>00421 <span class="comment">  * @param  hpcd USB PCD handle</span>
<a name="l00422"></a>00422 <span class="comment">  * @param  CallbackID ID of the callback to be unregistered</span>
<a name="l00423"></a>00423 <span class="comment">  *         This parameter can be one of the following values:</span>
<a name="l00424"></a>00424 <span class="comment">  *          @arg @ref HAL_PCD_SOF_CB_ID USB PCD SOF callback ID</span>
<a name="l00425"></a>00425 <span class="comment">  *          @arg @ref HAL_PCD_SETUPSTAGE_CB_ID USB PCD Setup callback ID</span>
<a name="l00426"></a>00426 <span class="comment">  *          @arg @ref HAL_PCD_RESET_CB_ID USB PCD Reset callback ID</span>
<a name="l00427"></a>00427 <span class="comment">  *          @arg @ref HAL_PCD_SUSPEND_CB_ID USB PCD Suspend callback ID</span>
<a name="l00428"></a>00428 <span class="comment">  *          @arg @ref HAL_PCD_RESUME_CB_ID USB PCD Resume callback ID</span>
<a name="l00429"></a>00429 <span class="comment">  *          @arg @ref HAL_PCD_CONNECT_CB_ID USB PCD Connect callback ID</span>
<a name="l00430"></a>00430 <span class="comment">  *          @arg @ref HAL_PCD_DISCONNECT_CB_ID OTG PCD Disconnect callback ID</span>
<a name="l00431"></a>00431 <span class="comment">  *          @arg @ref HAL_PCD_MSPINIT_CB_ID MspDeInit callback ID</span>
<a name="l00432"></a>00432 <span class="comment">  *          @arg @ref HAL_PCD_MSPDEINIT_CB_ID MspDeInit callback ID</span>
<a name="l00433"></a>00433 <span class="comment">  * @retval HAL status</span>
<a name="l00434"></a>00434 <span class="comment">  */</span>
<a name="l00435"></a>00435 HAL_StatusTypeDef HAL_PCD_UnRegisterCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, HAL_PCD_CallbackIDTypeDef CallbackID)
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437   HAL_StatusTypeDef status = HAL_OK;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439   <span class="comment">/* Process locked */</span>
<a name="l00440"></a>00440   __HAL_LOCK(hpcd);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442   <span class="comment">/* Setup Legacy weak Callbacks  */</span>
<a name="l00443"></a>00443   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00444"></a>00444   {
<a name="l00445"></a>00445     <span class="keywordflow">switch</span> (CallbackID)
<a name="l00446"></a>00446     {
<a name="l00447"></a>00447       <span class="keywordflow">case</span> HAL_PCD_SOF_CB_ID :
<a name="l00448"></a>00448         hpcd-&gt;SOFCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e" title="USB Start Of Frame callback.">HAL_PCD_SOFCallback</a>;
<a name="l00449"></a>00449         <span class="keywordflow">break</span>;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451       <span class="keywordflow">case</span> HAL_PCD_SETUPSTAGE_CB_ID :
<a name="l00452"></a>00452         hpcd-&gt;SetupStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d" title="Setup stage callback.">HAL_PCD_SetupStageCallback</a>;
<a name="l00453"></a>00453         <span class="keywordflow">break</span>;
<a name="l00454"></a>00454 
<a name="l00455"></a>00455       <span class="keywordflow">case</span> HAL_PCD_RESET_CB_ID :
<a name="l00456"></a>00456         hpcd-&gt;ResetCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b" title="USB Reset callback.">HAL_PCD_ResetCallback</a>;
<a name="l00457"></a>00457         <span class="keywordflow">break</span>;
<a name="l00458"></a>00458 
<a name="l00459"></a>00459       <span class="keywordflow">case</span> HAL_PCD_SUSPEND_CB_ID :
<a name="l00460"></a>00460         hpcd-&gt;SuspendCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428" title="Suspend event callback.">HAL_PCD_SuspendCallback</a>;
<a name="l00461"></a>00461         <span class="keywordflow">break</span>;
<a name="l00462"></a>00462 
<a name="l00463"></a>00463       <span class="keywordflow">case</span> HAL_PCD_RESUME_CB_ID :
<a name="l00464"></a>00464         hpcd-&gt;ResumeCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1" title="Resume event callback.">HAL_PCD_ResumeCallback</a>;
<a name="l00465"></a>00465         <span class="keywordflow">break</span>;
<a name="l00466"></a>00466 
<a name="l00467"></a>00467       <span class="keywordflow">case</span> HAL_PCD_CONNECT_CB_ID :
<a name="l00468"></a>00468         hpcd-&gt;ConnectCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0c449541523759cf62be9c9d47540c5d" title="Connection event callback.">HAL_PCD_ConnectCallback</a>;
<a name="l00469"></a>00469         <span class="keywordflow">break</span>;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471       <span class="keywordflow">case</span> HAL_PCD_DISCONNECT_CB_ID :
<a name="l00472"></a>00472         hpcd-&gt;DisconnectCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga25f930b5fe696224f8e71dacf5f324b4" title="Disconnection event callback.">HAL_PCD_DisconnectCallback</a>;
<a name="l00473"></a>00473         <span class="keywordflow">break</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       <span class="keywordflow">case</span> HAL_PCD_MSPINIT_CB_ID :
<a name="l00476"></a>00476         hpcd-&gt;MspInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad" title="Initializes the PCD MSP.">HAL_PCD_MspInit</a>;
<a name="l00477"></a>00477         <span class="keywordflow">break</span>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479       <span class="keywordflow">case</span> HAL_PCD_MSPDEINIT_CB_ID :
<a name="l00480"></a>00480         hpcd-&gt;MspDeInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47" title="DeInitializes PCD MSP.">HAL_PCD_MspDeInit</a>;
<a name="l00481"></a>00481         <span class="keywordflow">break</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="keywordflow">default</span> :
<a name="l00484"></a>00484         <span class="comment">/* Update the error code */</span>
<a name="l00485"></a>00485         hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487         <span class="comment">/* Return error status */</span>
<a name="l00488"></a>00488         status =  HAL_ERROR;
<a name="l00489"></a>00489         <span class="keywordflow">break</span>;
<a name="l00490"></a>00490     }
<a name="l00491"></a>00491   }
<a name="l00492"></a>00492   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96aae4b1fe80cbc5d95ef8df608ebebbe81">HAL_PCD_STATE_RESET</a>)
<a name="l00493"></a>00493   {
<a name="l00494"></a>00494     <span class="keywordflow">switch</span> (CallbackID)
<a name="l00495"></a>00495     {
<a name="l00496"></a>00496       <span class="keywordflow">case</span> HAL_PCD_MSPINIT_CB_ID :
<a name="l00497"></a>00497         hpcd-&gt;MspInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga73af972b44ba2890202363cd8b197dad" title="Initializes the PCD MSP.">HAL_PCD_MspInit</a>;
<a name="l00498"></a>00498         <span class="keywordflow">break</span>;
<a name="l00499"></a>00499 
<a name="l00500"></a>00500       <span class="keywordflow">case</span> HAL_PCD_MSPDEINIT_CB_ID :
<a name="l00501"></a>00501         hpcd-&gt;MspDeInitCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group1.html#ga8194c593b1db635b225c4b6294f31e47" title="DeInitializes PCD MSP.">HAL_PCD_MspDeInit</a>;
<a name="l00502"></a>00502         <span class="keywordflow">break</span>;
<a name="l00503"></a>00503 
<a name="l00504"></a>00504       <span class="keywordflow">default</span> :
<a name="l00505"></a>00505         <span class="comment">/* Update the error code */</span>
<a name="l00506"></a>00506         hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508         <span class="comment">/* Return error status */</span>
<a name="l00509"></a>00509         status =  HAL_ERROR;
<a name="l00510"></a>00510         <span class="keywordflow">break</span>;
<a name="l00511"></a>00511     }
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513   <span class="keywordflow">else</span>
<a name="l00514"></a>00514   {
<a name="l00515"></a>00515     <span class="comment">/* Update the error code */</span>
<a name="l00516"></a>00516     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     <span class="comment">/* Return error status */</span>
<a name="l00519"></a>00519     status =  HAL_ERROR;
<a name="l00520"></a>00520   }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522   <span class="comment">/* Release Lock */</span>
<a name="l00523"></a>00523   __HAL_UNLOCK(hpcd);
<a name="l00524"></a>00524   <span class="keywordflow">return</span> status;
<a name="l00525"></a>00525 }
<a name="l00526"></a>00526 <span class="comment"></span>
<a name="l00527"></a>00527 <span class="comment">/**</span>
<a name="l00528"></a>00528 <span class="comment">  * @brief  Register USB PCD Data OUT Stage Callback</span>
<a name="l00529"></a>00529 <span class="comment">  *         To be used instead of the weak HAL_PCD_DataOutStageCallback() predefined callback</span>
<a name="l00530"></a>00530 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00531"></a>00531 <span class="comment">  * @param  pCallback pointer to the USB PCD Data OUT Stage Callback function</span>
<a name="l00532"></a>00532 <span class="comment">  * @retval HAL status</span>
<a name="l00533"></a>00533 <span class="comment">  */</span>
<a name="l00534"></a>00534 HAL_StatusTypeDef HAL_PCD_RegisterDataOutStageCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, pPCD_DataOutStageCallbackTypeDef pCallback)
<a name="l00535"></a>00535 {
<a name="l00536"></a>00536   HAL_StatusTypeDef status = HAL_OK;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="keywordflow">if</span> (pCallback == NULL)
<a name="l00539"></a>00539   {
<a name="l00540"></a>00540     <span class="comment">/* Update the error code */</span>
<a name="l00541"></a>00541     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00544"></a>00544   }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546   <span class="comment">/* Process locked */</span>
<a name="l00547"></a>00547   __HAL_LOCK(hpcd);
<a name="l00548"></a>00548 
<a name="l00549"></a>00549   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00550"></a>00550   {
<a name="l00551"></a>00551     hpcd-&gt;DataOutStageCallback = pCallback;
<a name="l00552"></a>00552   }
<a name="l00553"></a>00553   <span class="keywordflow">else</span>
<a name="l00554"></a>00554   {
<a name="l00555"></a>00555     <span class="comment">/* Update the error code */</span>
<a name="l00556"></a>00556     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="comment">/* Return error status */</span>
<a name="l00559"></a>00559     status =  HAL_ERROR;
<a name="l00560"></a>00560   }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562   <span class="comment">/* Release Lock */</span>
<a name="l00563"></a>00563   __HAL_UNLOCK(hpcd);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">return</span> status;
<a name="l00566"></a>00566 }
<a name="l00567"></a>00567 <span class="comment"></span>
<a name="l00568"></a>00568 <span class="comment">/**</span>
<a name="l00569"></a>00569 <span class="comment">  * @brief  UnRegister the USB PCD Data OUT Stage Callback</span>
<a name="l00570"></a>00570 <span class="comment">  *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataOutStageCallback() predefined callback</span>
<a name="l00571"></a>00571 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00572"></a>00572 <span class="comment">  * @retval HAL status</span>
<a name="l00573"></a>00573 <span class="comment">  */</span>
<a name="l00574"></a>00574 HAL_StatusTypeDef HAL_PCD_UnRegisterDataOutStageCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576   HAL_StatusTypeDef status = HAL_OK;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   <span class="comment">/* Process locked */</span>
<a name="l00579"></a>00579   __HAL_LOCK(hpcd);
<a name="l00580"></a>00580 
<a name="l00581"></a>00581   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00582"></a>00582   {
<a name="l00583"></a>00583     hpcd-&gt;DataOutStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>; <span class="comment">/* Legacy weak DataOutStageCallback  */</span>
<a name="l00584"></a>00584   }
<a name="l00585"></a>00585   <span class="keywordflow">else</span>
<a name="l00586"></a>00586   {
<a name="l00587"></a>00587     <span class="comment">/* Update the error code */</span>
<a name="l00588"></a>00588     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590     <span class="comment">/* Return error status */</span>
<a name="l00591"></a>00591     status =  HAL_ERROR;
<a name="l00592"></a>00592   }
<a name="l00593"></a>00593 
<a name="l00594"></a>00594   <span class="comment">/* Release Lock */</span>
<a name="l00595"></a>00595   __HAL_UNLOCK(hpcd);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597   <span class="keywordflow">return</span> status;
<a name="l00598"></a>00598 }
<a name="l00599"></a>00599 <span class="comment"></span>
<a name="l00600"></a>00600 <span class="comment">/**</span>
<a name="l00601"></a>00601 <span class="comment">  * @brief  Register USB PCD Data IN Stage Callback</span>
<a name="l00602"></a>00602 <span class="comment">  *         To be used instead of the weak HAL_PCD_DataInStageCallback() predefined callback</span>
<a name="l00603"></a>00603 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00604"></a>00604 <span class="comment">  * @param  pCallback pointer to the USB PCD Data IN Stage Callback function</span>
<a name="l00605"></a>00605 <span class="comment">  * @retval HAL status</span>
<a name="l00606"></a>00606 <span class="comment">  */</span>
<a name="l00607"></a>00607 HAL_StatusTypeDef HAL_PCD_RegisterDataInStageCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, pPCD_DataInStageCallbackTypeDef pCallback)
<a name="l00608"></a>00608 {
<a name="l00609"></a>00609   HAL_StatusTypeDef status = HAL_OK;
<a name="l00610"></a>00610 
<a name="l00611"></a>00611   <span class="keywordflow">if</span> (pCallback == NULL)
<a name="l00612"></a>00612   {
<a name="l00613"></a>00613     <span class="comment">/* Update the error code */</span>
<a name="l00614"></a>00614     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00615"></a>00615 
<a name="l00616"></a>00616     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00617"></a>00617   }
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   <span class="comment">/* Process locked */</span>
<a name="l00620"></a>00620   __HAL_LOCK(hpcd);
<a name="l00621"></a>00621 
<a name="l00622"></a>00622   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00623"></a>00623   {
<a name="l00624"></a>00624     hpcd-&gt;DataInStageCallback = pCallback;
<a name="l00625"></a>00625   }
<a name="l00626"></a>00626   <span class="keywordflow">else</span>
<a name="l00627"></a>00627   {
<a name="l00628"></a>00628     <span class="comment">/* Update the error code */</span>
<a name="l00629"></a>00629     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="comment">/* Return error status */</span>
<a name="l00632"></a>00632     status =  HAL_ERROR;
<a name="l00633"></a>00633   }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   <span class="comment">/* Release Lock */</span>
<a name="l00636"></a>00636   __HAL_UNLOCK(hpcd);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638   <span class="keywordflow">return</span> status;
<a name="l00639"></a>00639 }
<a name="l00640"></a>00640 <span class="comment"></span>
<a name="l00641"></a>00641 <span class="comment">/**</span>
<a name="l00642"></a>00642 <span class="comment">  * @brief  UnRegister the USB PCD Data IN Stage Callback</span>
<a name="l00643"></a>00643 <span class="comment">  *         USB PCD Data OUT Stage Callback is redirected to the weak HAL_PCD_DataInStageCallback() predefined callback</span>
<a name="l00644"></a>00644 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00645"></a>00645 <span class="comment">  * @retval HAL status</span>
<a name="l00646"></a>00646 <span class="comment">  */</span>
<a name="l00647"></a>00647 HAL_StatusTypeDef HAL_PCD_UnRegisterDataInStageCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00648"></a>00648 {
<a name="l00649"></a>00649   HAL_StatusTypeDef status = HAL_OK;
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <span class="comment">/* Process locked */</span>
<a name="l00652"></a>00652   __HAL_LOCK(hpcd);
<a name="l00653"></a>00653 
<a name="l00654"></a>00654   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00655"></a>00655   {
<a name="l00656"></a>00656     hpcd-&gt;DataInStageCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>; <span class="comment">/* Legacy weak DataInStageCallback  */</span>
<a name="l00657"></a>00657   }
<a name="l00658"></a>00658   <span class="keywordflow">else</span>
<a name="l00659"></a>00659   {
<a name="l00660"></a>00660     <span class="comment">/* Update the error code */</span>
<a name="l00661"></a>00661     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="comment">/* Return error status */</span>
<a name="l00664"></a>00664     status =  HAL_ERROR;
<a name="l00665"></a>00665   }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <span class="comment">/* Release Lock */</span>
<a name="l00668"></a>00668   __HAL_UNLOCK(hpcd);
<a name="l00669"></a>00669 
<a name="l00670"></a>00670   <span class="keywordflow">return</span> status;
<a name="l00671"></a>00671 }
<a name="l00672"></a>00672 <span class="comment"></span>
<a name="l00673"></a>00673 <span class="comment">/**</span>
<a name="l00674"></a>00674 <span class="comment">  * @brief  Register USB PCD Iso OUT incomplete Callback</span>
<a name="l00675"></a>00675 <span class="comment">  *         To be used instead of the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback</span>
<a name="l00676"></a>00676 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00677"></a>00677 <span class="comment">  * @param  pCallback pointer to the USB PCD Iso OUT incomplete Callback function</span>
<a name="l00678"></a>00678 <span class="comment">  * @retval HAL status</span>
<a name="l00679"></a>00679 <span class="comment">  */</span>
<a name="l00680"></a>00680 HAL_StatusTypeDef HAL_PCD_RegisterIsoOutIncpltCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, pPCD_IsoOutIncpltCallbackTypeDef pCallback)
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682   HAL_StatusTypeDef status = HAL_OK;
<a name="l00683"></a>00683 
<a name="l00684"></a>00684   <span class="keywordflow">if</span> (pCallback == NULL)
<a name="l00685"></a>00685   {
<a name="l00686"></a>00686     <span class="comment">/* Update the error code */</span>
<a name="l00687"></a>00687     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00690"></a>00690   }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   <span class="comment">/* Process locked */</span>
<a name="l00693"></a>00693   __HAL_LOCK(hpcd);
<a name="l00694"></a>00694 
<a name="l00695"></a>00695   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00696"></a>00696   {
<a name="l00697"></a>00697     hpcd-&gt;ISOOUTIncompleteCallback = pCallback;
<a name="l00698"></a>00698   }
<a name="l00699"></a>00699   <span class="keywordflow">else</span>
<a name="l00700"></a>00700   {
<a name="l00701"></a>00701     <span class="comment">/* Update the error code */</span>
<a name="l00702"></a>00702     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00703"></a>00703 
<a name="l00704"></a>00704     <span class="comment">/* Return error status */</span>
<a name="l00705"></a>00705     status =  HAL_ERROR;
<a name="l00706"></a>00706   }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="comment">/* Release Lock */</span>
<a name="l00709"></a>00709   __HAL_UNLOCK(hpcd);
<a name="l00710"></a>00710 
<a name="l00711"></a>00711   <span class="keywordflow">return</span> status;
<a name="l00712"></a>00712 }
<a name="l00713"></a>00713 <span class="comment"></span>
<a name="l00714"></a>00714 <span class="comment">/**</span>
<a name="l00715"></a>00715 <span class="comment">  * @brief  UnRegister the USB PCD Iso OUT incomplete Callback</span>
<a name="l00716"></a>00716 <span class="comment">  *         USB PCD Iso OUT incomplete Callback is redirected to the weak HAL_PCD_ISOOUTIncompleteCallback() predefined callback</span>
<a name="l00717"></a>00717 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00718"></a>00718 <span class="comment">  * @retval HAL status</span>
<a name="l00719"></a>00719 <span class="comment">  */</span>
<a name="l00720"></a>00720 HAL_StatusTypeDef HAL_PCD_UnRegisterIsoOutIncpltCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722   HAL_StatusTypeDef status = HAL_OK;
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   <span class="comment">/* Process locked */</span>
<a name="l00725"></a>00725   __HAL_LOCK(hpcd);
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     hpcd-&gt;ISOOUTIncompleteCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga4274f129d782f0a3c9a10b5bbe022cd4" title="Incomplete ISO OUT callback.">HAL_PCD_ISOOUTIncompleteCallback</a>; <span class="comment">/* Legacy weak ISOOUTIncompleteCallback  */</span>
<a name="l00730"></a>00730   }
<a name="l00731"></a>00731   <span class="keywordflow">else</span>
<a name="l00732"></a>00732   {
<a name="l00733"></a>00733     <span class="comment">/* Update the error code */</span>
<a name="l00734"></a>00734     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     <span class="comment">/* Return error status */</span>
<a name="l00737"></a>00737     status =  HAL_ERROR;
<a name="l00738"></a>00738   }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740   <span class="comment">/* Release Lock */</span>
<a name="l00741"></a>00741   __HAL_UNLOCK(hpcd);
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   <span class="keywordflow">return</span> status;
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 <span class="comment"></span>
<a name="l00746"></a>00746 <span class="comment">/**</span>
<a name="l00747"></a>00747 <span class="comment">  * @brief  Register USB PCD Iso IN incomplete Callback</span>
<a name="l00748"></a>00748 <span class="comment">  *         To be used instead of the weak HAL_PCD_ISOINIncompleteCallback() predefined callback</span>
<a name="l00749"></a>00749 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00750"></a>00750 <span class="comment">  * @param  pCallback pointer to the USB PCD Iso IN incomplete Callback function</span>
<a name="l00751"></a>00751 <span class="comment">  * @retval HAL status</span>
<a name="l00752"></a>00752 <span class="comment">  */</span>
<a name="l00753"></a>00753 HAL_StatusTypeDef HAL_PCD_RegisterIsoInIncpltCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, pPCD_IsoInIncpltCallbackTypeDef pCallback)
<a name="l00754"></a>00754 {
<a name="l00755"></a>00755   HAL_StatusTypeDef status = HAL_OK;
<a name="l00756"></a>00756 
<a name="l00757"></a>00757   <span class="keywordflow">if</span> (pCallback == NULL)
<a name="l00758"></a>00758   {
<a name="l00759"></a>00759     <span class="comment">/* Update the error code */</span>
<a name="l00760"></a>00760     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00763"></a>00763   }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765   <span class="comment">/* Process locked */</span>
<a name="l00766"></a>00766   __HAL_LOCK(hpcd);
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00769"></a>00769   {
<a name="l00770"></a>00770     hpcd-&gt;ISOINIncompleteCallback = pCallback;
<a name="l00771"></a>00771   }
<a name="l00772"></a>00772   <span class="keywordflow">else</span>
<a name="l00773"></a>00773   {
<a name="l00774"></a>00774     <span class="comment">/* Update the error code */</span>
<a name="l00775"></a>00775     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     <span class="comment">/* Return error status */</span>
<a name="l00778"></a>00778     status =  HAL_ERROR;
<a name="l00779"></a>00779   }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781   <span class="comment">/* Release Lock */</span>
<a name="l00782"></a>00782   __HAL_UNLOCK(hpcd);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784   <span class="keywordflow">return</span> status;
<a name="l00785"></a>00785 }
<a name="l00786"></a>00786 <span class="comment"></span>
<a name="l00787"></a>00787 <span class="comment">/**</span>
<a name="l00788"></a>00788 <span class="comment">  * @brief  UnRegister the USB PCD Iso IN incomplete Callback</span>
<a name="l00789"></a>00789 <span class="comment">  *         USB PCD Iso IN incomplete Callback is redirected to the weak HAL_PCD_ISOINIncompleteCallback() predefined callback</span>
<a name="l00790"></a>00790 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00791"></a>00791 <span class="comment">  * @retval HAL status</span>
<a name="l00792"></a>00792 <span class="comment">  */</span>
<a name="l00793"></a>00793 HAL_StatusTypeDef HAL_PCD_UnRegisterIsoInIncpltCallback(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00794"></a>00794 {
<a name="l00795"></a>00795   HAL_StatusTypeDef status = HAL_OK;
<a name="l00796"></a>00796 
<a name="l00797"></a>00797   <span class="comment">/* Process locked */</span>
<a name="l00798"></a>00798   __HAL_LOCK(hpcd);
<a name="l00799"></a>00799 
<a name="l00800"></a>00800   <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a> == <a class="code" href="group/group__PCD__Exported__Types.html#gga78b8f0aa4eea3865fb695a732b26be96a889f78424bffc6308ebe20dbbafe03ab">HAL_PCD_STATE_READY</a>)
<a name="l00801"></a>00801   {
<a name="l00802"></a>00802     hpcd-&gt;ISOINIncompleteCallback = <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga8f4041d553ef2fb326c6e483797f99a8" title="Incomplete ISO IN callback.">HAL_PCD_ISOINIncompleteCallback</a>; <span class="comment">/* Legacy weak ISOINIncompleteCallback  */</span>
<a name="l00803"></a>00803   }
<a name="l00804"></a>00804   <span class="keywordflow">else</span>
<a name="l00805"></a>00805   {
<a name="l00806"></a>00806     <span class="comment">/* Update the error code */</span>
<a name="l00807"></a>00807     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a03f9fda5f0f305fd8a8aa6765bd81da7">ErrorCode</a> |= HAL_PCD_ERROR_INVALID_CALLBACK;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809     <span class="comment">/* Return error status */</span>
<a name="l00810"></a>00810     status =  HAL_ERROR;
<a name="l00811"></a>00811   }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="comment">/* Release Lock */</span>
<a name="l00814"></a>00814   __HAL_UNLOCK(hpcd);
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="keywordflow">return</span> status;
<a name="l00817"></a>00817 }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l00820"></a>00820 <span class="comment"></span>
<a name="l00821"></a>00821 <span class="comment">/**</span>
<a name="l00822"></a>00822 <span class="comment">  * @}</span>
<a name="l00823"></a>00823 <span class="comment">  */</span>
<a name="l00824"></a>00824 <span class="comment"></span>
<a name="l00825"></a>00825 <span class="comment">/** @defgroup PCD_Exported_Functions_Group2 Input and Output operation functions</span>
<a name="l00826"></a>00826 <span class="comment"> *  @brief   Data transfers functions</span>
<a name="l00827"></a>00827 <span class="comment"> *</span>
<a name="l00828"></a>00828 <span class="comment">@verbatim</span>
<a name="l00829"></a>00829 <span class="comment"> ===============================================================================</span>
<a name="l00830"></a>00830 <span class="comment">                      ##### IO operation functions #####</span>
<a name="l00831"></a>00831 <span class="comment"> ===============================================================================</span>
<a name="l00832"></a>00832 <span class="comment">    [..]</span>
<a name="l00833"></a>00833 <span class="comment">    This subsection provides a set of functions allowing to manage the PCD data</span>
<a name="l00834"></a>00834 <span class="comment">    transfers.</span>
<a name="l00835"></a>00835 <span class="comment"></span>
<a name="l00836"></a>00836 <span class="comment">@endverbatim</span>
<a name="l00837"></a>00837 <span class="comment">  * @{</span>
<a name="l00838"></a>00838 <span class="comment">  */</span>
<a name="l00839"></a>00839 <span class="comment"></span>
<a name="l00840"></a>00840 <span class="comment">/**</span>
<a name="l00841"></a>00841 <span class="comment">  * @brief  Start the USB device</span>
<a name="l00842"></a>00842 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00843"></a>00843 <span class="comment">  * @retval HAL status</span>
<a name="l00844"></a>00844 <span class="comment">  */</span>
<a name="l00845"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaed7a0a21ca81a2fcdd4db87606dee381">00845</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaed7a0a21ca81a2fcdd4db87606dee381" title="Start the USB device.">HAL_PCD_Start</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00846"></a>00846 {
<a name="l00847"></a>00847   __HAL_LOCK(hpcd);
<a name="l00848"></a>00848 <span class="preprocessor">#if defined (USB)</span>
<a name="l00849"></a>00849 <span class="preprocessor"></span>  <a class="code" href="group/group__PCDEx__Exported__Functions__Group1.html#ga3d04e2831c0a46d0e6719c1a2caba5b1" title="Software Device Connection, this function is not required by USB OTG FS peripheral, it is used only by USB Device FS peripheral.">HAL_PCDEx_SetConnectionState</a>(hpcd, 1U);
<a name="l00850"></a>00850 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l00851"></a>00851   (void)USB_DevConnect(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l00852"></a>00852   <a class="code" href="group/group__PCD__Exported__Macros.html#gaaa11c016ef66a8888c6c174bd05e3aa7">__HAL_PCD_ENABLE</a>(hpcd);
<a name="l00853"></a>00853   __HAL_UNLOCK(hpcd);
<a name="l00854"></a>00854   <span class="keywordflow">return</span> HAL_OK;
<a name="l00855"></a>00855 }
<a name="l00856"></a>00856 <span class="comment"></span>
<a name="l00857"></a>00857 <span class="comment">/**</span>
<a name="l00858"></a>00858 <span class="comment">  * @brief  Stop the USB device.</span>
<a name="l00859"></a>00859 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00860"></a>00860 <span class="comment">  * @retval HAL status</span>
<a name="l00861"></a>00861 <span class="comment">  */</span>
<a name="l00862"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gad2e6055aea6458c0aec7df9c8ab7abab">00862</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gad2e6055aea6458c0aec7df9c8ab7abab" title="Stop the USB device.">HAL_PCD_Stop</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00863"></a>00863 {
<a name="l00864"></a>00864   __HAL_LOCK(hpcd);
<a name="l00865"></a>00865   <a class="code" href="group/group__PCD__Exported__Macros.html#ga71786c2c6765e270f25c21a85ac3fa77">__HAL_PCD_DISABLE</a>(hpcd);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keywordflow">if</span> (USB_StopDevice(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>) != HAL_OK)
<a name="l00868"></a>00868   {
<a name="l00869"></a>00869     __HAL_UNLOCK(hpcd);
<a name="l00870"></a>00870     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l00871"></a>00871   }
<a name="l00872"></a>00872 
<a name="l00873"></a>00873   (void)USB_DevDisconnect(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l00874"></a>00874   __HAL_UNLOCK(hpcd);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keywordflow">return</span> HAL_OK;
<a name="l00877"></a>00877 }
<a name="l00878"></a>00878 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l00879"></a>00879 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l00880"></a>00880 <span class="comment">  * @brief  Handles PCD interrupt request.</span>
<a name="l00881"></a>00881 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l00882"></a>00882 <span class="comment">  * @retval HAL status</span>
<a name="l00883"></a>00883 <span class="comment">  */</span>
<a name="l00884"></a>00884 <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga502da86920d2beb8284c4c2d3dbac0c6" title="This function handles PCD interrupt request.">HAL_PCD_IRQHandler</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l00885"></a>00885 {
<a name="l00886"></a>00886   USB_OTG_GlobalTypeDef *USBx = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>;
<a name="l00887"></a>00887   uint32_t USBx_BASE = (uint32_t)USBx;
<a name="l00888"></a>00888   uint32_t i, ep_intr, epint, epnum;
<a name="l00889"></a>00889   uint32_t fifoemptymsk, temp;
<a name="l00890"></a>00890   USB_OTG_EPTypeDef *ep;
<a name="l00891"></a>00891 
<a name="l00892"></a>00892   <span class="comment">/* ensure that we are in device mode */</span>
<a name="l00893"></a>00893   <span class="keywordflow">if</span> (USB_GetMode(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>) == USB_OTG_MODE_DEVICE)
<a name="l00894"></a>00894   {
<a name="l00895"></a>00895     <span class="comment">/* avoid spurious interrupt */</span>
<a name="l00896"></a>00896     <span class="keywordflow">if</span> (__HAL_PCD_IS_INVALID_INTERRUPT(hpcd))
<a name="l00897"></a>00897     {
<a name="l00898"></a>00898       <span class="keywordflow">return</span>;
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_MMIS))
<a name="l00902"></a>00902     {
<a name="l00903"></a>00903       <span class="comment">/* incorrect mode, acknowledge the interrupt */</span>
<a name="l00904"></a>00904       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_MMIS);
<a name="l00905"></a>00905     }
<a name="l00906"></a>00906 
<a name="l00907"></a>00907     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_OEPINT))
<a name="l00908"></a>00908     {
<a name="l00909"></a>00909       epnum = 0U;
<a name="l00910"></a>00910 
<a name="l00911"></a>00911       <span class="comment">/* Read in the device interrupt bits */</span>
<a name="l00912"></a>00912       ep_intr = USB_ReadDevAllOutEpInterrupt(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l00913"></a>00913 
<a name="l00914"></a>00914       <span class="keywordflow">while</span> (ep_intr != 0U)
<a name="l00915"></a>00915       {
<a name="l00916"></a>00916         <span class="keywordflow">if</span> ((ep_intr &amp; 0x1U) != 0U)
<a name="l00917"></a>00917         {
<a name="l00918"></a>00918           epint = USB_ReadDevOutEPInterrupt(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint8_t)epnum);
<a name="l00919"></a>00919 
<a name="l00920"></a>00920           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DOEPINT_XFRC) == USB_OTG_DOEPINT_XFRC)
<a name="l00921"></a>00921           {
<a name="l00922"></a>00922             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_XFRC);
<a name="l00923"></a>00923             (void)PCD_EP_OutXfrComplete_int(hpcd, epnum);
<a name="l00924"></a>00924           }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DOEPINT_STUP) == USB_OTG_DOEPINT_STUP)
<a name="l00927"></a>00927           {
<a name="l00928"></a>00928             <span class="comment">/* Class B setup phase done for previous decoded setup */</span>
<a name="l00929"></a>00929             (void)PCD_EP_OutSetupPacket_int(hpcd, epnum);
<a name="l00930"></a>00930             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STUP);
<a name="l00931"></a>00931           }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DOEPINT_OTEPDIS) == USB_OTG_DOEPINT_OTEPDIS)
<a name="l00934"></a>00934           {
<a name="l00935"></a>00935             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPDIS);
<a name="l00936"></a>00936           }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938           <span class="comment">/* Clear Status Phase Received interrupt */</span>
<a name="l00939"></a>00939           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
<a name="l00940"></a>00940           {
<a name="l00941"></a>00941             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
<a name="l00942"></a>00942           }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944           <span class="comment">/* Clear OUT NAK interrupt */</span>
<a name="l00945"></a>00945           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DOEPINT_NAK) == USB_OTG_DOEPINT_NAK)
<a name="l00946"></a>00946           {
<a name="l00947"></a>00947             CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_NAK);
<a name="l00948"></a>00948           }
<a name="l00949"></a>00949         }
<a name="l00950"></a>00950         epnum++;
<a name="l00951"></a>00951         ep_intr &gt;&gt;= 1U;
<a name="l00952"></a>00952       }
<a name="l00953"></a>00953     }
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_IEPINT))
<a name="l00956"></a>00956     {
<a name="l00957"></a>00957       <span class="comment">/* Read in the device interrupt bits */</span>
<a name="l00958"></a>00958       ep_intr = USB_ReadDevAllInEpInterrupt(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l00959"></a>00959 
<a name="l00960"></a>00960       epnum = 0U;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962       <span class="keywordflow">while</span> (ep_intr != 0U)
<a name="l00963"></a>00963       {
<a name="l00964"></a>00964         <span class="keywordflow">if</span> ((ep_intr &amp; 0x1U) != 0U) <span class="comment">/* In ITR */</span>
<a name="l00965"></a>00965         {
<a name="l00966"></a>00966           epint = USB_ReadDevInEPInterrupt(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint8_t)epnum);
<a name="l00967"></a>00967 
<a name="l00968"></a>00968           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_XFRC) == USB_OTG_DIEPINT_XFRC)
<a name="l00969"></a>00969           {
<a name="l00970"></a>00970             fifoemptymsk = (uint32_t)(0x1UL &lt;&lt; (epnum &amp; EP_ADDR_MSK));
<a name="l00971"></a>00971             USBx_DEVICE-&gt;DIEPEMPMSK &amp;= ~fifoemptymsk;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973             CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_XFRC);
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span>            hpcd-&gt;DataInStageCallback(hpcd, (uint8_t)epnum);
<a name="l00977"></a>00977 <span class="preprocessor">#else</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>            <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>(hpcd, (uint8_t)epnum);
<a name="l00979"></a>00979 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l00980"></a>00980           }
<a name="l00981"></a>00981           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_TOC) == USB_OTG_DIEPINT_TOC)
<a name="l00982"></a>00982           {
<a name="l00983"></a>00983             CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_TOC);
<a name="l00984"></a>00984           }
<a name="l00985"></a>00985           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_ITTXFE) == USB_OTG_DIEPINT_ITTXFE)
<a name="l00986"></a>00986           {
<a name="l00987"></a>00987             CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_ITTXFE);
<a name="l00988"></a>00988           }
<a name="l00989"></a>00989           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_INEPNE) == USB_OTG_DIEPINT_INEPNE)
<a name="l00990"></a>00990           {
<a name="l00991"></a>00991             CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_INEPNE);
<a name="l00992"></a>00992           }
<a name="l00993"></a>00993           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_EPDISD) == USB_OTG_DIEPINT_EPDISD)
<a name="l00994"></a>00994           {
<a name="l00995"></a>00995             CLEAR_IN_EP_INTR(epnum, USB_OTG_DIEPINT_EPDISD);
<a name="l00996"></a>00996           }
<a name="l00997"></a>00997           <span class="keywordflow">if</span> ((epint &amp; USB_OTG_DIEPINT_TXFE) == USB_OTG_DIEPINT_TXFE)
<a name="l00998"></a>00998           {
<a name="l00999"></a>00999             (void)PCD_WriteEmptyTxFifo(hpcd, epnum);
<a name="l01000"></a>01000           }
<a name="l01001"></a>01001         }
<a name="l01002"></a>01002         epnum++;
<a name="l01003"></a>01003         ep_intr &gt;&gt;= 1U;
<a name="l01004"></a>01004       }
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     <span class="comment">/* Handle Resume Interrupt */</span>
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_WKUINT))
<a name="l01009"></a>01009     {
<a name="l01010"></a>01010       <span class="comment">/* Clear the Remote Wake-up Signaling */</span>
<a name="l01011"></a>01011       USBx_DEVICE-&gt;DCTL &amp;= ~USB_OTG_DCTL_RWUSIG;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01014"></a>01014 <span class="preprocessor"></span>      hpcd-&gt;ResumeCallback(hpcd);
<a name="l01015"></a>01015 <span class="preprocessor">#else</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1" title="Resume event callback.">HAL_PCD_ResumeCallback</a>(hpcd);
<a name="l01017"></a>01017 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01018"></a>01018 
<a name="l01019"></a>01019       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_WKUINT);
<a name="l01020"></a>01020     }
<a name="l01021"></a>01021 
<a name="l01022"></a>01022     <span class="comment">/* Handle Suspend Interrupt */</span>
<a name="l01023"></a>01023     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_USBSUSP))
<a name="l01024"></a>01024     {
<a name="l01025"></a>01025       <span class="keywordflow">if</span> ((USBx_DEVICE-&gt;DSTS &amp; USB_OTG_DSTS_SUSPSTS) == USB_OTG_DSTS_SUSPSTS)
<a name="l01026"></a>01026       {
<a name="l01027"></a>01027 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01028"></a>01028 <span class="preprocessor"></span>        hpcd-&gt;SuspendCallback(hpcd);
<a name="l01029"></a>01029 <span class="preprocessor">#else</span>
<a name="l01030"></a>01030 <span class="preprocessor"></span>        <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428" title="Suspend event callback.">HAL_PCD_SuspendCallback</a>(hpcd);
<a name="l01031"></a>01031 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01032"></a>01032       }
<a name="l01033"></a>01033       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_USBSUSP);
<a name="l01034"></a>01034     }
<a name="l01035"></a>01035     <span class="comment">/* Handle Reset Interrupt */</span>
<a name="l01036"></a>01036     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_USBRST))
<a name="l01037"></a>01037     {
<a name="l01038"></a>01038       USBx_DEVICE-&gt;DCTL &amp;= ~USB_OTG_DCTL_RWUSIG;
<a name="l01039"></a>01039       (void)USB_FlushTxFifo(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, 0x10U);
<a name="l01040"></a>01040 
<a name="l01041"></a>01041       <span class="keywordflow">for</span> (i = 0U; i &lt; hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dev_endpoints; i++)
<a name="l01042"></a>01042       {
<a name="l01043"></a>01043         USBx_INEP(i)-&gt;DIEPINT = 0xFB7FU;
<a name="l01044"></a>01044         USBx_INEP(i)-&gt;DIEPCTL &amp;= ~USB_OTG_DIEPCTL_STALL;
<a name="l01045"></a>01045         USBx_OUTEP(i)-&gt;DOEPINT = 0xFB7FU;
<a name="l01046"></a>01046         USBx_OUTEP(i)-&gt;DOEPCTL &amp;= ~USB_OTG_DOEPCTL_STALL;
<a name="l01047"></a>01047       }
<a name="l01048"></a>01048       USBx_DEVICE-&gt;DAINTMSK |= 0x10001U;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       <span class="keywordflow">if</span> (hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.use_dedicated_ep1 != 0U)
<a name="l01051"></a>01051       {
<a name="l01052"></a>01052         USBx_DEVICE-&gt;DOUTEP1MSK |= USB_OTG_DOEPMSK_STUPM |
<a name="l01053"></a>01053                                    USB_OTG_DOEPMSK_XFRCM |
<a name="l01054"></a>01054                                    USB_OTG_DOEPMSK_EPDM;
<a name="l01055"></a>01055 
<a name="l01056"></a>01056         USBx_DEVICE-&gt;DINEP1MSK |= USB_OTG_DIEPMSK_TOM |
<a name="l01057"></a>01057                                   USB_OTG_DIEPMSK_XFRCM |
<a name="l01058"></a>01058                                   USB_OTG_DIEPMSK_EPDM;
<a name="l01059"></a>01059       }
<a name="l01060"></a>01060       <span class="keywordflow">else</span>
<a name="l01061"></a>01061       {
<a name="l01062"></a>01062         USBx_DEVICE-&gt;DOEPMSK |= USB_OTG_DOEPMSK_STUPM |
<a name="l01063"></a>01063                                 USB_OTG_DOEPMSK_XFRCM |
<a name="l01064"></a>01064                                 USB_OTG_DOEPMSK_EPDM |
<a name="l01065"></a>01065                                 USB_OTG_DOEPMSK_OTEPSPRM |
<a name="l01066"></a>01066                                 USB_OTG_DOEPMSK_NAKM;
<a name="l01067"></a>01067 
<a name="l01068"></a>01068         USBx_DEVICE-&gt;DIEPMSK |= USB_OTG_DIEPMSK_TOM |
<a name="l01069"></a>01069                                 USB_OTG_DIEPMSK_XFRCM |
<a name="l01070"></a>01070                                 USB_OTG_DIEPMSK_EPDM;
<a name="l01071"></a>01071       }
<a name="l01072"></a>01072 
<a name="l01073"></a>01073       <span class="comment">/* Set Default Address to 0 */</span>
<a name="l01074"></a>01074       USBx_DEVICE-&gt;DCFG &amp;= ~USB_OTG_DCFG_DAD;
<a name="l01075"></a>01075 
<a name="l01076"></a>01076       <span class="comment">/* setup EP0 to receive SETUP packets */</span>
<a name="l01077"></a>01077       (void)USB_EP0_OutStart(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint8_t *)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a1b0969b24339de5dd49515ef1282743c">Setup</a>);
<a name="l01078"></a>01078 
<a name="l01079"></a>01079       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_USBRST);
<a name="l01080"></a>01080     }
<a name="l01081"></a>01081 
<a name="l01082"></a>01082     <span class="comment">/* Handle Enumeration done Interrupt */</span>
<a name="l01083"></a>01083     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_ENUMDNE))
<a name="l01084"></a>01084     {
<a name="l01085"></a>01085       (void)USB_ActivateSetup(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l01086"></a>01086       hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.speed = USB_GetDevSpeed(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l01087"></a>01087 
<a name="l01088"></a>01088       <span class="comment">/* Set USB Turnaround time */</span>
<a name="l01089"></a>01089       (void)USB_SetTurnaroundTime(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>,
<a name="l01090"></a>01090                                   <a class="code" href="group__RCC__Exported__Functions__Group2.html#ga38d6c5c7a5d8758849912c9aa0a2156d" title="Returns the HCLK frequency.">HAL_RCC_GetHCLKFreq</a>(),
<a name="l01091"></a>01091                                   (uint8_t)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.speed);
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01094"></a>01094 <span class="preprocessor"></span>      hpcd-&gt;ResetCallback(hpcd);
<a name="l01095"></a>01095 <span class="preprocessor">#else</span>
<a name="l01096"></a>01096 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b" title="USB Reset callback.">HAL_PCD_ResetCallback</a>(hpcd);
<a name="l01097"></a>01097 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01098"></a>01098 
<a name="l01099"></a>01099       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_ENUMDNE);
<a name="l01100"></a>01100     }
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     <span class="comment">/* Handle RxQLevel Interrupt */</span>
<a name="l01103"></a>01103     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_RXFLVL))
<a name="l01104"></a>01104     {
<a name="l01105"></a>01105       USB_MASK_INTERRUPT(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, USB_OTG_GINTSTS_RXFLVL);
<a name="l01106"></a>01106 
<a name="l01107"></a>01107       temp = USBx-&gt;GRXSTSP;
<a name="l01108"></a>01108 
<a name="l01109"></a>01109       ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[temp &amp; USB_OTG_GRXSTSP_EPNUM];
<a name="l01110"></a>01110 
<a name="l01111"></a>01111       <span class="keywordflow">if</span> (((temp &amp; USB_OTG_GRXSTSP_PKTSTS) &gt;&gt; 17) ==  STS_DATA_UPDT)
<a name="l01112"></a>01112       {
<a name="l01113"></a>01113         <span class="keywordflow">if</span> ((temp &amp; USB_OTG_GRXSTSP_BCNT) != 0U)
<a name="l01114"></a>01114         {
<a name="l01115"></a>01115           (void)USB_ReadPacket(USBx, ep-&gt;xfer_buff,
<a name="l01116"></a>01116                                (uint16_t)((temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; 4));
<a name="l01117"></a>01117 
<a name="l01118"></a>01118           ep-&gt;xfer_buff += (temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; 4;
<a name="l01119"></a>01119           ep-&gt;xfer_count += (temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; 4;
<a name="l01120"></a>01120         }
<a name="l01121"></a>01121       }
<a name="l01122"></a>01122       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (((temp &amp; USB_OTG_GRXSTSP_PKTSTS) &gt;&gt; 17) ==  STS_SETUP_UPDT)
<a name="l01123"></a>01123       {
<a name="l01124"></a>01124         (void)USB_ReadPacket(USBx, (uint8_t *)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a1b0969b24339de5dd49515ef1282743c">Setup</a>, 8U);
<a name="l01125"></a>01125         ep-&gt;xfer_count += (temp &amp; USB_OTG_GRXSTSP_BCNT) &gt;&gt; 4;
<a name="l01126"></a>01126       }
<a name="l01127"></a>01127       <span class="keywordflow">else</span>
<a name="l01128"></a>01128       {
<a name="l01129"></a>01129         <span class="comment">/* ... */</span>
<a name="l01130"></a>01130       }
<a name="l01131"></a>01131       USB_UNMASK_INTERRUPT(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, USB_OTG_GINTSTS_RXFLVL);
<a name="l01132"></a>01132     }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     <span class="comment">/* Handle SOF Interrupt */</span>
<a name="l01135"></a>01135     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_SOF))
<a name="l01136"></a>01136     {
<a name="l01137"></a>01137 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01138"></a>01138 <span class="preprocessor"></span>      hpcd-&gt;SOFCallback(hpcd);
<a name="l01139"></a>01139 <span class="preprocessor">#else</span>
<a name="l01140"></a>01140 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e" title="USB Start Of Frame callback.">HAL_PCD_SOFCallback</a>(hpcd);
<a name="l01141"></a>01141 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01142"></a>01142 
<a name="l01143"></a>01143       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_SOF);
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145 
<a name="l01146"></a>01146     <span class="comment">/* Handle Incomplete ISO IN Interrupt */</span>
<a name="l01147"></a>01147     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_IISOIXFR))
<a name="l01148"></a>01148     {
<a name="l01149"></a>01149       <span class="comment">/* Keep application checking the corresponding Iso IN endpoint</span>
<a name="l01150"></a>01150 <span class="comment">      causing the incomplete Interrupt */</span>
<a name="l01151"></a>01151       epnum = 0U;
<a name="l01152"></a>01152 
<a name="l01153"></a>01153 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01154"></a>01154 <span class="preprocessor"></span>      hpcd-&gt;ISOINIncompleteCallback(hpcd, (uint8_t)epnum);
<a name="l01155"></a>01155 <span class="preprocessor">#else</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga8f4041d553ef2fb326c6e483797f99a8" title="Incomplete ISO IN callback.">HAL_PCD_ISOINIncompleteCallback</a>(hpcd, (uint8_t)epnum);
<a name="l01157"></a>01157 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01158"></a>01158 
<a name="l01159"></a>01159       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_IISOIXFR);
<a name="l01160"></a>01160     }
<a name="l01161"></a>01161 
<a name="l01162"></a>01162     <span class="comment">/* Handle Incomplete ISO OUT Interrupt */</span>
<a name="l01163"></a>01163     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
<a name="l01164"></a>01164     {
<a name="l01165"></a>01165       <span class="comment">/* Keep application checking the corresponding Iso OUT endpoint</span>
<a name="l01166"></a>01166 <span class="comment">      causing the incomplete Interrupt */</span>
<a name="l01167"></a>01167       epnum = 0U;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01170"></a>01170 <span class="preprocessor"></span>      hpcd-&gt;ISOOUTIncompleteCallback(hpcd, (uint8_t)epnum);
<a name="l01171"></a>01171 <span class="preprocessor">#else</span>
<a name="l01172"></a>01172 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga4274f129d782f0a3c9a10b5bbe022cd4" title="Incomplete ISO OUT callback.">HAL_PCD_ISOOUTIncompleteCallback</a>(hpcd, (uint8_t)epnum);
<a name="l01173"></a>01173 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01174"></a>01174 
<a name="l01175"></a>01175       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178     <span class="comment">/* Handle Connection event Interrupt */</span>
<a name="l01179"></a>01179     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_SRQINT))
<a name="l01180"></a>01180     {
<a name="l01181"></a>01181 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01182"></a>01182 <span class="preprocessor"></span>      hpcd-&gt;ConnectCallback(hpcd);
<a name="l01183"></a>01183 <span class="preprocessor">#else</span>
<a name="l01184"></a>01184 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0c449541523759cf62be9c9d47540c5d" title="Connection event callback.">HAL_PCD_ConnectCallback</a>(hpcd);
<a name="l01185"></a>01185 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01186"></a>01186 
<a name="l01187"></a>01187       <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_OTG_GINTSTS_SRQINT);
<a name="l01188"></a>01188     }
<a name="l01189"></a>01189 
<a name="l01190"></a>01190     <span class="comment">/* Handle Disconnection event Interrupt */</span>
<a name="l01191"></a>01191     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_OTG_GINTSTS_OTGINT))
<a name="l01192"></a>01192     {
<a name="l01193"></a>01193       temp = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;GOTGINT;
<a name="l01194"></a>01194 
<a name="l01195"></a>01195       <span class="keywordflow">if</span> ((temp &amp; USB_OTG_GOTGINT_SEDET) == USB_OTG_GOTGINT_SEDET)
<a name="l01196"></a>01196       {
<a name="l01197"></a>01197 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01198"></a>01198 <span class="preprocessor"></span>        hpcd-&gt;DisconnectCallback(hpcd);
<a name="l01199"></a>01199 <span class="preprocessor">#else</span>
<a name="l01200"></a>01200 <span class="preprocessor"></span>        <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga25f930b5fe696224f8e71dacf5f324b4" title="Disconnection event callback.">HAL_PCD_DisconnectCallback</a>(hpcd);
<a name="l01201"></a>01201 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01202"></a>01202       }
<a name="l01203"></a>01203       hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;GOTGINT |= temp;
<a name="l01204"></a>01204     }
<a name="l01205"></a>01205   }
<a name="l01206"></a>01206 }
<a name="l01207"></a>01207 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l01208"></a>01208 
<a name="l01209"></a>01209 <span class="preprocessor">#if defined (USB)</span>
<a name="l01210"></a>01210 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01211"></a>01211 <span class="comment">  * @brief  This function handles PCD interrupt request.</span>
<a name="l01212"></a>01212 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01213"></a>01213 <span class="comment">  * @retval HAL status</span>
<a name="l01214"></a>01214 <span class="comment">  */</span>
<a name="l01215"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga502da86920d2beb8284c4c2d3dbac0c6">01215</a> <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga502da86920d2beb8284c4c2d3dbac0c6" title="This function handles PCD interrupt request.">HAL_PCD_IRQHandler</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01216"></a>01216 {
<a name="l01217"></a>01217   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_CTR))
<a name="l01218"></a>01218   {
<a name="l01219"></a>01219     <span class="comment">/* servicing of the endpoint correct transfer interrupt */</span>
<a name="l01220"></a>01220     <span class="comment">/* clear of the CTR flag into the sub */</span>
<a name="l01221"></a>01221     (void)<a class="code" href="group/group__PCD__Private__Functions.html#ga3420898814fa6df814196c597d833007" title="This function handles PCD Endpoint interrupt request.">PCD_EP_ISR_Handler</a>(hpcd);
<a name="l01222"></a>01222   }
<a name="l01223"></a>01223 
<a name="l01224"></a>01224   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_RESET))
<a name="l01225"></a>01225   {
<a name="l01226"></a>01226     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_RESET);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01229"></a>01229 <span class="preprocessor"></span>    hpcd-&gt;ResetCallback(hpcd);
<a name="l01230"></a>01230 <span class="preprocessor">#else</span>
<a name="l01231"></a>01231 <span class="preprocessor"></span>    <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b" title="USB Reset callback.">HAL_PCD_ResetCallback</a>(hpcd);
<a name="l01232"></a>01232 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     (void)<a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga66397fbae1dd4b6f4b5225b23345ea30" title="Set the USB Device address.">HAL_PCD_SetAddress</a>(hpcd, 0U);
<a name="l01235"></a>01235   }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_PMAOVR))
<a name="l01238"></a>01238   {
<a name="l01239"></a>01239     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_PMAOVR);
<a name="l01240"></a>01240   }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_ERR))
<a name="l01243"></a>01243   {
<a name="l01244"></a>01244     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_ERR);
<a name="l01245"></a>01245   }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_WKUP))
<a name="l01248"></a>01248   {
<a name="l01249"></a>01249     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;CNTR &amp;= (uint16_t) ~(USB_CNTR_LP_MODE);
<a name="l01250"></a>01250     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;CNTR &amp;= (uint16_t) ~(USB_CNTR_FSUSP);
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01253"></a>01253 <span class="preprocessor"></span>    hpcd-&gt;ResumeCallback(hpcd);
<a name="l01254"></a>01254 <span class="preprocessor">#else</span>
<a name="l01255"></a>01255 <span class="preprocessor"></span>    <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1" title="Resume event callback.">HAL_PCD_ResumeCallback</a>(hpcd);
<a name="l01256"></a>01256 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01257"></a>01257 
<a name="l01258"></a>01258     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_WKUP);
<a name="l01259"></a>01259   }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_SUSP))
<a name="l01262"></a>01262   {
<a name="l01263"></a>01263     <span class="comment">/* Force low-power mode in the macrocell */</span>
<a name="l01264"></a>01264     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;CNTR |= USB_CNTR_FSUSP;
<a name="l01265"></a>01265 
<a name="l01266"></a>01266     <span class="comment">/* clear of the ISTR bit must be done after setting of CNTR_FSUSP */</span>
<a name="l01267"></a>01267     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_SUSP);
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;CNTR |= USB_CNTR_LP_MODE;
<a name="l01270"></a>01270 
<a name="l01271"></a>01271     <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_WKUP) == 0U)
<a name="l01272"></a>01272     {
<a name="l01273"></a>01273 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span>      hpcd-&gt;SuspendCallback(hpcd);
<a name="l01275"></a>01275 <span class="preprocessor">#else</span>
<a name="l01276"></a>01276 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428" title="Suspend event callback.">HAL_PCD_SuspendCallback</a>(hpcd);
<a name="l01277"></a>01277 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01278"></a>01278     }
<a name="l01279"></a>01279   }
<a name="l01280"></a>01280 
<a name="l01281"></a>01281   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_SOF))
<a name="l01282"></a>01282   {
<a name="l01283"></a>01283     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_SOF);
<a name="l01284"></a>01284 
<a name="l01285"></a>01285 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01286"></a>01286 <span class="preprocessor"></span>    hpcd-&gt;SOFCallback(hpcd);
<a name="l01287"></a>01287 <span class="preprocessor">#else</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>    <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e" title="USB Start Of Frame callback.">HAL_PCD_SOFCallback</a>(hpcd);
<a name="l01289"></a>01289 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01290"></a>01290   }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292   <span class="keywordflow">if</span> (<a class="code" href="group/group__PCD__Exported__Macros.html#gabf69abad2382b1f7eb7d3f309991f1d1">__HAL_PCD_GET_FLAG</a>(hpcd, USB_ISTR_ESOF))
<a name="l01293"></a>01293   {
<a name="l01294"></a>01294     <span class="comment">/* clear ESOF flag in ISTR */</span>
<a name="l01295"></a>01295     <a class="code" href="group/group__PCD__Exported__Macros.html#ga3aa1cfbbd0c63e125f50e28a4381256d">__HAL_PCD_CLEAR_FLAG</a>(hpcd, USB_ISTR_ESOF);
<a name="l01296"></a>01296   }
<a name="l01297"></a>01297 }
<a name="l01298"></a>01298 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l01299"></a>01299 <span class="comment"></span>
<a name="l01300"></a>01300 <span class="comment">/**</span>
<a name="l01301"></a>01301 <span class="comment">  * @brief  Data OUT stage callback.</span>
<a name="l01302"></a>01302 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01303"></a>01303 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01304"></a>01304 <span class="comment">  * @retval None</span>
<a name="l01305"></a>01305 <span class="comment">  */</span>
<a name="l01306"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149">01306</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t epnum)
<a name="l01307"></a>01307 {
<a name="l01308"></a>01308   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01309"></a>01309   UNUSED(hpcd);
<a name="l01310"></a>01310   UNUSED(epnum);
<a name="l01311"></a>01311 
<a name="l01312"></a>01312   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01313"></a>01313 <span class="comment">            the HAL_PCD_DataOutStageCallback could be implemented in the user file</span>
<a name="l01314"></a>01314 <span class="comment">   */</span>
<a name="l01315"></a>01315 }
<a name="l01316"></a>01316 <span class="comment"></span>
<a name="l01317"></a>01317 <span class="comment">/**</span>
<a name="l01318"></a>01318 <span class="comment">  * @brief  Data IN stage callback</span>
<a name="l01319"></a>01319 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01320"></a>01320 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01321"></a>01321 <span class="comment">  * @retval None</span>
<a name="l01322"></a>01322 <span class="comment">  */</span>
<a name="l01323"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b">01323</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t epnum)
<a name="l01324"></a>01324 {
<a name="l01325"></a>01325   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01326"></a>01326   UNUSED(hpcd);
<a name="l01327"></a>01327   UNUSED(epnum);
<a name="l01328"></a>01328 
<a name="l01329"></a>01329   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01330"></a>01330 <span class="comment">            the HAL_PCD_DataInStageCallback could be implemented in the user file</span>
<a name="l01331"></a>01331 <span class="comment">   */</span>
<a name="l01332"></a>01332 }<span class="comment"></span>
<a name="l01333"></a>01333 <span class="comment">/**</span>
<a name="l01334"></a>01334 <span class="comment">  * @brief  Setup stage callback</span>
<a name="l01335"></a>01335 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01336"></a>01336 <span class="comment">  * @retval None</span>
<a name="l01337"></a>01337 <span class="comment">  */</span>
<a name="l01338"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d">01338</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d" title="Setup stage callback.">HAL_PCD_SetupStageCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01339"></a>01339 {
<a name="l01340"></a>01340   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01341"></a>01341   UNUSED(hpcd);
<a name="l01342"></a>01342 
<a name="l01343"></a>01343   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01344"></a>01344 <span class="comment">            the HAL_PCD_SetupStageCallback could be implemented in the user file</span>
<a name="l01345"></a>01345 <span class="comment">   */</span>
<a name="l01346"></a>01346 }
<a name="l01347"></a>01347 <span class="comment"></span>
<a name="l01348"></a>01348 <span class="comment">/**</span>
<a name="l01349"></a>01349 <span class="comment">  * @brief  USB Start Of Frame callback.</span>
<a name="l01350"></a>01350 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01351"></a>01351 <span class="comment">  * @retval None</span>
<a name="l01352"></a>01352 <span class="comment">  */</span>
<a name="l01353"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e">01353</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga85c99eeb4aa17d8ff5298efff92ac28e" title="USB Start Of Frame callback.">HAL_PCD_SOFCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01354"></a>01354 {
<a name="l01355"></a>01355   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01356"></a>01356   UNUSED(hpcd);
<a name="l01357"></a>01357 
<a name="l01358"></a>01358   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01359"></a>01359 <span class="comment">            the HAL_PCD_SOFCallback could be implemented in the user file</span>
<a name="l01360"></a>01360 <span class="comment">   */</span>
<a name="l01361"></a>01361 }
<a name="l01362"></a>01362 <span class="comment"></span>
<a name="l01363"></a>01363 <span class="comment">/**</span>
<a name="l01364"></a>01364 <span class="comment">  * @brief  USB Reset callback.</span>
<a name="l01365"></a>01365 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01366"></a>01366 <span class="comment">  * @retval None</span>
<a name="l01367"></a>01367 <span class="comment">  */</span>
<a name="l01368"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b">01368</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#gaf4fbef977092aa525c6b1668ffbec77b" title="USB Reset callback.">HAL_PCD_ResetCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01369"></a>01369 {
<a name="l01370"></a>01370   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01371"></a>01371   UNUSED(hpcd);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01374"></a>01374 <span class="comment">            the HAL_PCD_ResetCallback could be implemented in the user file</span>
<a name="l01375"></a>01375 <span class="comment">   */</span>
<a name="l01376"></a>01376 }
<a name="l01377"></a>01377 <span class="comment"></span>
<a name="l01378"></a>01378 <span class="comment">/**</span>
<a name="l01379"></a>01379 <span class="comment">  * @brief  Suspend event callback.</span>
<a name="l01380"></a>01380 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01381"></a>01381 <span class="comment">  * @retval None</span>
<a name="l01382"></a>01382 <span class="comment">  */</span>
<a name="l01383"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428">01383</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0e14acd4564979743bc0a89aa5f15428" title="Suspend event callback.">HAL_PCD_SuspendCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01384"></a>01384 {
<a name="l01385"></a>01385   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01386"></a>01386   UNUSED(hpcd);
<a name="l01387"></a>01387 
<a name="l01388"></a>01388   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01389"></a>01389 <span class="comment">            the HAL_PCD_SuspendCallback could be implemented in the user file</span>
<a name="l01390"></a>01390 <span class="comment">   */</span>
<a name="l01391"></a>01391 }
<a name="l01392"></a>01392 <span class="comment"></span>
<a name="l01393"></a>01393 <span class="comment">/**</span>
<a name="l01394"></a>01394 <span class="comment">  * @brief  Resume event callback.</span>
<a name="l01395"></a>01395 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01396"></a>01396 <span class="comment">  * @retval None</span>
<a name="l01397"></a>01397 <span class="comment">  */</span>
<a name="l01398"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1">01398</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0386a36b921cd51dd6e50103c3cd33b1" title="Resume event callback.">HAL_PCD_ResumeCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01399"></a>01399 {
<a name="l01400"></a>01400   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01401"></a>01401   UNUSED(hpcd);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01404"></a>01404 <span class="comment">            the HAL_PCD_ResumeCallback could be implemented in the user file</span>
<a name="l01405"></a>01405 <span class="comment">   */</span>
<a name="l01406"></a>01406 }
<a name="l01407"></a>01407 <span class="comment"></span>
<a name="l01408"></a>01408 <span class="comment">/**</span>
<a name="l01409"></a>01409 <span class="comment">  * @brief  Incomplete ISO OUT callback.</span>
<a name="l01410"></a>01410 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01411"></a>01411 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01412"></a>01412 <span class="comment">  * @retval None</span>
<a name="l01413"></a>01413 <span class="comment">  */</span>
<a name="l01414"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga4274f129d782f0a3c9a10b5bbe022cd4">01414</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga4274f129d782f0a3c9a10b5bbe022cd4" title="Incomplete ISO OUT callback.">HAL_PCD_ISOOUTIncompleteCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t epnum)
<a name="l01415"></a>01415 {
<a name="l01416"></a>01416   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01417"></a>01417   UNUSED(hpcd);
<a name="l01418"></a>01418   UNUSED(epnum);
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01421"></a>01421 <span class="comment">            the HAL_PCD_ISOOUTIncompleteCallback could be implemented in the user file</span>
<a name="l01422"></a>01422 <span class="comment">   */</span>
<a name="l01423"></a>01423 }
<a name="l01424"></a>01424 <span class="comment"></span>
<a name="l01425"></a>01425 <span class="comment">/**</span>
<a name="l01426"></a>01426 <span class="comment">  * @brief  Incomplete ISO IN callback.</span>
<a name="l01427"></a>01427 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01428"></a>01428 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01429"></a>01429 <span class="comment">  * @retval None</span>
<a name="l01430"></a>01430 <span class="comment">  */</span>
<a name="l01431"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga8f4041d553ef2fb326c6e483797f99a8">01431</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga8f4041d553ef2fb326c6e483797f99a8" title="Incomplete ISO IN callback.">HAL_PCD_ISOINIncompleteCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t epnum)
<a name="l01432"></a>01432 {
<a name="l01433"></a>01433   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01434"></a>01434   UNUSED(hpcd);
<a name="l01435"></a>01435   UNUSED(epnum);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01438"></a>01438 <span class="comment">            the HAL_PCD_ISOINIncompleteCallback could be implemented in the user file</span>
<a name="l01439"></a>01439 <span class="comment">   */</span>
<a name="l01440"></a>01440 }
<a name="l01441"></a>01441 <span class="comment"></span>
<a name="l01442"></a>01442 <span class="comment">/**</span>
<a name="l01443"></a>01443 <span class="comment">  * @brief  Connection event callback.</span>
<a name="l01444"></a>01444 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01445"></a>01445 <span class="comment">  * @retval None</span>
<a name="l01446"></a>01446 <span class="comment">  */</span>
<a name="l01447"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0c449541523759cf62be9c9d47540c5d">01447</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga0c449541523759cf62be9c9d47540c5d" title="Connection event callback.">HAL_PCD_ConnectCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01448"></a>01448 {
<a name="l01449"></a>01449   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01450"></a>01450   UNUSED(hpcd);
<a name="l01451"></a>01451 
<a name="l01452"></a>01452   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01453"></a>01453 <span class="comment">            the HAL_PCD_ConnectCallback could be implemented in the user file</span>
<a name="l01454"></a>01454 <span class="comment">   */</span>
<a name="l01455"></a>01455 }
<a name="l01456"></a>01456 <span class="comment"></span>
<a name="l01457"></a>01457 <span class="comment">/**</span>
<a name="l01458"></a>01458 <span class="comment">  * @brief  Disconnection event callback.</span>
<a name="l01459"></a>01459 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01460"></a>01460 <span class="comment">  * @retval None</span>
<a name="l01461"></a>01461 <span class="comment">  */</span>
<a name="l01462"></a><a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga25f930b5fe696224f8e71dacf5f324b4">01462</a> __weak <span class="keywordtype">void</span> <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga25f930b5fe696224f8e71dacf5f324b4" title="Disconnection event callback.">HAL_PCD_DisconnectCallback</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01463"></a>01463 {
<a name="l01464"></a>01464   <span class="comment">/* Prevent unused argument(s) compilation warning */</span>
<a name="l01465"></a>01465   UNUSED(hpcd);
<a name="l01466"></a>01466 
<a name="l01467"></a>01467   <span class="comment">/* NOTE : This function should not be modified, when the callback is needed,</span>
<a name="l01468"></a>01468 <span class="comment">            the HAL_PCD_DisconnectCallback could be implemented in the user file</span>
<a name="l01469"></a>01469 <span class="comment">   */</span>
<a name="l01470"></a>01470 }
<a name="l01471"></a>01471 <span class="comment"></span>
<a name="l01472"></a>01472 <span class="comment">/**</span>
<a name="l01473"></a>01473 <span class="comment">  * @}</span>
<a name="l01474"></a>01474 <span class="comment">  */</span>
<a name="l01475"></a>01475 <span class="comment"></span>
<a name="l01476"></a>01476 <span class="comment">/** @defgroup PCD_Exported_Functions_Group3 Peripheral Control functions</span>
<a name="l01477"></a>01477 <span class="comment"> *  @brief   management functions</span>
<a name="l01478"></a>01478 <span class="comment"> *</span>
<a name="l01479"></a>01479 <span class="comment">@verbatim</span>
<a name="l01480"></a>01480 <span class="comment"> ===============================================================================</span>
<a name="l01481"></a>01481 <span class="comment">                      ##### Peripheral Control functions #####</span>
<a name="l01482"></a>01482 <span class="comment"> ===============================================================================</span>
<a name="l01483"></a>01483 <span class="comment">    [..]</span>
<a name="l01484"></a>01484 <span class="comment">    This subsection provides a set of functions allowing to control the PCD data</span>
<a name="l01485"></a>01485 <span class="comment">    transfers.</span>
<a name="l01486"></a>01486 <span class="comment"></span>
<a name="l01487"></a>01487 <span class="comment">@endverbatim</span>
<a name="l01488"></a>01488 <span class="comment">  * @{</span>
<a name="l01489"></a>01489 <span class="comment">  */</span>
<a name="l01490"></a>01490 <span class="comment"></span>
<a name="l01491"></a>01491 <span class="comment">/**</span>
<a name="l01492"></a>01492 <span class="comment">  * @brief  Connect the USB device</span>
<a name="l01493"></a>01493 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01494"></a>01494 <span class="comment">  * @retval HAL status</span>
<a name="l01495"></a>01495 <span class="comment">  */</span>
<a name="l01496"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga89ca79760ba1c490c2d526e2590d9c8a">01496</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga89ca79760ba1c490c2d526e2590d9c8a" title="Connect the USB device.">HAL_PCD_DevConnect</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01497"></a>01497 {
<a name="l01498"></a>01498   __HAL_LOCK(hpcd);
<a name="l01499"></a>01499 <span class="preprocessor">#if defined (USB)</span>
<a name="l01500"></a>01500 <span class="preprocessor"></span>  <a class="code" href="group/group__PCDEx__Exported__Functions__Group1.html#ga3d04e2831c0a46d0e6719c1a2caba5b1" title="Software Device Connection, this function is not required by USB OTG FS peripheral, it is used only by USB Device FS peripheral.">HAL_PCDEx_SetConnectionState</a>(hpcd, 1U);
<a name="l01501"></a>01501 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l01502"></a>01502   (void)USB_DevConnect(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l01503"></a>01503   __HAL_UNLOCK(hpcd);
<a name="l01504"></a>01504   <span class="keywordflow">return</span> HAL_OK;
<a name="l01505"></a>01505 }
<a name="l01506"></a>01506 <span class="comment"></span>
<a name="l01507"></a>01507 <span class="comment">/**</span>
<a name="l01508"></a>01508 <span class="comment">  * @brief  Disconnect the USB device.</span>
<a name="l01509"></a>01509 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01510"></a>01510 <span class="comment">  * @retval HAL status</span>
<a name="l01511"></a>01511 <span class="comment">  */</span>
<a name="l01512"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaa7cb70cf9891c6e22cad3930ba2d5f99">01512</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaa7cb70cf9891c6e22cad3930ba2d5f99" title="Disconnect the USB device.">HAL_PCD_DevDisconnect</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01513"></a>01513 {
<a name="l01514"></a>01514   __HAL_LOCK(hpcd);
<a name="l01515"></a>01515 <span class="preprocessor">#if defined (USB)</span>
<a name="l01516"></a>01516 <span class="preprocessor"></span>  <a class="code" href="group/group__PCDEx__Exported__Functions__Group1.html#ga3d04e2831c0a46d0e6719c1a2caba5b1" title="Software Device Connection, this function is not required by USB OTG FS peripheral, it is used only by USB Device FS peripheral.">HAL_PCDEx_SetConnectionState</a>(hpcd, 0U);
<a name="l01517"></a>01517 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l01518"></a>01518   (void)USB_DevDisconnect(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l01519"></a>01519   __HAL_UNLOCK(hpcd);
<a name="l01520"></a>01520   <span class="keywordflow">return</span> HAL_OK;
<a name="l01521"></a>01521 }
<a name="l01522"></a>01522 <span class="comment"></span>
<a name="l01523"></a>01523 <span class="comment">/**</span>
<a name="l01524"></a>01524 <span class="comment">  * @brief  Set the USB Device address.</span>
<a name="l01525"></a>01525 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01526"></a>01526 <span class="comment">  * @param  address new device address</span>
<a name="l01527"></a>01527 <span class="comment">  * @retval HAL status</span>
<a name="l01528"></a>01528 <span class="comment">  */</span>
<a name="l01529"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga66397fbae1dd4b6f4b5225b23345ea30">01529</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga66397fbae1dd4b6f4b5225b23345ea30" title="Set the USB Device address.">HAL_PCD_SetAddress</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t address)
<a name="l01530"></a>01530 {
<a name="l01531"></a>01531   __HAL_LOCK(hpcd);
<a name="l01532"></a>01532   hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a795a07e094bc7bc5a4dc3e149d7a33c7">USB_Address</a> = address;
<a name="l01533"></a>01533   (void)USB_SetDevAddress(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, address);
<a name="l01534"></a>01534   __HAL_UNLOCK(hpcd);
<a name="l01535"></a>01535   <span class="keywordflow">return</span> HAL_OK;
<a name="l01536"></a>01536 }<span class="comment"></span>
<a name="l01537"></a>01537 <span class="comment">/**</span>
<a name="l01538"></a>01538 <span class="comment">  * @brief  Open and configure an endpoint.</span>
<a name="l01539"></a>01539 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01540"></a>01540 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01541"></a>01541 <span class="comment">  * @param  ep_mps endpoint max packet size</span>
<a name="l01542"></a>01542 <span class="comment">  * @param  ep_type endpoint type</span>
<a name="l01543"></a>01543 <span class="comment">  * @retval HAL status</span>
<a name="l01544"></a>01544 <span class="comment">  */</span>
<a name="l01545"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gab377a41f91fb7c12c12886d94bd765f2">01545</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gab377a41f91fb7c12c12886d94bd765f2" title="Open and configure an endpoint.">HAL_PCD_EP_Open</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
<a name="l01546"></a>01546 {
<a name="l01547"></a>01547   HAL_StatusTypeDef  ret = HAL_OK;
<a name="l01548"></a>01548   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01549"></a>01549 
<a name="l01550"></a>01550   <span class="keywordflow">if</span> ((ep_addr &amp; 0x80U) == 0x80U)
<a name="l01551"></a>01551   {
<a name="l01552"></a>01552     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01553"></a>01553     ep-&gt;is_in = 1U;
<a name="l01554"></a>01554   }
<a name="l01555"></a>01555   <span class="keywordflow">else</span>
<a name="l01556"></a>01556   {
<a name="l01557"></a>01557     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01558"></a>01558     ep-&gt;is_in = 0U;
<a name="l01559"></a>01559   }
<a name="l01560"></a>01560 
<a name="l01561"></a>01561   ep-&gt;num = ep_addr &amp; EP_ADDR_MSK;
<a name="l01562"></a>01562   ep-&gt;maxpacket = ep_mps;
<a name="l01563"></a>01563   ep-&gt;type = ep_type;
<a name="l01564"></a>01564 
<a name="l01565"></a>01565   <span class="keywordflow">if</span> (ep-&gt;is_in != 0U)
<a name="l01566"></a>01566   {
<a name="l01567"></a>01567     <span class="comment">/* Assign a Tx FIFO */</span>
<a name="l01568"></a>01568     ep-&gt;tx_fifo_num = ep-&gt;num;
<a name="l01569"></a>01569   }
<a name="l01570"></a>01570   <span class="comment">/* Set initial data PID. */</span>
<a name="l01571"></a>01571   <span class="keywordflow">if</span> (ep_type == EP_TYPE_BULK)
<a name="l01572"></a>01572   {
<a name="l01573"></a>01573     ep-&gt;data_pid_start = 0U;
<a name="l01574"></a>01574   }
<a name="l01575"></a>01575 
<a name="l01576"></a>01576   __HAL_LOCK(hpcd);
<a name="l01577"></a>01577   (void)USB_ActivateEndpoint(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01578"></a>01578   __HAL_UNLOCK(hpcd);
<a name="l01579"></a>01579 
<a name="l01580"></a>01580   <span class="keywordflow">return</span> ret;
<a name="l01581"></a>01581 }
<a name="l01582"></a>01582 <span class="comment"></span>
<a name="l01583"></a>01583 <span class="comment">/**</span>
<a name="l01584"></a>01584 <span class="comment">  * @brief  Deactivate an endpoint.</span>
<a name="l01585"></a>01585 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01586"></a>01586 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01587"></a>01587 <span class="comment">  * @retval HAL status</span>
<a name="l01588"></a>01588 <span class="comment">  */</span>
<a name="l01589"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga439d45b17aa238f68e43b60783836849">01589</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga439d45b17aa238f68e43b60783836849" title="Deactivate an endpoint.">HAL_PCD_EP_Close</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr)
<a name="l01590"></a>01590 {
<a name="l01591"></a>01591   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01592"></a>01592 
<a name="l01593"></a>01593   <span class="keywordflow">if</span> ((ep_addr &amp; 0x80U) == 0x80U)
<a name="l01594"></a>01594   {
<a name="l01595"></a>01595     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01596"></a>01596     ep-&gt;is_in = 1U;
<a name="l01597"></a>01597   }
<a name="l01598"></a>01598   <span class="keywordflow">else</span>
<a name="l01599"></a>01599   {
<a name="l01600"></a>01600     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01601"></a>01601     ep-&gt;is_in = 0U;
<a name="l01602"></a>01602   }
<a name="l01603"></a>01603   ep-&gt;num   = ep_addr &amp; EP_ADDR_MSK;
<a name="l01604"></a>01604 
<a name="l01605"></a>01605   __HAL_LOCK(hpcd);
<a name="l01606"></a>01606   (void)USB_DeactivateEndpoint(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01607"></a>01607   __HAL_UNLOCK(hpcd);
<a name="l01608"></a>01608   <span class="keywordflow">return</span> HAL_OK;
<a name="l01609"></a>01609 }
<a name="l01610"></a>01610 
<a name="l01611"></a>01611 <span class="comment"></span>
<a name="l01612"></a>01612 <span class="comment">/**</span>
<a name="l01613"></a>01613 <span class="comment">  * @brief  Receive an amount of data.</span>
<a name="l01614"></a>01614 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01615"></a>01615 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01616"></a>01616 <span class="comment">  * @param  pBuf pointer to the reception buffer</span>
<a name="l01617"></a>01617 <span class="comment">  * @param  len amount of data to be received</span>
<a name="l01618"></a>01618 <span class="comment">  * @retval HAL status</span>
<a name="l01619"></a>01619 <span class="comment">  */</span>
<a name="l01620"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga0029fe7a8d3db91b13637e2507fba60c">01620</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga0029fe7a8d3db91b13637e2507fba60c" title="Receive an amount of data.">HAL_PCD_EP_Receive</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
<a name="l01621"></a>01621 {
<a name="l01622"></a>01622   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01623"></a>01623 
<a name="l01624"></a>01624   ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01625"></a>01625 
<a name="l01626"></a>01626   <span class="comment">/*setup and start the Xfer */</span>
<a name="l01627"></a>01627   ep-&gt;xfer_buff = pBuf;
<a name="l01628"></a>01628   ep-&gt;xfer_len = len;
<a name="l01629"></a>01629   ep-&gt;xfer_count = 0U;
<a name="l01630"></a>01630   ep-&gt;is_in = 0U;
<a name="l01631"></a>01631   ep-&gt;num = ep_addr &amp; EP_ADDR_MSK;
<a name="l01632"></a>01632 
<a name="l01633"></a>01633   <span class="keywordflow">if</span> ((ep_addr &amp; EP_ADDR_MSK) == 0U)
<a name="l01634"></a>01634   {
<a name="l01635"></a>01635     (void)<a class="code" href="group/group__PCD__Private__Macros.html#ga7a6adfccbbfbc483a20e982d4a3e9543">USB_EP0StartXfer</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01636"></a>01636   }
<a name="l01637"></a>01637   <span class="keywordflow">else</span>
<a name="l01638"></a>01638   {
<a name="l01639"></a>01639     (void)USB_EPStartXfer(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01640"></a>01640   }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642   <span class="keywordflow">return</span> HAL_OK;
<a name="l01643"></a>01643 }
<a name="l01644"></a>01644 <span class="comment"></span>
<a name="l01645"></a>01645 <span class="comment">/**</span>
<a name="l01646"></a>01646 <span class="comment">  * @brief  Get Received Data Size</span>
<a name="l01647"></a>01647 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01648"></a>01648 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01649"></a>01649 <span class="comment">  * @retval Data Size</span>
<a name="l01650"></a>01650 <span class="comment">  */</span>
<a name="l01651"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaf4db38022f73d0dd02f9178229dd74c9">01651</a> uint32_t <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaf4db38022f73d0dd02f9178229dd74c9" title="Get Received Data Size.">HAL_PCD_EP_GetRxCount</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr)
<a name="l01652"></a>01652 {
<a name="l01653"></a>01653   <span class="keywordflow">return</span> hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr &amp; EP_ADDR_MSK].xfer_count;
<a name="l01654"></a>01654 }<span class="comment"></span>
<a name="l01655"></a>01655 <span class="comment">/**</span>
<a name="l01656"></a>01656 <span class="comment">  * @brief  Send an amount of data</span>
<a name="l01657"></a>01657 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01658"></a>01658 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01659"></a>01659 <span class="comment">  * @param  pBuf pointer to the transmission buffer</span>
<a name="l01660"></a>01660 <span class="comment">  * @param  len amount of data to be sent</span>
<a name="l01661"></a>01661 <span class="comment">  * @retval HAL status</span>
<a name="l01662"></a>01662 <span class="comment">  */</span>
<a name="l01663"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga116ada543442c8f7a1003c4d4c211618">01663</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga116ada543442c8f7a1003c4d4c211618" title="Send an amount of data.">HAL_PCD_EP_Transmit</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
<a name="l01664"></a>01664 {
<a name="l01665"></a>01665   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01666"></a>01666 
<a name="l01667"></a>01667   ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01668"></a>01668 
<a name="l01669"></a>01669   <span class="comment">/*setup and start the Xfer */</span>
<a name="l01670"></a>01670   ep-&gt;xfer_buff = pBuf;
<a name="l01671"></a>01671   ep-&gt;xfer_len = len;
<a name="l01672"></a>01672   ep-&gt;xfer_count = 0U;
<a name="l01673"></a>01673   ep-&gt;is_in = 1U;
<a name="l01674"></a>01674   ep-&gt;num = ep_addr &amp; EP_ADDR_MSK;
<a name="l01675"></a>01675 
<a name="l01676"></a>01676   <span class="keywordflow">if</span> ((ep_addr &amp; EP_ADDR_MSK) == 0U)
<a name="l01677"></a>01677   {
<a name="l01678"></a>01678     (void)<a class="code" href="group/group__PCD__Private__Macros.html#ga7a6adfccbbfbc483a20e982d4a3e9543">USB_EP0StartXfer</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01679"></a>01679   }
<a name="l01680"></a>01680   <span class="keywordflow">else</span>
<a name="l01681"></a>01681   {
<a name="l01682"></a>01682     (void)USB_EPStartXfer(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01683"></a>01683   }
<a name="l01684"></a>01684 
<a name="l01685"></a>01685   <span class="keywordflow">return</span> HAL_OK;
<a name="l01686"></a>01686 }
<a name="l01687"></a>01687 <span class="comment"></span>
<a name="l01688"></a>01688 <span class="comment">/**</span>
<a name="l01689"></a>01689 <span class="comment">  * @brief  Set a STALL condition over an endpoint</span>
<a name="l01690"></a>01690 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01691"></a>01691 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01692"></a>01692 <span class="comment">  * @retval HAL status</span>
<a name="l01693"></a>01693 <span class="comment">  */</span>
<a name="l01694"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaecee197a59aacc015742c62b74881b6f">01694</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaecee197a59aacc015742c62b74881b6f" title="Set a STALL condition over an endpoint.">HAL_PCD_EP_SetStall</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr)
<a name="l01695"></a>01695 {
<a name="l01696"></a>01696   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01697"></a>01697 
<a name="l01698"></a>01698   <span class="keywordflow">if</span> (((uint32_t)ep_addr &amp; EP_ADDR_MSK) &gt; hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dev_endpoints)
<a name="l01699"></a>01699   {
<a name="l01700"></a>01700     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01701"></a>01701   }
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   <span class="keywordflow">if</span> ((0x80U &amp; ep_addr) == 0x80U)
<a name="l01704"></a>01704   {
<a name="l01705"></a>01705     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01706"></a>01706     ep-&gt;is_in = 1U;
<a name="l01707"></a>01707   }
<a name="l01708"></a>01708   <span class="keywordflow">else</span>
<a name="l01709"></a>01709   {
<a name="l01710"></a>01710     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr];
<a name="l01711"></a>01711     ep-&gt;is_in = 0U;
<a name="l01712"></a>01712   }
<a name="l01713"></a>01713 
<a name="l01714"></a>01714   ep-&gt;is_stall = 1U;
<a name="l01715"></a>01715   ep-&gt;num = ep_addr &amp; EP_ADDR_MSK;
<a name="l01716"></a>01716 
<a name="l01717"></a>01717   __HAL_LOCK(hpcd);
<a name="l01718"></a>01718 
<a name="l01719"></a>01719   (void)USB_EPSetStall(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01720"></a>01720   <span class="keywordflow">if</span> ((ep_addr &amp; EP_ADDR_MSK) == 0U)
<a name="l01721"></a>01721   {
<a name="l01722"></a>01722     (void)USB_EP0_OutStart(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint8_t *)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a1b0969b24339de5dd49515ef1282743c">Setup</a>);
<a name="l01723"></a>01723   }
<a name="l01724"></a>01724   __HAL_UNLOCK(hpcd);
<a name="l01725"></a>01725 
<a name="l01726"></a>01726   <span class="keywordflow">return</span> HAL_OK;
<a name="l01727"></a>01727 }
<a name="l01728"></a>01728 <span class="comment"></span>
<a name="l01729"></a>01729 <span class="comment">/**</span>
<a name="l01730"></a>01730 <span class="comment">  * @brief  Clear a STALL condition over in an endpoint</span>
<a name="l01731"></a>01731 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01732"></a>01732 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01733"></a>01733 <span class="comment">  * @retval HAL status</span>
<a name="l01734"></a>01734 <span class="comment">  */</span>
<a name="l01735"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga56466fbd2aa05a80c924b18ddc2ac3ca">01735</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga56466fbd2aa05a80c924b18ddc2ac3ca" title="Clear a STALL condition over in an endpoint.">HAL_PCD_EP_ClrStall</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr)
<a name="l01736"></a>01736 {
<a name="l01737"></a>01737   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01738"></a>01738 
<a name="l01739"></a>01739   <span class="keywordflow">if</span> (((uint32_t)ep_addr &amp; 0x0FU) &gt; hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#af610ca87ae079aa8aef6734862ef2485">Init</a>.dev_endpoints)
<a name="l01740"></a>01740   {
<a name="l01741"></a>01741     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01742"></a>01742   }
<a name="l01743"></a>01743 
<a name="l01744"></a>01744   <span class="keywordflow">if</span> ((0x80U &amp; ep_addr) == 0x80U)
<a name="l01745"></a>01745   {
<a name="l01746"></a>01746     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01747"></a>01747     ep-&gt;is_in = 1U;
<a name="l01748"></a>01748   }
<a name="l01749"></a>01749   <span class="keywordflow">else</span>
<a name="l01750"></a>01750   {
<a name="l01751"></a>01751     ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[ep_addr &amp; EP_ADDR_MSK];
<a name="l01752"></a>01752     ep-&gt;is_in = 0U;
<a name="l01753"></a>01753   }
<a name="l01754"></a>01754 
<a name="l01755"></a>01755   ep-&gt;is_stall = 0U;
<a name="l01756"></a>01756   ep-&gt;num = ep_addr &amp; EP_ADDR_MSK;
<a name="l01757"></a>01757 
<a name="l01758"></a>01758   __HAL_LOCK(hpcd);
<a name="l01759"></a>01759   (void)USB_EPClearStall(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep);
<a name="l01760"></a>01760   __HAL_UNLOCK(hpcd);
<a name="l01761"></a>01761 
<a name="l01762"></a>01762   <span class="keywordflow">return</span> HAL_OK;
<a name="l01763"></a>01763 }
<a name="l01764"></a>01764 <span class="comment"></span>
<a name="l01765"></a>01765 <span class="comment">/**</span>
<a name="l01766"></a>01766 <span class="comment">  * @brief  Flush an endpoint</span>
<a name="l01767"></a>01767 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01768"></a>01768 <span class="comment">  * @param  ep_addr endpoint address</span>
<a name="l01769"></a>01769 <span class="comment">  * @retval HAL status</span>
<a name="l01770"></a>01770 <span class="comment">  */</span>
<a name="l01771"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaf245d7a10c697f4591c144596cb2df0f">01771</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gaf245d7a10c697f4591c144596cb2df0f" title="Flush an endpoint.">HAL_PCD_EP_Flush</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint8_t ep_addr)
<a name="l01772"></a>01772 {
<a name="l01773"></a>01773   __HAL_LOCK(hpcd);
<a name="l01774"></a>01774 
<a name="l01775"></a>01775   <span class="keywordflow">if</span> ((ep_addr &amp; 0x80U) == 0x80U)
<a name="l01776"></a>01776   {
<a name="l01777"></a>01777     (void)USB_FlushTxFifo(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint32_t)ep_addr &amp; EP_ADDR_MSK);
<a name="l01778"></a>01778   }
<a name="l01779"></a>01779   <span class="keywordflow">else</span>
<a name="l01780"></a>01780   {
<a name="l01781"></a>01781     (void)USB_FlushRxFifo(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>);
<a name="l01782"></a>01782   }
<a name="l01783"></a>01783 
<a name="l01784"></a>01784   __HAL_UNLOCK(hpcd);
<a name="l01785"></a>01785 
<a name="l01786"></a>01786   <span class="keywordflow">return</span> HAL_OK;
<a name="l01787"></a>01787 }
<a name="l01788"></a>01788 <span class="comment"></span>
<a name="l01789"></a>01789 <span class="comment">/**</span>
<a name="l01790"></a>01790 <span class="comment">  * @brief  Activate remote wakeup signalling</span>
<a name="l01791"></a>01791 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01792"></a>01792 <span class="comment">  * @retval HAL status</span>
<a name="l01793"></a>01793 <span class="comment">  */</span>
<a name="l01794"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gacf293c3e537397cc6067d643d3e976fa">01794</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gacf293c3e537397cc6067d643d3e976fa" title="Activate remote wakeup signalling.">HAL_PCD_ActivateRemoteWakeup</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01795"></a>01795 {
<a name="l01796"></a>01796   <span class="keywordflow">return</span> (USB_ActivateRemoteWakeup(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>));
<a name="l01797"></a>01797 }
<a name="l01798"></a>01798 <span class="comment"></span>
<a name="l01799"></a>01799 <span class="comment">/**</span>
<a name="l01800"></a>01800 <span class="comment">  * @brief  De-activate remote wakeup signalling.</span>
<a name="l01801"></a>01801 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01802"></a>01802 <span class="comment">  * @retval HAL status</span>
<a name="l01803"></a>01803 <span class="comment">  */</span>
<a name="l01804"></a><a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gab9c7261c91edf2ececb0699d320cf177">01804</a> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Exported__Functions__Group3.html#gab9c7261c91edf2ececb0699d320cf177" title="De-activate remote wakeup signalling.">HAL_PCD_DeActivateRemoteWakeup</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01805"></a>01805 {
<a name="l01806"></a>01806   <span class="keywordflow">return</span> (USB_DeActivateRemoteWakeup(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>));
<a name="l01807"></a>01807 }
<a name="l01808"></a>01808 <span class="comment"></span>
<a name="l01809"></a>01809 <span class="comment">/**</span>
<a name="l01810"></a>01810 <span class="comment">  * @}</span>
<a name="l01811"></a>01811 <span class="comment">  */</span>
<a name="l01812"></a>01812 <span class="comment"></span>
<a name="l01813"></a>01813 <span class="comment">/** @defgroup PCD_Exported_Functions_Group4 Peripheral State functions</span>
<a name="l01814"></a>01814 <span class="comment"> *  @brief   Peripheral State functions</span>
<a name="l01815"></a>01815 <span class="comment"> *</span>
<a name="l01816"></a>01816 <span class="comment">@verbatim</span>
<a name="l01817"></a>01817 <span class="comment"> ===============================================================================</span>
<a name="l01818"></a>01818 <span class="comment">                      ##### Peripheral State functions #####</span>
<a name="l01819"></a>01819 <span class="comment"> ===============================================================================</span>
<a name="l01820"></a>01820 <span class="comment">    [..]</span>
<a name="l01821"></a>01821 <span class="comment">    This subsection permits to get in run-time the status of the peripheral</span>
<a name="l01822"></a>01822 <span class="comment">    and the data flow.</span>
<a name="l01823"></a>01823 <span class="comment"></span>
<a name="l01824"></a>01824 <span class="comment">@endverbatim</span>
<a name="l01825"></a>01825 <span class="comment">  * @{</span>
<a name="l01826"></a>01826 <span class="comment">  */</span>
<a name="l01827"></a>01827 <span class="comment"></span>
<a name="l01828"></a>01828 <span class="comment">/**</span>
<a name="l01829"></a>01829 <span class="comment">  * @brief  Return the PCD handle state.</span>
<a name="l01830"></a>01830 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01831"></a>01831 <span class="comment">  * @retval HAL state</span>
<a name="l01832"></a>01832 <span class="comment">  */</span>
<a name="l01833"></a><a class="code" href="group/group__PCD__Exported__Functions__Group4.html#ga63732e60894249f910c31a5bb336b698">01833</a> <a class="code" href="group/group__PCD__Exported__Types.html#ga78b8f0aa4eea3865fb695a732b26be96" title="PCD State structure definition.">PCD_StateTypeDef</a> <a class="code" href="group/group__PCD__Exported__Functions__Group4.html#ga63732e60894249f910c31a5bb336b698" title="Return the PCD handle state.">HAL_PCD_GetState</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01834"></a>01834 {
<a name="l01835"></a>01835   <span class="keywordflow">return</span> hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#ad7994c5f1b1d47cfffb95e9d8ec6a5f4">State</a>;
<a name="l01836"></a>01836 }
<a name="l01837"></a>01837 <span class="comment"></span>
<a name="l01838"></a>01838 <span class="comment">/**</span>
<a name="l01839"></a>01839 <span class="comment">  * @}</span>
<a name="l01840"></a>01840 <span class="comment">  */</span>
<a name="l01841"></a>01841 <span class="comment"></span>
<a name="l01842"></a>01842 <span class="comment">/**</span>
<a name="l01843"></a>01843 <span class="comment">  * @}</span>
<a name="l01844"></a>01844 <span class="comment">  */</span>
<a name="l01845"></a>01845 
<a name="l01846"></a>01846 <span class="comment">/* Private functions ---------------------------------------------------------*/</span><span class="comment"></span>
<a name="l01847"></a>01847 <span class="comment">/** @addtogroup PCD_Private_Functions</span>
<a name="l01848"></a>01848 <span class="comment">  * @{</span>
<a name="l01849"></a>01849 <span class="comment">  */</span>
<a name="l01850"></a>01850 <span class="preprocessor">#if defined (USB_OTG_FS)</span>
<a name="l01851"></a>01851 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01852"></a>01852 <span class="comment">  * @brief  Check FIFO for the next packet to be loaded.</span>
<a name="l01853"></a>01853 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01854"></a>01854 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01855"></a>01855 <span class="comment">  * @retval HAL status</span>
<a name="l01856"></a>01856 <span class="comment">  */</span>
<a name="l01857"></a>01857 <span class="keyword">static</span> HAL_StatusTypeDef PCD_WriteEmptyTxFifo(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum)
<a name="l01858"></a>01858 {
<a name="l01859"></a>01859   USB_OTG_GlobalTypeDef *USBx = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>;
<a name="l01860"></a>01860   uint32_t USBx_BASE = (uint32_t)USBx;
<a name="l01861"></a>01861   USB_OTG_EPTypeDef *ep;
<a name="l01862"></a>01862   uint32_t len;
<a name="l01863"></a>01863   uint32_t len32b;
<a name="l01864"></a>01864   uint32_t fifoemptymsk;
<a name="l01865"></a>01865 
<a name="l01866"></a>01866   ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[epnum];
<a name="l01867"></a>01867 
<a name="l01868"></a>01868   <span class="keywordflow">if</span> (ep-&gt;xfer_count &gt; ep-&gt;xfer_len)
<a name="l01869"></a>01869   {
<a name="l01870"></a>01870     <span class="keywordflow">return</span> HAL_ERROR;
<a name="l01871"></a>01871   }
<a name="l01872"></a>01872 
<a name="l01873"></a>01873   len = ep-&gt;xfer_len - ep-&gt;xfer_count;
<a name="l01874"></a>01874 
<a name="l01875"></a>01875   <span class="keywordflow">if</span> (len &gt; ep-&gt;maxpacket)
<a name="l01876"></a>01876   {
<a name="l01877"></a>01877     len = ep-&gt;maxpacket;
<a name="l01878"></a>01878   }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880   len32b = (len + 3U) / 4U;
<a name="l01881"></a>01881 
<a name="l01882"></a>01882   <span class="keywordflow">while</span> (((USBx_INEP(epnum)-&gt;DTXFSTS &amp; USB_OTG_DTXFSTS_INEPTFSAV) &gt;= len32b) &amp;&amp;
<a name="l01883"></a>01883          (ep-&gt;xfer_count &lt; ep-&gt;xfer_len) &amp;&amp; (ep-&gt;xfer_len != 0U))
<a name="l01884"></a>01884   {
<a name="l01885"></a>01885     <span class="comment">/* Write the FIFO */</span>
<a name="l01886"></a>01886     len = ep-&gt;xfer_len - ep-&gt;xfer_count;
<a name="l01887"></a>01887 
<a name="l01888"></a>01888     <span class="keywordflow">if</span> (len &gt; ep-&gt;maxpacket)
<a name="l01889"></a>01889     {
<a name="l01890"></a>01890       len = ep-&gt;maxpacket;
<a name="l01891"></a>01891     }
<a name="l01892"></a>01892     len32b = (len + 3U) / 4U;
<a name="l01893"></a>01893 
<a name="l01894"></a>01894     (void)USB_WritePacket(USBx, ep-&gt;xfer_buff, (uint8_t)epnum, (uint16_t)len);
<a name="l01895"></a>01895 
<a name="l01896"></a>01896     ep-&gt;xfer_buff  += len;
<a name="l01897"></a>01897     ep-&gt;xfer_count += len;
<a name="l01898"></a>01898   }
<a name="l01899"></a>01899 
<a name="l01900"></a>01900   <span class="keywordflow">if</span> (ep-&gt;xfer_len &lt;= ep-&gt;xfer_count)
<a name="l01901"></a>01901   {
<a name="l01902"></a>01902     fifoemptymsk = (uint32_t)(0x1UL &lt;&lt; (epnum &amp; EP_ADDR_MSK));
<a name="l01903"></a>01903     USBx_DEVICE-&gt;DIEPEMPMSK &amp;= ~fifoemptymsk;
<a name="l01904"></a>01904   }
<a name="l01905"></a>01905 
<a name="l01906"></a>01906   <span class="keywordflow">return</span> HAL_OK;
<a name="l01907"></a>01907 }
<a name="l01908"></a>01908 
<a name="l01909"></a>01909 <span class="comment"></span>
<a name="l01910"></a>01910 <span class="comment">/**</span>
<a name="l01911"></a>01911 <span class="comment">  * @brief  process EP OUT transfer complete interrupt.</span>
<a name="l01912"></a>01912 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01913"></a>01913 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01914"></a>01914 <span class="comment">  * @retval HAL status</span>
<a name="l01915"></a>01915 <span class="comment">  */</span>
<a name="l01916"></a>01916 <span class="keyword">static</span> HAL_StatusTypeDef PCD_EP_OutXfrComplete_int(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum)
<a name="l01917"></a>01917 {
<a name="l01918"></a>01918   USB_OTG_GlobalTypeDef *USBx = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>;
<a name="l01919"></a>01919   uint32_t USBx_BASE = (uint32_t)USBx;
<a name="l01920"></a>01920   uint32_t gSNPSiD = *(__IO uint32_t *)(&amp;USBx-&gt;CID + 0x1U);
<a name="l01921"></a>01921   uint32_t DoepintReg = USBx_OUTEP(epnum)-&gt;DOEPINT;
<a name="l01922"></a>01922 
<a name="l01923"></a>01923   <span class="keywordflow">if</span> (gSNPSiD == USB_OTG_CORE_ID_310A)
<a name="l01924"></a>01924   {
<a name="l01925"></a>01925     <span class="comment">/* StupPktRcvd = 1 this is a setup packet */</span>
<a name="l01926"></a>01926     <span class="keywordflow">if</span> ((DoepintReg &amp; USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX)
<a name="l01927"></a>01927     {
<a name="l01928"></a>01928       CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
<a name="l01929"></a>01929     }
<a name="l01930"></a>01930     <span class="keywordflow">else</span>
<a name="l01931"></a>01931     {
<a name="l01932"></a>01932       <span class="keywordflow">if</span> ((DoepintReg &amp; USB_OTG_DOEPINT_OTEPSPR) == USB_OTG_DOEPINT_OTEPSPR)
<a name="l01933"></a>01933       {
<a name="l01934"></a>01934         CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_OTEPSPR);
<a name="l01935"></a>01935       }
<a name="l01936"></a>01936 
<a name="l01937"></a>01937 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>      hpcd-&gt;DataOutStageCallback(hpcd, (uint8_t)epnum);
<a name="l01939"></a>01939 <span class="preprocessor">#else</span>
<a name="l01940"></a>01940 <span class="preprocessor"></span>      <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>(hpcd, (uint8_t)epnum);
<a name="l01941"></a>01941 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01942"></a>01942     }
<a name="l01943"></a>01943   }
<a name="l01944"></a>01944   <span class="keywordflow">else</span>
<a name="l01945"></a>01945   {
<a name="l01946"></a>01946 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01947"></a>01947 <span class="preprocessor"></span>    hpcd-&gt;DataOutStageCallback(hpcd, (uint8_t)epnum);
<a name="l01948"></a>01948 <span class="preprocessor">#else</span>
<a name="l01949"></a>01949 <span class="preprocessor"></span>    <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>(hpcd, (uint8_t)epnum);
<a name="l01950"></a>01950 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01951"></a>01951   }
<a name="l01952"></a>01952 
<a name="l01953"></a>01953   <span class="keywordflow">return</span> HAL_OK;
<a name="l01954"></a>01954 }
<a name="l01955"></a>01955 
<a name="l01956"></a>01956 <span class="comment"></span>
<a name="l01957"></a>01957 <span class="comment">/**</span>
<a name="l01958"></a>01958 <span class="comment">  * @brief  process EP OUT setup packet received interrupt.</span>
<a name="l01959"></a>01959 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01960"></a>01960 <span class="comment">  * @param  epnum endpoint number</span>
<a name="l01961"></a>01961 <span class="comment">  * @retval HAL status</span>
<a name="l01962"></a>01962 <span class="comment">  */</span>
<a name="l01963"></a>01963 <span class="keyword">static</span> HAL_StatusTypeDef PCD_EP_OutSetupPacket_int(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd, uint32_t epnum)
<a name="l01964"></a>01964 {
<a name="l01965"></a>01965   USB_OTG_GlobalTypeDef *USBx = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>;
<a name="l01966"></a>01966   uint32_t USBx_BASE = (uint32_t)USBx;
<a name="l01967"></a>01967   uint32_t gSNPSiD = *(__IO uint32_t *)(&amp;USBx-&gt;CID + 0x1U);
<a name="l01968"></a>01968   uint32_t DoepintReg = USBx_OUTEP(epnum)-&gt;DOEPINT;
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 
<a name="l01971"></a>01971   <span class="keywordflow">if</span> ((gSNPSiD == USB_OTG_CORE_ID_310A) &amp;&amp;
<a name="l01972"></a>01972       ((DoepintReg &amp; USB_OTG_DOEPINT_STPKTRX) == USB_OTG_DOEPINT_STPKTRX))
<a name="l01973"></a>01973   {
<a name="l01974"></a>01974     CLEAR_OUT_EP_INTR(epnum, USB_OTG_DOEPINT_STPKTRX);
<a name="l01975"></a>01975   }
<a name="l01976"></a>01976 
<a name="l01977"></a>01977   <span class="comment">/* Inform the upper layer that a setup packet is available */</span>
<a name="l01978"></a>01978 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l01979"></a>01979 <span class="preprocessor"></span>  hpcd-&gt;SetupStageCallback(hpcd);
<a name="l01980"></a>01980 <span class="preprocessor">#else</span>
<a name="l01981"></a>01981 <span class="preprocessor"></span>  <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d" title="Setup stage callback.">HAL_PCD_SetupStageCallback</a>(hpcd);
<a name="l01982"></a>01982 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l01983"></a>01983 
<a name="l01984"></a>01984   <span class="keywordflow">return</span> HAL_OK;
<a name="l01985"></a>01985 }
<a name="l01986"></a>01986 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB_OTG_FS) */</span>
<a name="l01987"></a>01987 
<a name="l01988"></a>01988 <span class="preprocessor">#if defined (USB)</span>
<a name="l01989"></a>01989 <span class="preprocessor"></span><span class="comment">/**</span>
<a name="l01990"></a>01990 <span class="comment">  * @brief  This function handles PCD Endpoint interrupt request.</span>
<a name="l01991"></a>01991 <span class="comment">  * @param  hpcd PCD handle</span>
<a name="l01992"></a>01992 <span class="comment">  * @retval HAL status</span>
<a name="l01993"></a>01993 <span class="comment">  */</span>
<a name="l01994"></a><a class="code" href="group/group__PCD__Private__Functions.html#ga3420898814fa6df814196c597d833007">01994</a> <span class="keyword">static</span> HAL_StatusTypeDef <a class="code" href="group/group__PCD__Private__Functions.html#ga3420898814fa6df814196c597d833007" title="This function handles PCD Endpoint interrupt request.">PCD_EP_ISR_Handler</a>(<a class="code" href="structPCD__HandleTypeDef.html" title="PCD Handle Structure definition.">PCD_HandleTypeDef</a> *hpcd)
<a name="l01995"></a>01995 {
<a name="l01996"></a>01996   <a class="code" href="group/group__PCD__Exported__Types.html#ga21d0ff8d891c77251b49b3878a0d7584">PCD_EPTypeDef</a> *ep;
<a name="l01997"></a>01997   uint16_t count;
<a name="l01998"></a>01998   uint16_t wIstr;
<a name="l01999"></a>01999   uint16_t wEPVal;
<a name="l02000"></a>02000   uint8_t epindex;
<a name="l02001"></a>02001 
<a name="l02002"></a>02002   <span class="comment">/* stay in loop while pending interrupts */</span>
<a name="l02003"></a>02003   <span class="keywordflow">while</span> ((hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;ISTR &amp; USB_ISTR_CTR) != 0U)
<a name="l02004"></a>02004   {
<a name="l02005"></a>02005     wIstr = hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;ISTR;
<a name="l02006"></a>02006     <span class="comment">/* extract highest priority endpoint number */</span>
<a name="l02007"></a>02007     epindex = (uint8_t)(wIstr &amp; USB_ISTR_EP_ID);
<a name="l02008"></a>02008 
<a name="l02009"></a>02009     <span class="keywordflow">if</span> (epindex == 0U)
<a name="l02010"></a>02010     {
<a name="l02011"></a>02011       <span class="comment">/* Decode and service control endpoint interrupt */</span>
<a name="l02012"></a>02012 
<a name="l02013"></a>02013       <span class="comment">/* DIR bit = origin of the interrupt */</span>
<a name="l02014"></a>02014       <span class="keywordflow">if</span> ((wIstr &amp; USB_ISTR_DIR) == 0U)
<a name="l02015"></a>02015       {
<a name="l02016"></a>02016         <span class="comment">/* DIR = 0 */</span>
<a name="l02017"></a>02017 
<a name="l02018"></a>02018         <span class="comment">/* DIR = 0      =&gt; IN  int */</span>
<a name="l02019"></a>02019         <span class="comment">/* DIR = 0 implies that (EP_CTR_TX = 1) always  */</span>
<a name="l02020"></a>02020         <a class="code" href="group/group__PCD__Private__Macros.html#ga2acbe2a407b78b2da6523ab655c63efe">PCD_CLEAR_TX_EP_CTR</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>);
<a name="l02021"></a>02021         ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[0];
<a name="l02022"></a>02022 
<a name="l02023"></a>02023         ep-&gt;xfer_count = <a class="code" href="group/group__PCD__Private__Macros.html#ga5b1ae84bc910a8f8dfb57b85f68c77cc" title="gets counter of the tx buffer.">PCD_GET_EP_TX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02024"></a>02024         ep-&gt;xfer_buff += ep-&gt;xfer_count;
<a name="l02025"></a>02025 
<a name="l02026"></a>02026         <span class="comment">/* TX COMPLETE */</span>
<a name="l02027"></a>02027 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l02028"></a>02028 <span class="preprocessor"></span>        hpcd-&gt;DataInStageCallback(hpcd, 0U);
<a name="l02029"></a>02029 <span class="preprocessor">#else</span>
<a name="l02030"></a>02030 <span class="preprocessor"></span>        <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>(hpcd, 0U);
<a name="l02031"></a>02031 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l02032"></a>02032 
<a name="l02033"></a>02033         <span class="keywordflow">if</span> ((hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a795a07e094bc7bc5a4dc3e149d7a33c7">USB_Address</a> &gt; 0U) &amp;&amp; (ep-&gt;xfer_len == 0U))
<a name="l02034"></a>02034         {
<a name="l02035"></a>02035           hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>-&gt;DADDR = ((uint16_t)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a795a07e094bc7bc5a4dc3e149d7a33c7">USB_Address</a> | USB_DADDR_EF);
<a name="l02036"></a>02036           hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a795a07e094bc7bc5a4dc3e149d7a33c7">USB_Address</a> = 0U;
<a name="l02037"></a>02037         }
<a name="l02038"></a>02038       }
<a name="l02039"></a>02039       <span class="keywordflow">else</span>
<a name="l02040"></a>02040       {
<a name="l02041"></a>02041         <span class="comment">/* DIR = 1 */</span>
<a name="l02042"></a>02042 
<a name="l02043"></a>02043         <span class="comment">/* DIR = 1 &amp; CTR_RX       =&gt; SETUP or OUT int */</span>
<a name="l02044"></a>02044         <span class="comment">/* DIR = 1 &amp; (CTR_TX | CTR_RX) =&gt; 2 int pending */</span>
<a name="l02045"></a>02045         ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[0];
<a name="l02046"></a>02046         wEPVal = <a class="code" href="group/group__PCD__Private__Macros.html#ga09b8919a2ec0460a256ef2cbe2e59714">PCD_GET_ENDPOINT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>);
<a name="l02047"></a>02047 
<a name="l02048"></a>02048         <span class="keywordflow">if</span> ((wEPVal &amp; USB_EP_SETUP) != 0U)
<a name="l02049"></a>02049         {
<a name="l02050"></a>02050           <span class="comment">/* Get SETUP Packet*/</span>
<a name="l02051"></a>02051           ep-&gt;xfer_count = <a class="code" href="group/group__PCD__Private__Macros.html#ga583c3ba5673461d38a7d821a4b5b2401">PCD_GET_EP_RX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053           USB_ReadPMA(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, (uint8_t *)hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a1b0969b24339de5dd49515ef1282743c">Setup</a>,
<a name="l02054"></a>02054                       ep-&gt;pmaadress, (uint16_t)ep-&gt;xfer_count);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056           <span class="comment">/* SETUP bit kept frozen while CTR_RX = 1*/</span>
<a name="l02057"></a>02057           <a class="code" href="group/group__PCD__Private__Macros.html#ga2e4a8b09874d22ec68b9808ffbd8de93" title="Clears bit CTR_RX / CTR_TX in the endpoint register.">PCD_CLEAR_RX_EP_CTR</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>);
<a name="l02058"></a>02058 
<a name="l02059"></a>02059           <span class="comment">/* Process SETUP Packet*/</span>
<a name="l02060"></a>02060 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l02061"></a>02061 <span class="preprocessor"></span>          hpcd-&gt;SetupStageCallback(hpcd);
<a name="l02062"></a>02062 <span class="preprocessor">#else</span>
<a name="l02063"></a>02063 <span class="preprocessor"></span>          <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga9d72aa4d3d984b164047b081d4566f6d" title="Setup stage callback.">HAL_PCD_SetupStageCallback</a>(hpcd);
<a name="l02064"></a>02064 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l02065"></a>02065         }
<a name="l02066"></a>02066 
<a name="l02067"></a>02067         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((wEPVal &amp; USB_EP_CTR_RX) != 0U)
<a name="l02068"></a>02068         {
<a name="l02069"></a>02069           <a class="code" href="group/group__PCD__Private__Macros.html#ga2e4a8b09874d22ec68b9808ffbd8de93" title="Clears bit CTR_RX / CTR_TX in the endpoint register.">PCD_CLEAR_RX_EP_CTR</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071           <span class="comment">/* Get Control Data OUT Packet*/</span>
<a name="l02072"></a>02072           ep-&gt;xfer_count = <a class="code" href="group/group__PCD__Private__Macros.html#ga583c3ba5673461d38a7d821a4b5b2401">PCD_GET_EP_RX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02073"></a>02073 
<a name="l02074"></a>02074           <span class="keywordflow">if</span> ((ep-&gt;xfer_count != 0U) &amp;&amp; (ep-&gt;xfer_buff != 0U))
<a name="l02075"></a>02075           {
<a name="l02076"></a>02076             USB_ReadPMA(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;xfer_buff,
<a name="l02077"></a>02077                         ep-&gt;pmaadress, (uint16_t)ep-&gt;xfer_count);
<a name="l02078"></a>02078 
<a name="l02079"></a>02079             ep-&gt;xfer_buff += ep-&gt;xfer_count;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081             <span class="comment">/* Process Control Data OUT Packet*/</span>
<a name="l02082"></a>02082 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l02083"></a>02083 <span class="preprocessor"></span>            hpcd-&gt;DataOutStageCallback(hpcd, 0U);
<a name="l02084"></a>02084 <span class="preprocessor">#else</span>
<a name="l02085"></a>02085 <span class="preprocessor"></span>            <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>(hpcd, 0U);
<a name="l02086"></a>02086 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l02087"></a>02087           }
<a name="l02088"></a>02088 
<a name="l02089"></a>02089           <a class="code" href="group/group__PCD__Private__Macros.html#gae2e17b7fdfdfb07e1f8587accd3ac433">PCD_SET_EP_RX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>, ep-&gt;maxpacket);
<a name="l02090"></a>02090           <a class="code" href="group/group__PCD__Private__Macros.html#gac0b77bb4ecc3ce2b6a10181cc3033502" title="sets the status for rx transfer (bits STAT_TX[1:0])">PCD_SET_EP_RX_STATUS</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, <a class="code" href="group/group__PCD__ENDP.html#gacb9e0e8226d7a6298cc855e30096fd20">PCD_ENDP0</a>, USB_EP_RX_VALID);
<a name="l02091"></a>02091         }
<a name="l02092"></a>02092       }
<a name="l02093"></a>02093     }
<a name="l02094"></a>02094     <span class="keywordflow">else</span>
<a name="l02095"></a>02095     {
<a name="l02096"></a>02096       <span class="comment">/* Decode and service non control endpoints interrupt  */</span>
<a name="l02097"></a>02097 
<a name="l02098"></a>02098       <span class="comment">/* process related endpoint register */</span>
<a name="l02099"></a>02099       wEPVal = <a class="code" href="group/group__PCD__Private__Macros.html#ga09b8919a2ec0460a256ef2cbe2e59714">PCD_GET_ENDPOINT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, epindex);
<a name="l02100"></a>02100       <span class="keywordflow">if</span> ((wEPVal &amp; USB_EP_CTR_RX) != 0U)
<a name="l02101"></a>02101       {
<a name="l02102"></a>02102         <span class="comment">/* clear int flag */</span>
<a name="l02103"></a>02103         <a class="code" href="group/group__PCD__Private__Macros.html#ga2e4a8b09874d22ec68b9808ffbd8de93" title="Clears bit CTR_RX / CTR_TX in the endpoint register.">PCD_CLEAR_RX_EP_CTR</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, epindex);
<a name="l02104"></a>02104         ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a2715e9254d360b384153353cc620cb46">OUT_ep</a>[epindex];
<a name="l02105"></a>02105 
<a name="l02106"></a>02106         <span class="comment">/* OUT double Buffering*/</span>
<a name="l02107"></a>02107         <span class="keywordflow">if</span> (ep-&gt;doublebuffer == 0U)
<a name="l02108"></a>02108         {
<a name="l02109"></a>02109           count = (uint16_t)<a class="code" href="group/group__PCD__Private__Macros.html#ga583c3ba5673461d38a7d821a4b5b2401">PCD_GET_EP_RX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02110"></a>02110           <span class="keywordflow">if</span> (count != 0U)
<a name="l02111"></a>02111           {
<a name="l02112"></a>02112             USB_ReadPMA(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;xfer_buff, ep-&gt;pmaadress, count);
<a name="l02113"></a>02113           }
<a name="l02114"></a>02114         }
<a name="l02115"></a>02115         <span class="keywordflow">else</span>
<a name="l02116"></a>02116         {
<a name="l02117"></a>02117           <span class="keywordflow">if</span> ((<a class="code" href="group/group__PCD__Private__Macros.html#ga09b8919a2ec0460a256ef2cbe2e59714">PCD_GET_ENDPOINT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num) &amp; USB_EP_DTOG_RX) != 0U)
<a name="l02118"></a>02118           {
<a name="l02119"></a>02119             <span class="comment">/*read from endpoint BUF0Addr buffer*/</span>
<a name="l02120"></a>02120             count = (uint16_t)<a class="code" href="group/group__PCD__Private__Macros.html#ga46eec745fe033fbc1d5f7fa39f8fb88a" title="Gets buffer 0/1 rx/tx counter for double buffering.">PCD_GET_EP_DBUF0_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02121"></a>02121             <span class="keywordflow">if</span> (count != 0U)
<a name="l02122"></a>02122             {
<a name="l02123"></a>02123               USB_ReadPMA(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;xfer_buff, ep-&gt;pmaaddr0, count);
<a name="l02124"></a>02124             }
<a name="l02125"></a>02125           }
<a name="l02126"></a>02126           <span class="keywordflow">else</span>
<a name="l02127"></a>02127           {
<a name="l02128"></a>02128             <span class="comment">/*read from endpoint BUF1Addr buffer*/</span>
<a name="l02129"></a>02129             count = (uint16_t)<a class="code" href="group/group__PCD__Private__Macros.html#ga2e2ccf9f6e7344594a6e8ab9e3e6d849">PCD_GET_EP_DBUF1_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02130"></a>02130             <span class="keywordflow">if</span> (count != 0U)
<a name="l02131"></a>02131             {
<a name="l02132"></a>02132               USB_ReadPMA(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;xfer_buff, ep-&gt;pmaaddr1, count);
<a name="l02133"></a>02133             }
<a name="l02134"></a>02134           }
<a name="l02135"></a>02135           <span class="comment">/* free EP OUT Buffer */</span>
<a name="l02136"></a>02136           <a class="code" href="group/group__PCD__Private__Macros.html#ga3e9e55a81ab8a3f6936810a65642bf72" title="free buffer used from the application realizing it to the line toggles bit SW_BUF in the double buffe...">PCD_FreeUserBuffer</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num, 0U);
<a name="l02137"></a>02137         }
<a name="l02138"></a>02138         <span class="comment">/*multi-packet on the NON control OUT endpoint*/</span>
<a name="l02139"></a>02139         ep-&gt;xfer_count += count;
<a name="l02140"></a>02140         ep-&gt;xfer_buff += count;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142         <span class="keywordflow">if</span> ((ep-&gt;xfer_len == 0U) || (count &lt; ep-&gt;maxpacket))
<a name="l02143"></a>02143         {
<a name="l02144"></a>02144           <span class="comment">/* RX COMPLETE */</span>
<a name="l02145"></a>02145 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l02146"></a>02146 <span class="preprocessor"></span>          hpcd-&gt;DataOutStageCallback(hpcd, ep-&gt;num);
<a name="l02147"></a>02147 <span class="preprocessor">#else</span>
<a name="l02148"></a>02148 <span class="preprocessor"></span>          <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga2f1ac834d9677dcae7d8973828f81149" title="Data OUT stage callback.">HAL_PCD_DataOutStageCallback</a>(hpcd, ep-&gt;num);
<a name="l02149"></a>02149 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l02150"></a>02150         }
<a name="l02151"></a>02151         <span class="keywordflow">else</span>
<a name="l02152"></a>02152         {
<a name="l02153"></a>02153           (void)<a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga0029fe7a8d3db91b13637e2507fba60c" title="Receive an amount of data.">HAL_PCD_EP_Receive</a>(hpcd, ep-&gt;num, ep-&gt;xfer_buff, ep-&gt;xfer_len);
<a name="l02154"></a>02154         }
<a name="l02155"></a>02155 
<a name="l02156"></a>02156       } <span class="comment">/* if((wEPVal &amp; EP_CTR_RX) */</span>
<a name="l02157"></a>02157 
<a name="l02158"></a>02158       <span class="keywordflow">if</span> ((wEPVal &amp; USB_EP_CTR_TX) != 0U)
<a name="l02159"></a>02159       {
<a name="l02160"></a>02160         ep = &amp;hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#a8b97be96cb8c2765f61c50c373b0aef4">IN_ep</a>[epindex];
<a name="l02161"></a>02161 
<a name="l02162"></a>02162         <span class="comment">/* clear int flag */</span>
<a name="l02163"></a>02163         <a class="code" href="group/group__PCD__Private__Macros.html#ga2acbe2a407b78b2da6523ab655c63efe">PCD_CLEAR_TX_EP_CTR</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, epindex);
<a name="l02164"></a>02164 
<a name="l02165"></a>02165         <span class="comment">/*multi-packet on the NON control IN endpoint*/</span>
<a name="l02166"></a>02166         ep-&gt;xfer_count = <a class="code" href="group/group__PCD__Private__Macros.html#ga5b1ae84bc910a8f8dfb57b85f68c77cc" title="gets counter of the tx buffer.">PCD_GET_EP_TX_CNT</a>(hpcd-&gt;<a class="code" href="structPCD__HandleTypeDef.html#afd50525fd795b4f93a09a0e606ec6b2c">Instance</a>, ep-&gt;num);
<a name="l02167"></a>02167         ep-&gt;xfer_buff += ep-&gt;xfer_count;
<a name="l02168"></a>02168 
<a name="l02169"></a>02169         <span class="comment">/* Zero Length Packet? */</span>
<a name="l02170"></a>02170         <span class="keywordflow">if</span> (ep-&gt;xfer_len == 0U)
<a name="l02171"></a>02171         {
<a name="l02172"></a>02172           <span class="comment">/* TX COMPLETE */</span>
<a name="l02173"></a>02173 <span class="preprocessor">#if (USE_HAL_PCD_REGISTER_CALLBACKS == 1U)</span>
<a name="l02174"></a>02174 <span class="preprocessor"></span>          hpcd-&gt;DataInStageCallback(hpcd, ep-&gt;num);
<a name="l02175"></a>02175 <span class="preprocessor">#else</span>
<a name="l02176"></a>02176 <span class="preprocessor"></span>          <a class="code" href="group/group__PCD__Exported__Functions__Group2.html#ga1679f5c50539a3dfca1391557e7a757b" title="Data IN stage callback.">HAL_PCD_DataInStageCallback</a>(hpcd, ep-&gt;num);
<a name="l02177"></a>02177 <span class="preprocessor">#endif </span><span class="comment">/* USE_HAL_PCD_REGISTER_CALLBACKS */</span>
<a name="l02178"></a>02178         }
<a name="l02179"></a>02179         <span class="keywordflow">else</span>
<a name="l02180"></a>02180         {
<a name="l02181"></a>02181           (void)<a class="code" href="group/group__PCD__Exported__Functions__Group3.html#ga116ada543442c8f7a1003c4d4c211618" title="Send an amount of data.">HAL_PCD_EP_Transmit</a>(hpcd, ep-&gt;num, ep-&gt;xfer_buff, ep-&gt;xfer_len);
<a name="l02182"></a>02182         }
<a name="l02183"></a>02183       }
<a name="l02184"></a>02184     }
<a name="l02185"></a>02185   }
<a name="l02186"></a>02186   <span class="keywordflow">return</span> HAL_OK;
<a name="l02187"></a>02187 }
<a name="l02188"></a>02188 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) */</span>
<a name="l02189"></a>02189 <span class="comment"></span>
<a name="l02190"></a>02190 <span class="comment">/**</span>
<a name="l02191"></a>02191 <span class="comment">  * @}</span>
<a name="l02192"></a>02192 <span class="comment">  */</span>
<a name="l02193"></a>02193 <span class="preprocessor">#endif </span><span class="comment">/* defined (USB) || defined (USB_OTG_FS) */</span>
<a name="l02194"></a>02194 <span class="preprocessor">#endif </span><span class="comment">/* HAL_PCD_MODULE_ENABLED */</span>
<a name="l02195"></a>02195 <span class="comment"></span>
<a name="l02196"></a>02196 <span class="comment">/**</span>
<a name="l02197"></a>02197 <span class="comment">  * @}</span>
<a name="l02198"></a>02198 <span class="comment">  */</span>
<a name="l02199"></a>02199 <span class="comment"></span>
<a name="l02200"></a>02200 <span class="comment">/**</span>
<a name="l02201"></a>02201 <span class="comment">  * @}</span>
<a name="l02202"></a>02202 <span class="comment">  */</span>
<a name="l02203"></a>02203 
<a name="l02204"></a>02204 <span class="comment">/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Tue May 14 2019 08:56:52 for STM32F103xG HAL User Manual by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
